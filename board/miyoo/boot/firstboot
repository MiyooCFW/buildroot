#!/bin/busybox sh

MOUNTDIR=/boot
# expect to be run from /boot, where the boot partition is mounted (readonly)

# create swap
mkswap /dev/mmcblk0p3 | tee -a ${LOG}
swapon /dev/mmcblk0p3 | tee -a ${LOG}

LOG=/dev/null

# high brightness
echo '10' > /sys/devices/platform/backlight/backlight/backlight/brightness

#echo -e "\e[?3c"
echo -e "\e[32m" # green

echo "firstboot script running..." | tee -a ${LOG}
echo

BASEDIR="${MOUNTDIR}"

# action time

# copy over the config files
echo "Copying default configuration files into place..." | tee -a ${LOG}
mount -t vfat -o rw,sync,utf8 /dev/mmcblk0p4 /mnt | tee -a ${LOG}
if test -r "${BASEDIR}/configs/manifest"; then
	cat "${BASEDIR}/configs/manifest" | while read -r LINE; do
		if test "${LINE}" == "${LINE#!}" -a "${LINE}" != "" ; then
			set -- ${LINE}
			# 1               2
			# source_filename target_filename/inside main/
			if test -r "${BASEDIR}/configs/$1"; then
				TO="$2"
				if test "${TO}" == ""; then
					TO="$1"
				fi
				echo "Copying $1 to /mnt/$TO..." | tee -a ${LOG}
				cp -f "${BASEDIR}/configs/$1" "/mnt/$TO" | tee -a ${LOG}
			fi
		fi
	done
fi
echo

# run a custom script if present - could be used to fix u-boot and such
if test -r "${BASEDIR}/firstboot.custom.sh"; then
	echo "Running a specific firstboot script..." | tee -a ${LOG}
	(cd "${BASEDIR}" && sh firstboot.custom.sh) | tee -a ${LOG}
	echo "Finished running a specific firstboot script." | tee -a ${LOG}
fi


echo " "
sleep 1

LICENSE="
The software provided is offered without \
any warranties or guarantees of any kind, either \
expressed or implied. The use of this software is \
entirely at your own risk. We shall not be held \
responsible for any damages, losses, or adverse \
consequences arising from the use or misuse of this software.
\n\n
\ZuDo you acknowledge and agree to these terms?\Zn
\n\n
   Select an option & press START"

## Create temp file to store variable for menu choice
TEMP=$(mktemp) 
## Access /boot directory
mount -o remount,rw "${MOUNTDIR}" | tee -a ${LOG}

# try to read what handheld we're on when calling func
console_var_func(){
	if (test -r "${MOUNTDIR}/console.cfg"); then
		source "${MOUNTDIR}/console.cfg"
	else 
		export CONSOLE_VARIANT="unknown"
	fi
}

# sync & unmount MAIN whenever needed
safe_reboot_func(){
	echo "please wait a few seconds for a reboot...." | tee -a ${LOG}
	sync
	sleep 0.1
	umount /dev/mmcblk0p4 | tee -a ${LOG}
	#umount /dev/mmcblk0p1 | tee -a ${LOG} # this fails
	sleep 2
	reboot
}

safe_poweroff_func(){
	echo "please wait a few seconds for a shutdown...." | tee -a ${LOG}
	sync
	sleep 0.1
	umount /dev/mmcblk0p4 | tee -a ${LOG}
	#umount /dev/mmcblk0p1 | tee -a ${LOG} # this fails
	sleep 2
	poweroff
}

# list of available devices in u-boot Environment parameters' read from FORCE_VERSION
devices_ID="
bittboy2x_v1
bittboy2x_v2
bittboy3.5
q20
q90
v90
pocketgo
pocketgo_TE
xyc_gc9306
m3_r61520
m3_rm68090
m3_hx8347d
m3_gc9306
"

# list of available devices in u-boot Environment parameters' read from Auto-Detection method
devices_auto_ID="
st7789s
bittboy
bittboy2
bittboy3
xyc
m3
"

# list of available devices in this flashing procedure read from DETECTED_VERSION in u-boot Environment parameters'
DETECTED_1="V90/Q90/Q20/PocketGo ST7789S controller"
DETECTED_2="GC9306/GC9305 controller from gc9306fb"
DETECTED_3="SUP M3 unknown controller Works with R61520"
DETECTED_4="bittboy r61520fb controller"
DETECTED_5="bittboy2 ST7789S controller"
DETECTED_6="bittboy3 ST7789S controller"
DETECTED_7="RM68090 controller"
DETECTED_8="R61520 controller"
DETECTED_9="R61505W controller"
DETECTED_10="HX8347-D controller"
DETECTED_11="UNKNOWN"

## Defaulting to "not found the console in string list"
export FOUND_CONSOLE=false
export FOUND_CONSOLE_AUTO=false

find_console_func(){
for i in $devices_ID; do
	if test "$i" = "$CONSOLE_VARIANT"; then
		export FOUND_CONSOLE=true
		break
	fi
done
}

find_console_auto_func(){
for i in $devices_auto_ID; do
	if test "$i" = "$CONSOLE_VARIANT"; then
		export FOUND_CONSOLE_AUTO=true
		break
	fi
done
}

detect_console_func(){
	console_var_func
	find_console_func
	find_console_auto_func
}

export CONSOLE_DETECTED=false
#Checking if device at hand is operational within flashing procedure 
if (grep -qE "${DETECTED_1}|${DETECTED_2}|${DETECTED_3}|${DETECTED_4}|${DETECTED_5}|${DETECTED_6}|${DETECTED_7}|${DETECTED_8}|${DETECTED_9}|${DETECTED_10}|${DETECTED_11}" "${MOUNTDIR}/uEnv.txt"); then
	CONSOLE_DETECTED=true
fi

detect_console_func
if ! $FOUND_CONSOLE && ! $FOUND_CONSOLE_AUTO && $CONSOLE_DETECTED; then
	if (grep -q "$DETECTED_1" "${MOUNTDIR}/uEnv.txt"); then
		dialog --timeout 3 --msgbox  "Auto-Detected $DETECTED_1" 0 0
		# Test_Video if proper miyoo video's version driver was loaded:
		test_video_func(){
			dialog --defaultno --ok-label NO --cancel-label "Flipped!" --extra-button --extra-label YES --stdout --title   "   Test Video" \
			--colors --pause "\n\n   \ZuCan you see this message?\Zn\n\nSelect an option & press START" 12 34 10

			echo $? > $TEMP
			## Read the user's first choice from the tmp file
			CHOICE=$(cat $TEMP)

			# "YES" choice for Test_Video msgbox DIALOG_EXTRA exit code
			if test $CHOICE -eq 3; then
				# Correct variant for st7789s (non forced)
				echo "CONSOLE_VARIANT=st7789s" > ${MOUNTDIR}/console.cfg	
			# "Flipped!" choice for Test_Video msgbox DIALOG_CANCEL exit code
			elif test $CHOICE -eq 1; then
				# Correct variant for bittboy3.5 (non forced) and display info about flipped image
				echo "CONSOLE_VARIANT=bittboy3" > ${MOUNTDIR}/console.cfg
				dialog --timeout 2 --msgbox "Image flipped! correct&reboot" 0 0
				#TODO: use special Unicode characters to draw text upside-down e.g.:
				## dialog --timeout 2 --msgbox "ƃuᴉʇooqǝɹ⅋uᴉʇɔǝɹɹoɔ 'pǝddᴉןɟ ǝƃɐɯᴉ \n\n image flipped, correcting&rebooting" 0 0
				safe_reboot_func
			# "NO" or timeout choice for Test_Video msgbox thus DIALOG_OK exit code
			elif test $CHOICE -eq 0; then
				# Correct variant for bittboy2x_v1 (non forced)
				echo "CONSOLE_VARIANT=bittboy" > ${MOUNTDIR}/console.cfg
				safe_reboot_func
			# Error (DIALOG_ERROR) or ESCAPE button pressed (DIALOG_ESCAPE) thus exit code -1/255
			else
				dialog --timeout 2 --msgbox "Invalid choice, please redo the test!" 0 0
				sleep 1.5
			fi
		}
		
		# Loop Test_Video until correct selection has been performed (CHOICE=0/1/3)
		while true; do
			test_video_func
			if !(test $CHOICE -eq -1 || test $CHOICE -eq 255); then
				break
			fi
		done
	elif (grep -q "$DETECTED_2" "${MOUNTDIR}/uEnv.txt"); then
		dialog --timeout 3 --msgbox  "Auto-Detected $DETECTED_2" 0 0
		echo "CONSOLE_VARIANT=m3" > ${MOUNTDIR}/console.cfg
	elif (grep -q "$DETECTED_3" "${MOUNTDIR}/uEnv.txt"); then
		dialog --timeout 3 --msgbox  "Auto-Detected $DETECTED_3" 0 0
		# Test_Image if proper "invert" colors parameter was loaded: 
		dialog --defaultno --ok-label NO --cancel-label Inverted --stdout --title   "  Test Image" \
		--colors --pause "\n\n  \ZuAre your colors Inverted?\Zn\n\nSelect an option & press START" 12 34 10

		echo $? > $TEMP
		echo "CONSOLE_VARIANT=m3_r61520" > ${MOUNTDIR}/console.cfg
		## Read the user's last choice from the tmp file
		CHOICE=$(cat $TEMP)
		# "NO" choice for Test_Image msgbox DIALOG_OK exit code
		## thus we have valid version and simply continue
		if test $CHOICE -eq 0; then
			echo "Colors are correct, proceed with flashing"
		# "INVERTED" choice for Test_Iamge msgbox DIALOG_CANCEL exit code and -1/255
		## thus correct "invert" colors parameter on video driver
		else
#TODO - make "invert" flag overwriting less dependent
			echo "INVERT=0" >> /mnt/options.cfg
			safe_reboot_func
		fi
	elif (grep -q "$DETECTED_4" "${MOUNTDIR}/uEnv.txt"); then
		dialog --timeout 3 --msgbox  "Auto-Detected $DETECTED_4" 0 0
		echo "CONSOLE_VARIANT=bittboy" > ${MOUNTDIR}/console.cfg
	elif (grep -q "$DETECTED_5" "${MOUNTDIR}/uEnv.txt"); then
		dialog --timeout 3 --msgbox  "Auto-Detected $DETECTED_5" 0 0
		echo "CONSOLE_VARIANT=bittboy2" > ${MOUNTDIR}/console.cfg
	elif (grep -q "$DETECTED_6" "${MOUNTDIR}/uEnv.txt"); then
		dialog --timeout 3 --msgbox  "Auto-Detected $DETECTED_6" 0 0
		echo "CONSOLE_VARIANT=bittboy3" > ${MOUNTDIR}/console.cfg
	elif (grep -q "$DETECTED_7" "${MOUNTDIR}/uEnv.txt"); then
		dialog --timeout 3 --msgbox  "Auto-Detected $DETECTED_7" 0 0
		echo "CONSOLE_VARIANT=m3_rm68090" > ${MOUNTDIR}/console.cfg
	elif (grep -q "$DETECTED_8" "${MOUNTDIR}/uEnv.txt"); then
		dialog --timeout 3 --msgbox  "Auto-Detected $DETECTED_8" 0 0
		#echo "CONSOLE_VARIANT=r61520" > ${MOUNTDIR}/console.cfg
	elif (grep -q "$DETECTED_9" "${MOUNTDIR}/uEnv.txt"); then
		dialog --timeout 3 --msgbox  "Auto-Detected $DETECTED_9" 0 0
		#echo "CONSOLE_VARIANT=r61505w" > ${MOUNTDIR}/console.cfg
	elif (grep -q "$DETECTED_10" "${MOUNTDIR}/uEnv.txt"); then
		dialog --timeout 3 --msgbox  "Auto-Detected $DETECTED_10" 0 0
		echo "CONSOLE_VARIANT=m3_hx8347d" > ${MOUNTDIR}/console.cfg
	elif (grep -q "$DETECTED_11" "${MOUNTDIR}/uEnv.txt"); then
		dialog --timeout 3 --msgbox  "Auto-Detected $DETECTED_11" 0 0
		#echo "CONSOLE_VARIANT=unknown-error" > ${MOUNTDIR}/console.cfg
	fi
	# Overwrite CONSOLE_VARIANT from new entry
	source "${MOUNTDIR}/console.cfg"
fi

console_unknown_func(){
	echo "CONSOLE_VARIANT=unknown" > ${MOUNTDIR}/console.cfg
	echo "##DO_NOT_REMOVE_THIS_LINE##" >> ${MOUNTDIR}/console.cfg
}

# Defaulting to console overwriting inactive
export CONSOLE_OVERWRITE=false
# Test if console have been found in devices_auto_ID
detect_console_func
# test if no device specified in console.cfg
if ! $FOUND_CONSOLE && $FOUND_CONSOLE_AUTO && $CONSOLE_DETECTED; then
	## show selection menu for ST7789S devices
	### TODO: test also if "<DETECTED_VERSION>"="$DETECTED_?" depending on current CONSOLE_VARIANT
	if test "$CONSOLE_VARIANT" == "st7789s"; then
		dialog --clear --timeout 60 --title "Select your device:" --menu " " 15 40 5 \
		1 "Powkiddy Q20" \
		2 "Powkiddy Q90" \
		3 "Powkiddy V90" \
		4 "PocketGO (default)" \
		5 "PocketGO with TE pin" \
		2> $TEMP
		## Defaulting to console overwriting active
		export CONSOLE_OVERWRITE=true
		
		## Default CONSOLE_VARIANT for st7789s screns
		default_console_func(){
			echo "CONSOLE_VARIANT=pocketgo" > ${MOUNTDIR}/console.cfg
			# No need to overwrite uboot FORCE version for default so continue procedure
			export CONSOLE_OVERWRITE=false
		}
		## Read the user's choice from the file
		CHOICE=$(cat $TEMP)
		## Perform actions based on the user's choice
		case $CHOICE in
			1)
				echo "CONSOLE_VARIANT=q20" > ${MOUNTDIR}/console.cfg
				;;
			2)
				echo "CONSOLE_VARIANT=q90" > ${MOUNTDIR}/console.cfg
				;;
			3)
				echo "CONSOLE_VARIANT=v90" > ${MOUNTDIR}/console.cfg
				;;
			4)
				default_console_func
				;;
			5)
				echo "CONSOLE_VARIANT=pocketgo_TE" > ${MOUNTDIR}/console.cfg
				;;
			*)
				dialog --timeout 4 --msgbox "Invalid choice. Exiting and selecting default device from autodetection." 0 0
				default_console_func
				sleep 0.1
				;;
		esac
	# Test_Keyboard if proper miyoo.kbd  version was loaded: 
	elif test "$CONSOLE_VARIANT" == "bittboy3" || test "$CONSOLE_VARIANT" == "bittboy2" || test "$CONSOLE_VARIANT" == "xyc" || test "$CONSOLE_VARIANT" == "m3"; then
		test_keyboard_func(){
			dialog --ok-label NO --cancel-label YES --stdout --title   "  Test Keyboard" \
			--colors --pause "\n\n  \ZuDoes D-pad works correctly?\Zn\n\nSelect an option & press START" 12 34 10

			echo $? > $TEMP
			## Read the user's last choice from the tmp file
			CHOICE=$(cat $TEMP)

			# "YES" choice for Test_Keyboard msgbox DIALOG_CANCEL exit code
			## thus we have valid version, just update to FORCE_VERSION and continue
			if test $CHOICE -eq 1; then
				if test "$CONSOLE_VARIANT" == "bittboy3"; then
					echo "CONSOLE_VARIANT=bittboy3.5" > ${MOUNTDIR}/console.cfg
				elif test "$CONSOLE_VARIANT" == "bittboy2"; then
					echo "CONSOLE_VARIANT=bittboy2x_v2" > ${MOUNTDIR}/console.cfg
				elif test "$CONSOLE_VARIANT" == "xyc"; then
					echo "CONSOLE_VARIANT=xyc_gc9306" > ${MOUNTDIR}/console.cfg
				elif test "$CONSOLE_VARIANT" == "m3"; then
					echo "CONSOLE_VARIANT=m3_gc9306" > ${MOUNTDIR}/console.cfg
				fi
			# "NO" or timeout choice for Test_Keyboard msgbox DIALOG_OK exit code
			## thus correct Auto-Detection variant and reboot
			elif test $CHOICE -eq 0; then
				if test "$CONSOLE_VARIANT" == "bittboy3"; then
					echo "CONSOLE_VARIANT=bittboy2" > ${MOUNTDIR}/console.cfg
				elif test "$CONSOLE_VARIANT" == "bittboy2"; then
					console_unknown_func
				elif test "$CONSOLE_VARIANT" == "xyc"; then
					console_unknown_func
				elif test "$CONSOLE_VARIANT" == "m3"; then
					echo "CONSOLE_VARIANT=xyc" > ${MOUNTDIR}/console.cfg
				fi
				safe_reboot_func
			# Error (DIALOG_ERROR) or ESCAPE button pressed (DIALOG_ESCAPE) thus exit code -1/255
			else
				dialog --timeout 2 --msgbox "Invalid choice, please redo the test!" 0 0
				sleep 1.5
			fi
		}
		# Loop Test_Keyboard until correct selection has been performed (CHOICE=0/1)
		while true; do
			test_keyboard_func
			if !(test $CHOICE -eq -1 || test $CHOICE -eq 255); then
				break
			fi
		done
	elif test "$CONSOLE_VARIANT" == "bittboy"; then
		# Test_Video'2 if proper miyoo video's version driver was loaded:
		dialog --defaultno --ok-label NO --cancel-label YES --stdout --title   "   Test Video'2" \
		--colors --pause "\n\n   \ZuCan you see this message?\Zn\n\nSelect an option & press START" 12 34 10
		
		echo $? > $TEMP
		## Read the user's last choice from the tmp file
		CHOICE=$(cat $TEMP)
		# "YES" choice for Test_Video'2 msgbox DIALOG_CANCEL exit code
		## thus we have valid version, just update to FORCE_VERSION and continue
		if test $CHOICE -eq 1; then
			echo "CONSOLE_VARIANT=bittboy2x_v1" > ${MOUNTDIR}/console.cfg
		# "NO" or timeout choice for Test_Video msgbox thus DIALOG_OK exit code 0 (or ERROR/ESCAPE with -1/255)
		## correct variant to unknown and redo whole flashing_prd again
		else
			console_unknown_func			
			safe_reboot_func
		fi
	fi
fi

detect_console_func
if $FOUND_CONSOLE; then
	# Info_Box about selected/edited device in console.cfg
	case $CONSOLE_VARIANT in
		bittboy2x_v1)
				dialog --colors --timeout 2 --ok-label " Your device " --msgbox " BittBoy2x v1" 5 18
				;;
		bittboy2x_v2)
				dialog --colors --timeout 2 --ok-label " Your device " --msgbox " BittBoy2x v2" 5 18
				;;
		bittboy3.5)
				dialog --colors --timeout 2 --ok-label " Your device " --msgbox " BittBoy3.5" 5 18
				;;
		q20)
				dialog --colors --timeout 2 --ok-label " Your device " --msgbox " Powkiddy Q20" 5 18
				;;
		q90)
				dialog --colors --timeout 2 --ok-label " Your device " --msgbox " Powkiddy Q90" 5 18
				;;
		v90)
				dialog --colors --timeout 2 --ok-label " Your device " --msgbox " Powkiddy V90" 5 18
				;;
		pocketgo)
				dialog --colors --timeout 2 --ok-label " Your device " --msgbox " PocketGo" 5 18
				;;
		pocketgo_TE)
				dialog --colors --timeout 2 --ok-label " Your device " --msgbox " PocketGo+TE" 5 18
				;;
		xyc_gc9306)
				dialog --colors --timeout 2 --ok-label " Your device " --msgbox " XYC Q8" 5 18
				;;
		m3_r61520)
				dialog --colors --timeout 2 --ok-label " Your device " --msgbox "         SUP M3\n (controller of r61520fb)" 6 29
				;;
		m3_rm68090)
				dialog --colors --timeout 2 --ok-label " Your device " --msgbox "      SUP M3\n(RM68090 controller)" 6 24
				;;
		m3_hx8347d)
				dialog --colors --timeout 2 --ok-label " Your device " --msgbox "      SUP M3\n(HX8347D controller)" 6 24
				;;
		m3_gc9306)
				dialog --colors --timeout 2 --ok-label " Your device " --msgbox "      SUP M3\n(GC9306 controller)" 6 24
				;;
		*)
				dialog --colors --timeout 2 --ok-label " Your device " --msgbox "\Zb\Z1 Unknown-Error\Zn" 5 18
	esac
	# Test_Variant if correct CONSOLE_VARIANT has been written to console.cfg
	dialog --defaultno --ok-label NO --cancel-label YES --stdout --title   "   Test Variant" \
	--colors --pause "Does this device match yours?" 0 0 15
	
	echo $? > $TEMP
	## Read the user's last choice from the tmp file
	CHOICE=$(cat $TEMP)
	# Any choice different than "YES" from Test_Variant - that is 0/-1/255 exit code
	## correct variant to unknown and redo whole flashing_prd again
	if !(test $CHOICE -eq 1); then
		console_unknown_func			
		safe_reboot_func
	fi
else
	dialog --colors --timeout 2 --ok-label " Your device " --msgbox "\Zb\Z1 Unknown\Zn" 5 18
	console_unknown_func
fi

#License prompt
if (dialog --clear --ok-label NO --cancel-label YES --stdout --title "   License agreement" \
	--colors --pause "\n              \ZbMiyooCFW\Zn\n$LICENSE" 22 60 30 || test $? -eq 255); then
	echo -en "     We understand. Have a nice day!\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
	sleep 1
	console_unknown_func
	safe_poweroff_func
fi
mount -o remount,ro "${MOUNTDIR}" | tee -a ${LOG}

export RESIZE_COMMENCED=false
# resize the main partition if requested
if ((test -e "${MOUNTDIR}/resize") && (dialog --clear --stdout --ok-label YES --cancel-label NO --title "   AUTO-RESIZE" \
	--colors --pause "\n\n       \ZuExpand MAIN partition?\Zn\n\n   Select an option & press START
	\n\n             \ZbWARNING:\Zn\n       After 10s auto-resize\n   of FAT32 partition will begin." 15 60 10)); then
	clear
	echo "Going to resize the MAIN partition." | tee -a ${LOG}
	echo "This can take A LONG TIME, so be patient." | tee -a ${LOG}
	umount /dev/mmcblk0p4 | tee -a ${LOG}
	fsck.fat -y /dev/mmcblk0p4 | tee -a ${LOG}
	fatresize -s max -v -p /dev/mmcblk0p4 -n 4
	fsck.fat -y /dev/mmcblk0p4 | tee -a ${LOG}
	echo -n -e \\xEB\\x58\\x90 > /dev/mmcblk0p4
	sync
	mount -t vfat -o rw,sync,utf8 /dev/mmcblk0p4 /mnt | tee -a ${LOG}
	export RESIZE_COMMENCED=true
fi

# Cleanup - delete the temporary file storing variable value
rm $TEMP

# disable this script
mount -o remount,rw "${MOUNTDIR}" | tee -a ${LOG}
echo "Disabling the firstboot script." | tee -a ${LOG}
mv "${MOUNTDIR}/firstboot" "${MOUNTDIR}/firstboot.done" | tee -a ${LOG}
if test -e "${MOUNTDIR}/resize"; then
	rm "${MOUNTDIR}/resize"
fi
mount -o remount,ro "${MOUNTDIR}" | tee -a ${LOG}

echo

sync
echo "firstboot script finished." | tee -a ${LOG}

echo

# Reboot device if CONSOLE_VARIANT was overwritten from $CHOICE so that it could be applied in u-boot by readID 
## or resizing FAT partition has completed / found firstboot custom script
if ($CONSOLE_OVERWRITE || $RESIZE_COMMENCED || test -r "${BASEDIR}/firstboot.custom.sh"); then
	safe_reboot_func
fi
