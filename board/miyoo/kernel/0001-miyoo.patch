diff --git a/Documentation/devicetree/bindings/interrupt-controller/allwinner,sun4i-ic.txt b/Documentation/devicetree/bindings/interrupt-controller/allwinner,sun4i-ic.txt
index b290ca15..3b709612 100644
--- a/Documentation/devicetree/bindings/interrupt-controller/allwinner,sun4i-ic.txt
+++ b/Documentation/devicetree/bindings/interrupt-controller/allwinner,sun4i-ic.txt
@@ -2,7 +2,9 @@ Allwinner Sunxi Interrupt Controller
 
 Required properties:
 
-- compatible : should be "allwinner,sun4i-a10-ic"
+- compatible : should be one of
+	"allwinner,suniv-f1c100s-ic"
+	"allwinner,sun4i-a10-ic"
 - reg : Specifies base physical address and size of the registers.
 - interrupt-controller : Identifies the node as an interrupt controller
 - #interrupt-cells : Specifies the number of cells needed to encode an
diff --git a/Documentation/devicetree/bindings/timer/allwinner,sun4i-timer.txt b/Documentation/devicetree/bindings/timer/allwinner,sun4i-timer.txt
index 5c2e2357..5d4916c0 100644
--- a/Documentation/devicetree/bindings/timer/allwinner,sun4i-timer.txt
+++ b/Documentation/devicetree/bindings/timer/allwinner,sun4i-timer.txt
@@ -2,7 +2,9 @@ Allwinner A1X SoCs Timer Controller
 
 Required properties:
 
-- compatible : should be "allwinner,sun4i-a10-timer"
+- compatible : should be one of
+	"allwinner,suniv-f1c100s-timer"
+	"allwinner,sun4i-a10-timer"
 - reg : Specifies base physical address and size of the registers.
 - interrupts : The interrupt of the first timer
 - clocks: phandle to the source clock (usually a 24 MHz fixed clock)
diff --git a/arch/arm/Kconfig b/arch/arm/Kconfig
index 5473db09..879c4f8c 100644
--- a/arch/arm/Kconfig
+++ b/arch/arm/Kconfig
@@ -833,7 +833,7 @@ source "arch/arm/plat-samsung/Kconfig"
 
 source "arch/arm/mach-shmobile/Kconfig"
 
-source "arch/arm/mach-sunxi/Kconfig"
+source "arch/arm/mach-suniv/Kconfig"
 
 source "arch/arm/mach-prima2/Kconfig"
 
@@ -1477,7 +1477,7 @@ config ARCH_NR_GPIO
 		ARCH_ZYNQ
 	default 512 if ARCH_EXYNOS || ARCH_KEYSTONE || SOC_OMAP5 || \
 		SOC_DRA7XX || ARCH_S3C24XX || ARCH_S3C64XX || ARCH_S5PV210
-	default 416 if ARCH_SUNXI
+	default 416 if ARCH_SUNIV
 	default 392 if ARCH_U8500
 	default 352 if ARCH_VT8500
 	default 288 if ARCH_ROCKCHIP
diff --git a/arch/arm/Makefile b/arch/arm/Makefile
index ce4ba57d..59738f2c 100644
--- a/arch/arm/Makefile
+++ b/arch/arm/Makefile
@@ -215,7 +215,7 @@ machine-$(CONFIG_ARCH_SIRF)		+= prima2
 machine-$(CONFIG_ARCH_SOCFPGA)		+= socfpga
 machine-$(CONFIG_ARCH_STI)		+= sti
 machine-$(CONFIG_ARCH_STM32)		+= stm32
-machine-$(CONFIG_ARCH_SUNXI)		+= sunxi
+machine-$(CONFIG_ARCH_SUNXI_V5)		+= suniv
 machine-$(CONFIG_ARCH_TANGO)		+= tango
 machine-$(CONFIG_ARCH_TEGRA)		+= tegra
 machine-$(CONFIG_ARCH_U300)		+= u300
diff --git a/arch/arm/boot/dts/Makefile b/arch/arm/boot/dts/Makefile
index eff87a34..63cbd3b7 100644
--- a/arch/arm/boot/dts/Makefile
+++ b/arch/arm/boot/dts/Makefile
@@ -817,126 +817,9 @@ dtb-$(CONFIG_ARCH_STM32)+= \
 	stm32746g-eval.dtb \
 	stm32h743i-eval.dtb \
 	stm32h743i-disco.dtb
-dtb-$(CONFIG_MACH_SUN4I) += \
-	sun4i-a10-a1000.dtb \
-	sun4i-a10-ba10-tvbox.dtb \
-	sun4i-a10-chuwi-v7-cw0825.dtb \
-	sun4i-a10-cubieboard.dtb \
-	sun4i-a10-dserve-dsrv9703c.dtb \
-	sun4i-a10-gemei-g9.dtb \
-	sun4i-a10-hackberry.dtb \
-	sun4i-a10-hyundai-a7hd.dtb \
-	sun4i-a10-inet1.dtb \
-	sun4i-a10-inet97fv2.dtb \
-	sun4i-a10-inet9f-rev03.dtb \
-	sun4i-a10-itead-iteaduino-plus.dtb \
-	sun4i-a10-jesurun-q5.dtb \
-	sun4i-a10-marsboard.dtb \
-	sun4i-a10-mini-xplus.dtb \
-	sun4i-a10-mk802.dtb \
-	sun4i-a10-mk802ii.dtb \
-	sun4i-a10-olinuxino-lime.dtb \
-	sun4i-a10-pcduino.dtb \
-	sun4i-a10-pcduino2.dtb \
-	sun4i-a10-pov-protab2-ips9.dtb
-dtb-$(CONFIG_MACH_SUN5I) += \
-	sun5i-a10s-auxtek-t003.dtb \
-	sun5i-a10s-auxtek-t004.dtb \
-	sun5i-a10s-mk802.dtb \
-	sun5i-a10s-olinuxino-micro.dtb \
-	sun5i-a10s-r7-tv-dongle.dtb \
-	sun5i-a10s-wobo-i5.dtb \
-	sun5i-a13-difrnce-dit4350.dtb \
-	sun5i-a13-empire-electronix-d709.dtb \
-	sun5i-a13-empire-electronix-m712.dtb \
-	sun5i-a13-hsg-h702.dtb \
-	sun5i-a13-inet-98v-rev2.dtb \
-	sun5i-a13-licheepi-one.dtb \
-	sun5i-a13-olinuxino.dtb \
-	sun5i-a13-olinuxino-micro.dtb \
-	sun5i-a13-q8-tablet.dtb \
-	sun5i-a13-utoo-p66.dtb \
-	sun5i-gr8-chip-pro.dtb \
-	sun5i-gr8-evb.dtb \
-	sun5i-r8-chip.dtb
-dtb-$(CONFIG_MACH_SUN6I) += \
-	sun6i-a31-app4-evb1.dtb \
-	sun6i-a31-colombus.dtb \
-	sun6i-a31-hummingbird.dtb \
-	sun6i-a31-i7.dtb \
-	sun6i-a31-m9.dtb \
-	sun6i-a31-mele-a1000g-quad.dtb \
-	sun6i-a31s-colorfly-e708-q1.dtb \
-	sun6i-a31s-cs908.dtb \
-	sun6i-a31s-inet-q972.dtb \
-	sun6i-a31s-primo81.dtb \
-	sun6i-a31s-sina31s.dtb \
-	sun6i-a31s-sinovoip-bpi-m2.dtb \
-	sun6i-a31s-yones-toptech-bs1078-v2.dtb
-dtb-$(CONFIG_MACH_SUN7I) += \
-	sun7i-a20-bananapi.dtb \
-	sun7i-a20-bananapi-m1-plus.dtb \
-	sun7i-a20-bananapro.dtb \
-	sun7i-a20-cubieboard2.dtb \
-	sun7i-a20-cubietruck.dtb \
-	sun7i-a20-hummingbird.dtb \
-	sun7i-a20-itead-ibox.dtb \
-	sun7i-a20-i12-tvbox.dtb \
-	sun7i-a20-icnova-swac.dtb \
-	sun7i-a20-lamobo-r1.dtb \
-	sun7i-a20-m3.dtb \
-	sun7i-a20-mk808c.dtb \
-	sun7i-a20-olimex-som-evb.dtb \
-	sun7i-a20-olinuxino-lime.dtb \
-	sun7i-a20-olinuxino-lime2.dtb \
-	sun7i-a20-olinuxino-lime2-emmc.dtb \
-	sun7i-a20-olinuxino-micro.dtb \
-	sun7i-a20-orangepi.dtb \
-	sun7i-a20-orangepi-mini.dtb \
-	sun7i-a20-pcduino3.dtb \
-	sun7i-a20-pcduino3-nano.dtb \
-	sun7i-a20-wexler-tab7200.dtb \
-	sun7i-a20-wits-pro-a20-dkt.dtb
-dtb-$(CONFIG_MACH_SUN8I) += \
-	sun8i-a23-evb.dtb \
-	sun8i-a23-gt90h-v4.dtb \
-	sun8i-a23-inet86dz.dtb \
-	sun8i-a23-ippo-q8h-v5.dtb \
-	sun8i-a23-ippo-q8h-v1.2.dtb \
-	sun8i-a23-polaroid-mid2407pxe03.dtb \
-	sun8i-a23-polaroid-mid2809pxe04.dtb \
-	sun8i-a23-q8-tablet.dtb \
-	sun8i-a33-et-q8-v1.6.dtb \
-	sun8i-a33-ga10h-v1.1.dtb \
-	sun8i-a33-inet-d978-rev2.dtb \
-	sun8i-a33-ippo-q8h-v1.2.dtb \
-	sun8i-a33-olinuxino.dtb \
-	sun8i-a33-q8-tablet.dtb \
-	sun8i-a33-sinlinx-sina33.dtb \
-	sun8i-a83t-allwinner-h8homlet-v2.dtb \
-	sun8i-a83t-bananapi-m3.dtb \
-	sun8i-a83t-cubietruck-plus.dtb \
-	sun8i-h2-plus-orangepi-zero.dtb \
-	sun8i-h3-bananapi-m2-plus.dtb \
-	sun8i-h3-beelink-x2.dtb \
-	sun8i-h3-nanopi-m1.dtb	\
-	sun8i-h3-nanopi-m1-plus.dtb \
-	sun8i-h3-nanopi-neo.dtb \
-	sun8i-h3-nanopi-neo-air.dtb \
-	sun8i-h3-orangepi-2.dtb \
-	sun8i-h3-orangepi-lite.dtb \
-	sun8i-h3-orangepi-one.dtb \
-	sun8i-h3-orangepi-pc.dtb \
-	sun8i-h3-orangepi-pc-plus.dtb \
-	sun8i-h3-orangepi-plus.dtb \
-	sun8i-h3-orangepi-plus2e.dtb \
-	sun8i-r16-bananapi-m2m.dtb \
-	sun8i-r16-parrot.dtb \
-	sun8i-v3s-licheepi-zero.dtb \
-	sun8i-v3s-licheepi-zero-dock.dtb
-dtb-$(CONFIG_MACH_SUN9I) += \
-	sun9i-a80-optimus.dtb \
-	sun9i-a80-cubieboard4.dtb
+dtb-$(CONFIG_MACH_SUNIV) += \
+	suniv-f1c500s-miyoo.dtb \
+	suniv-f1c500s-miyoo-4bit.dtb
 dtb-$(CONFIG_ARCH_TANGO) += \
 	tango4-vantage-1172.dtb
 dtb-$(CONFIG_ARCH_TEGRA_2x_SOC) += \
diff --git a/arch/arm/boot/dts/suniv-f1c500s-miyoo-4bit.dts b/arch/arm/boot/dts/suniv-f1c500s-miyoo-4bit.dts
new file mode 100644
index 00000000..b0e1611a
--- /dev/null
+++ b/arch/arm/boot/dts/suniv-f1c500s-miyoo-4bit.dts
@@ -0,0 +1,96 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR X11)
+/*
+ * Copyright 2018 Icenowy Zheng <icenowy@aosc.io>
+ * Copyright 2018 Steward Fu <steward.fu@gmail.com>
+ */
+
+/dts-v1/;
+#include "suniv.dtsi"
+#include <dt-bindings/gpio/gpio.h>
+
+/ {
+	model = "Miyoo Handheld";
+	compatible = "allwinner,suniv-f1c500s";
+
+	aliases {
+		serial1 = &uart1;
+	};
+
+	chosen {
+		stdout-path = "serial1:115200n8";
+	};
+
+  backlight {
+		compatible = "pwm-backlight";
+		pwms = <&pwm 1 58824 0>;
+		brightness-levels = <0 10 20 30 40 50 60 70 80 90 100>;
+		default-brightness-level = <5>;
+		status = "okay";
+	};
+
+	reg_vcc3v3: vcc3v3 {
+		compatible = "regulator-fixed";
+		regulator-name = "vcc3v3";
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+	};
+};
+
+&pwm {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pwm1_pins_a>;
+	status = "okay";
+};
+
+&battery {
+  status = "okay";
+};
+
+&tcon0 {
+  status = "okay";
+};
+
+&mmc0 {
+	vmmc-supply = <&reg_vcc3v3>;
+	bus-width = <4>;
+	broken-cd;
+	status = "okay";
+};
+
+&codec {
+	status = "okay";
+};
+
+&uart1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&uart1_pins_a>;
+	status = "okay";
+};
+
+&spi0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&spi0_pins_a>;
+	status = "okay";
+
+	flash@0 {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		compatible = "winbond,w25q128", "jedec,spi-nor";
+		reg = <0>;
+		spi-max-frequency = <40000000>;
+	};
+};
+
+&otg_sram {
+	status = "okay";
+};
+
+&usb_otg {
+	dr_mode = "otg";
+	status = "okay";
+};
+
+&usbphy {
+	status = "okay";
+};
+
diff --git a/arch/arm/boot/dts/suniv-f1c500s-miyoo.dts b/arch/arm/boot/dts/suniv-f1c500s-miyoo.dts
new file mode 100644
index 00000000..6f2644e2
--- /dev/null
+++ b/arch/arm/boot/dts/suniv-f1c500s-miyoo.dts
@@ -0,0 +1,96 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR X11)
+/*
+ * Copyright 2018 Icenowy Zheng <icenowy@aosc.io>
+ * Copyright 2018 Steward Fu <steward.fu@gmail.com>
+ */
+
+/dts-v1/;
+#include "suniv.dtsi"
+#include <dt-bindings/gpio/gpio.h>
+
+/ {
+	model = "Miyoo Handheld";
+	compatible = "allwinner,suniv-f1c500s";
+
+	aliases {
+		serial1 = &uart1;
+	};
+
+	chosen {
+		stdout-path = "serial1:115200n8";
+	};
+	
+  backlight {
+		compatible = "pwm-backlight";
+		pwms = <&pwm 1 58824 0>;
+		brightness-levels = <0 10 20 30 40 50 60 70 80 90 100>;
+		default-brightness-level = <5>;
+		status = "okay";
+	};
+
+	reg_vcc3v3: vcc3v3 {
+		compatible = "regulator-fixed";
+		regulator-name = "vcc3v3";
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+	};
+};
+
+&pwm {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pwm1_pins_a>;
+	status = "okay";
+};
+
+&battery {
+  status = "okay";
+};
+
+&tcon0 {
+  status = "okay";
+};
+
+&mmc0 {
+	vmmc-supply = <&reg_vcc3v3>;
+	bus-width = <1>;
+	broken-cd;
+	status = "okay";
+};
+
+&codec {
+	status = "okay";
+};
+
+&uart1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&uart1_pins_a>;
+	status = "okay";
+};
+
+&spi0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&spi0_pins_a>;
+	status = "okay";
+
+	flash@0 {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		compatible = "winbond,w25q128", "jedec,spi-nor";
+		reg = <0>;
+		spi-max-frequency = <40000000>;
+	};
+};
+
+&otg_sram {
+	status = "okay";
+};
+
+&usb_otg {
+	dr_mode = "otg";
+	status = "okay";
+};
+
+&usbphy {
+	status = "okay";
+};
+
diff --git a/arch/arm/boot/dts/suniv.dtsi b/arch/arm/boot/dts/suniv.dtsi
new file mode 100644
index 00000000..bee4299a
--- /dev/null
+++ b/arch/arm/boot/dts/suniv.dtsi
@@ -0,0 +1,277 @@
+#include <dt-bindings/clock/suniv-ccu.h>
+#include <dt-bindings/reset/suniv-ccu.h>
+
+/ {
+	#address-cells = <1>;
+	#size-cells = <1>;
+	interrupt-parent = <&intc>;
+
+	clocks {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		ranges;
+
+		osc24M: clk-24M {
+			#clock-cells = <0>;
+			compatible = "fixed-clock";
+			clock-frequency = <24000000>;
+			clock-output-names = "osc24M";
+		};
+
+		osc32k: clk-32k {
+			#clock-cells = <0>;
+			compatible = "fixed-clock";
+			clock-frequency = <32768>;
+			clock-output-names = "osc32k";
+		};
+	};
+
+	cpus {
+		#address-cells = <0>;
+		#size-cells = <0>;
+
+		cpu {
+			compatible = "arm,arm926ej-s";
+			device_type = "cpu";
+		};
+	};
+
+	soc {
+		compatible = "simple-bus";
+		#address-cells = <1>;
+		#size-cells = <1>;
+		ranges;
+
+		sram-controller@1c00000 {
+			compatible = "allwinner,sun4i-a10-sram-controller";
+			reg = <0x01c00000 0x30>;
+			#address-cells = <1>;
+			#size-cells = <1>;
+			ranges;
+
+			sram_d: sram@10000 {
+				compatible = "mmio-sram";
+				reg = <0x00010000 0x1000>;
+				#address-cells = <1>;
+				#size-cells = <1>;
+				ranges = <0 0x00010000 0x1000>;
+
+				otg_sram: sram-section@0 {
+					compatible = "allwinner,sun4i-a10-sram-d";
+					reg = <0x0000 0x1000>;
+					status = "disabled";
+				};
+			};
+		};
+
+		spi0: spi@1c05000 {
+			compatible = "allwinner,suniv-f1c100s-spi", "allwinner,sun8i-h3-spi";
+			reg = <0x01c05000 0x1000>;
+			interrupts = <10>;
+			clocks = <&ccu CLK_BUS_SPI0>, <&ccu CLK_BUS_SPI0>;
+			clock-names = "ahb", "mod";
+			resets = <&ccu RST_BUS_SPI0>;
+			status = "disabled";
+			#address-cells = <1>;
+			#size-cells = <0>;
+		};
+
+		spi1: spi@1c06000 {
+			compatible = "allwinner,suniv-f1c100s-spi", "allwinner,sun8i-h3-spi";
+			reg = <0x01c06000 0x1000>;
+			interrupts = <11>;
+			clocks = <&ccu CLK_BUS_SPI1>, <&ccu CLK_BUS_SPI1>;
+			clock-names = "ahb", "mod";
+			resets = <&ccu RST_BUS_SPI1>;
+			status = "disabled";
+			#address-cells = <1>;
+			#size-cells = <0>;
+		};
+
+		tcon0: tcon0@1c0c000 {
+			compatible = "allwinner,suniv-f1c500s-tcon0";
+			reg = <0x01c0c000 0x1000>;
+			interrupts = <29>;
+			clocks = <&ccu CLK_BUS_LCD>, <&ccu CLK_TCON>;
+			status = "disabled";
+		};
+
+    dma: dma-controller@01c02000 {
+      compatible = "allwinner,suniv-dma";
+      reg = <0x01c02000 0x1000>;
+      #dma-cells = <1>;
+    }; 
+
+		mmc0: mmc@1c0f000 {
+			compatible = "allwinner,suniv-f1c100s-mmc", "allwinner,sun7i-a20-mmc";
+			reg = <0x01c0f000 0x1000>;
+			clocks = <&ccu CLK_BUS_MMC0>, <&ccu CLK_MMC0>, <&ccu CLK_MMC0_OUTPUT>, <&ccu CLK_MMC0_SAMPLE>;
+			clock-names = "ahb", "mmc", "output", "sample";
+			resets = <&ccu RST_BUS_MMC0>;
+			reset-names = "ahb";
+			interrupts = <23>;
+			pinctrl-names = "default";
+			pinctrl-0 = <&mmc0_pins>;
+			status = "disabled";
+			#address-cells = <1>;
+			#size-cells = <0>;
+		};
+
+		mmc1: mmc@1c10000 {
+			compatible = "allwinner,suniv-f1c100s-mmc", "allwinner,sun7i-a20-mmc";
+			reg = <0x01c10000 0x1000>;
+			clocks = <&ccu CLK_BUS_MMC1>, <&ccu CLK_MMC1>, <&ccu CLK_MMC1_OUTPUT>, <&ccu CLK_MMC1_SAMPLE>;
+			clock-names = "ahb", "mmc", "output", "sample";
+			resets = <&ccu RST_BUS_MMC1>;
+			reset-names = "ahb";
+			interrupts = <24>;
+			status = "disabled";
+			#address-cells = <1>;
+			#size-cells = <0>;
+		};
+
+		ccu: clock@1c20000 {
+			compatible = "allwinner,suniv-f1c100s-ccu";
+			reg = <0x01c20000 0x400>;
+			clocks = <&osc24M>, <&osc32k>;
+			clock-names = "hosc", "losc";
+			#clock-cells = <1>;
+			#reset-cells = <1>;
+		};
+
+		intc: interrupt-controller@1c20400 {
+			compatible = "allwinner,suniv-f1c100s-ic";
+			reg = <0x01c20400 0x400>;
+			interrupt-controller;
+			#interrupt-cells = <1>;
+		};
+
+		pwm: pwm@01c21000 {
+			compatible = "allwinner,suniv-pwm";
+			reg = <0x01c21000 0x400>;
+			clocks = <&osc24M>;
+			#pwm-cells = <3>;
+			status = "disabled";
+		};
+
+    pio: pinctrl@1c20800 {
+			compatible = "allwinner,suniv-f1c100s-pinctrl";
+			reg = <0x01c20800 0x400>;
+			interrupts = <38>, <39>, <40>;
+			clocks = <&ccu CLK_BUS_PIO>, <&osc24M>, <&osc32k>;
+			clock-names = "apb", "hosc", "losc";
+			gpio-controller;
+			interrupt-controller;
+			#interrupt-cells = <3>;
+			#gpio-cells = <3>;
+			
+      pwm1_pins_a: pwm1 {
+				pins = "PE6";
+				function = "pwm1";
+			};
+      
+			spi0_pins_a: spi0-pins-pc {
+				pins = "PC0", "PC1", "PC2", "PC3";
+				function = "spi0";
+			};
+
+			uart0_pins_a: uart-pins-pe {
+				pins = "PE0", "PE1";
+				function = "uart0";
+			};
+
+			uart1_pins_a: uart-pins-pa {
+				pins = "PA2", "PA3";
+				function = "uart1";
+			};
+
+			mmc0_pins: mmc0-pins {
+				pins = "PF0", "PF1", "PF2", "PF3", "PF4", "PF5";
+				function = "mmc0";
+			};
+		};
+
+		timer@1c20c00 {
+			compatible = "allwinner,suniv-f1c100s-timer";
+			reg = <0x01c20c00 0x90>;
+			interrupts = <13>;
+			clocks = <&osc24M>;
+		};
+    
+		codec: codec@1c22000 {
+			compatible = "allwinner,suniv-f1c500s-codec";
+			clocks = <&ccu CLK_BUS_CODEC>, <&ccu CLK_CODEC>;
+			interrupts = <18>;
+			status = "disabled";
+		};
+		
+    battery: battery@1c23400 {
+			compatible = "allwinner,suniv-f1c500s-battery";
+			reg = <0x01c23400 0x400>;
+		};
+
+    wdt: watchdog@1c20ca0 {
+			compatible = "allwinner,sun6i-a31-wdt";
+			reg = <0x01c20ca0 0x20>;
+		};
+
+		uart0: serial@1c25000 {
+			compatible = "snps,dw-apb-uart";
+			reg = <0x01c25000 0x400>;
+			interrupts = <1>;
+			reg-shift = <2>;
+			reg-io-width = <4>;
+			clocks = <&ccu CLK_BUS_UART0>;
+			resets = <&ccu RST_BUS_UART0>;
+			status = "disabled";
+		};
+
+		uart1: serial@1c25400 {
+			compatible = "snps,dw-apb-uart";
+			reg = <0x01c25400 0x400>;
+			interrupts = <2>;
+			reg-shift = <2>;
+			reg-io-width = <4>;
+			clocks = <&ccu CLK_BUS_UART1>;
+			resets = <&ccu RST_BUS_UART1>;
+			status = "disabled";
+		};
+
+		uart2: serial@1c25800 {
+			compatible = "snps,dw-apb-uart";
+			reg = <0x01c25800 0x400>;
+			interrupts = <3>;
+			reg-shift = <2>;
+			reg-io-width = <4>;
+			clocks = <&ccu CLK_BUS_UART2>;
+			resets = <&ccu RST_BUS_UART2>;
+			status = "disabled";
+		};
+
+		usb_otg: usb@1c13000 {
+			compatible = "allwinner,suniv-f1c100s-musb";
+			reg = <0x01c13000 0x0400>;
+			clocks = <&ccu CLK_BUS_OTG>;
+			resets = <&ccu RST_BUS_OTG>;
+			interrupts = <26>;
+			interrupt-names = "mc";
+			phys = <&usbphy 0>;
+			phy-names = "usb";
+			extcon = <&usbphy 0>;
+			allwinner,sram = <&otg_sram 1>;
+			status = "disabled";
+		};
+
+		usbphy: phy@1c13400 {
+			compatible = "allwinner,suniv-f1c100s-usb-phy";
+			reg = <0x01c13400 0x10>;
+			reg-names = "phy_ctrl";
+			clocks = <&ccu CLK_USB_PHY0>;
+			clock-names = "usb0_phy";
+			resets = <&ccu RST_USB_PHY0>;
+			reset-names = "usb0_reset";
+			#phy-cells = <1>;
+			status = "disabled";
+		};
+	};
+};
diff --git a/arch/arm/configs/f1c100s_config b/arch/arm/configs/f1c100s_config
new file mode 100644
index 00000000..84fa8ad5
--- /dev/null
+++ b/arch/arm/configs/f1c100s_config
@@ -0,0 +1,3240 @@
+#
+# Automatically generated file; DO NOT EDIT.
+# Linux/arm 4.14.0 Kernel Configuration
+#
+CONFIG_ARM=y
+CONFIG_ARM_HAS_SG_CHAIN=y
+CONFIG_MIGHT_HAVE_PCI=y
+CONFIG_SYS_SUPPORTS_APM_EMULATION=y
+CONFIG_HAVE_PROC_CPU=y
+CONFIG_STACKTRACE_SUPPORT=y
+CONFIG_LOCKDEP_SUPPORT=y
+CONFIG_TRACE_IRQFLAGS_SUPPORT=y
+CONFIG_RWSEM_XCHGADD_ALGORITHM=y
+CONFIG_FIX_EARLYCON_MEM=y
+CONFIG_GENERIC_HWEIGHT=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_NEED_DMA_MAP_STATE=y
+CONFIG_ARCH_SUPPORTS_UPROBES=y
+CONFIG_VECTORS_BASE=0xffff0000
+CONFIG_ARM_PATCH_PHYS_VIRT=y
+CONFIG_GENERIC_BUG=y
+CONFIG_PGTABLE_LEVELS=2
+CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
+CONFIG_IRQ_WORK=y
+CONFIG_BUILDTIME_EXTABLE_SORT=y
+
+#
+# General setup
+#
+CONFIG_BROKEN_ON_SMP=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
+CONFIG_CROSS_COMPILE=""
+# CONFIG_COMPILE_TEST is not set
+CONFIG_LOCALVERSION="-licheepi-nano"
+# CONFIG_LOCALVERSION_AUTO is not set
+CONFIG_HAVE_KERNEL_GZIP=y
+CONFIG_HAVE_KERNEL_LZMA=y
+CONFIG_HAVE_KERNEL_XZ=y
+CONFIG_HAVE_KERNEL_LZO=y
+CONFIG_HAVE_KERNEL_LZ4=y
+CONFIG_KERNEL_GZIP=y
+# CONFIG_KERNEL_LZMA is not set
+# CONFIG_KERNEL_XZ is not set
+# CONFIG_KERNEL_LZO is not set
+# CONFIG_KERNEL_LZ4 is not set
+CONFIG_DEFAULT_HOSTNAME="(none)"
+CONFIG_SWAP=y
+# CONFIG_SYSVIPC is not set
+# CONFIG_POSIX_MQUEUE is not set
+CONFIG_CROSS_MEMORY_ATTACH=y
+CONFIG_FHANDLE=y
+# CONFIG_USELIB is not set
+# CONFIG_AUDIT is not set
+
+#
+# IRQ subsystem
+#
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_GENERIC_IRQ_SHOW=y
+CONFIG_GENERIC_IRQ_SHOW_LEVEL=y
+CONFIG_HARDIRQS_SW_RESEND=y
+CONFIG_GENERIC_IRQ_CHIP=y
+CONFIG_IRQ_DOMAIN=y
+CONFIG_HANDLE_DOMAIN_IRQ=y
+# CONFIG_IRQ_DOMAIN_DEBUG is not set
+CONFIG_IRQ_FORCED_THREADING=y
+CONFIG_SPARSE_IRQ=y
+# CONFIG_GENERIC_IRQ_DEBUGFS is not set
+CONFIG_ARCH_CLOCKSOURCE_DATA=y
+CONFIG_GENERIC_CLOCKEVENTS=y
+
+#
+# Timers subsystem
+#
+CONFIG_TICK_ONESHOT=y
+CONFIG_NO_HZ_COMMON=y
+# CONFIG_HZ_PERIODIC is not set
+CONFIG_NO_HZ_IDLE=y
+CONFIG_NO_HZ=y
+CONFIG_HIGH_RES_TIMERS=y
+
+#
+# CPU/Task time and stats accounting
+#
+CONFIG_TICK_CPU_ACCOUNTING=y
+# CONFIG_VIRT_CPU_ACCOUNTING_GEN is not set
+# CONFIG_IRQ_TIME_ACCOUNTING is not set
+# CONFIG_BSD_PROCESS_ACCT is not set
+# CONFIG_TASKSTATS is not set
+
+#
+# RCU Subsystem
+#
+CONFIG_TINY_RCU=y
+# CONFIG_RCU_EXPERT is not set
+CONFIG_SRCU=y
+CONFIG_TINY_SRCU=y
+# CONFIG_TASKS_RCU is not set
+# CONFIG_RCU_STALL_COMMON is not set
+# CONFIG_RCU_NEED_SEGCBLIST is not set
+# CONFIG_BUILD_BIN2C is not set
+# CONFIG_IKCONFIG is not set
+CONFIG_LOG_BUF_SHIFT=17
+CONFIG_PRINTK_SAFE_LOG_BUF_SHIFT=13
+CONFIG_GENERIC_SCHED_CLOCK=y
+CONFIG_CGROUPS=y
+# CONFIG_MEMCG is not set
+# CONFIG_BLK_CGROUP is not set
+# CONFIG_CGROUP_SCHED is not set
+# CONFIG_CGROUP_PIDS is not set
+# CONFIG_CGROUP_RDMA is not set
+# CONFIG_CGROUP_FREEZER is not set
+# CONFIG_CGROUP_DEVICE is not set
+# CONFIG_CGROUP_CPUACCT is not set
+# CONFIG_CGROUP_PERF is not set
+# CONFIG_CGROUP_DEBUG is not set
+# CONFIG_SOCK_CGROUP_DATA is not set
+# CONFIG_CHECKPOINT_RESTORE is not set
+CONFIG_NAMESPACES=y
+CONFIG_UTS_NS=y
+# CONFIG_USER_NS is not set
+CONFIG_PID_NS=y
+CONFIG_NET_NS=y
+# CONFIG_SCHED_AUTOGROUP is not set
+# CONFIG_SYSFS_DEPRECATED is not set
+# CONFIG_RELAY is not set
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_INITRAMFS_SOURCE=""
+CONFIG_RD_GZIP=y
+CONFIG_RD_BZIP2=y
+CONFIG_RD_LZMA=y
+CONFIG_RD_XZ=y
+CONFIG_RD_LZO=y
+CONFIG_RD_LZ4=y
+CONFIG_CC_OPTIMIZE_FOR_PERFORMANCE=y
+# CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
+CONFIG_SYSCTL=y
+CONFIG_ANON_INODES=y
+CONFIG_HAVE_UID16=y
+CONFIG_BPF=y
+# CONFIG_EXPERT is not set
+CONFIG_UID16=y
+CONFIG_MULTIUSER=y
+# CONFIG_SGETMASK_SYSCALL is not set
+CONFIG_SYSFS_SYSCALL=y
+# CONFIG_SYSCTL_SYSCALL is not set
+CONFIG_POSIX_TIMERS=y
+CONFIG_KALLSYMS=y
+# CONFIG_KALLSYMS_ALL is not set
+# CONFIG_KALLSYMS_ABSOLUTE_PERCPU is not set
+CONFIG_KALLSYMS_BASE_RELATIVE=y
+CONFIG_PRINTK=y
+CONFIG_PRINTK_NMI=y
+CONFIG_BUG=y
+CONFIG_ELF_CORE=y
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_FUTEX_PI=y
+CONFIG_EPOLL=y
+CONFIG_SIGNALFD=y
+CONFIG_TIMERFD=y
+CONFIG_EVENTFD=y
+# CONFIG_BPF_SYSCALL is not set
+CONFIG_SHMEM=y
+CONFIG_AIO=y
+CONFIG_ADVISE_SYSCALLS=y
+# CONFIG_USERFAULTFD is not set
+CONFIG_MEMBARRIER=y
+# CONFIG_EMBEDDED is not set
+CONFIG_HAVE_PERF_EVENTS=y
+CONFIG_PERF_USE_VMALLOC=y
+# CONFIG_PC104 is not set
+
+#
+# Kernel Performance Events And Counters
+#
+CONFIG_PERF_EVENTS=y
+# CONFIG_DEBUG_PERF_USE_VMALLOC is not set
+CONFIG_VM_EVENT_COUNTERS=y
+CONFIG_SLUB_DEBUG=y
+CONFIG_COMPAT_BRK=y
+# CONFIG_SLAB is not set
+CONFIG_SLUB=y
+CONFIG_SLAB_MERGE_DEFAULT=y
+# CONFIG_SLAB_FREELIST_RANDOM is not set
+# CONFIG_SLAB_FREELIST_HARDENED is not set
+# CONFIG_SYSTEM_DATA_VERIFICATION is not set
+# CONFIG_PROFILING is not set
+CONFIG_HAVE_OPROFILE=y
+# CONFIG_KPROBES is not set
+# CONFIG_JUMP_LABEL is not set
+# CONFIG_UPROBES is not set
+# CONFIG_HAVE_64BIT_ALIGNED_ACCESS is not set
+CONFIG_ARCH_USE_BUILTIN_BSWAP=y
+CONFIG_HAVE_KPROBES=y
+CONFIG_HAVE_KRETPROBES=y
+CONFIG_HAVE_OPTPROBES=y
+CONFIG_HAVE_NMI=y
+CONFIG_HAVE_ARCH_TRACEHOOK=y
+CONFIG_HAVE_DMA_CONTIGUOUS=y
+CONFIG_GENERIC_SMP_IDLE_THREAD=y
+CONFIG_GENERIC_IDLE_POLL_SETUP=y
+CONFIG_ARCH_HAS_SET_MEMORY=y
+CONFIG_HAVE_REGS_AND_STACK_ACCESS_API=y
+CONFIG_HAVE_CLK=y
+CONFIG_HAVE_DMA_API_DEBUG=y
+CONFIG_HAVE_PERF_REGS=y
+CONFIG_HAVE_PERF_USER_STACK_DUMP=y
+CONFIG_HAVE_ARCH_JUMP_LABEL=y
+CONFIG_ARCH_WANT_IPC_PARSE_VERSION=y
+CONFIG_HAVE_GCC_PLUGINS=y
+# CONFIG_GCC_PLUGINS is not set
+CONFIG_HAVE_CC_STACKPROTECTOR=y
+# CONFIG_CC_STACKPROTECTOR is not set
+CONFIG_CC_STACKPROTECTOR_NONE=y
+# CONFIG_CC_STACKPROTECTOR_REGULAR is not set
+# CONFIG_CC_STACKPROTECTOR_STRONG is not set
+CONFIG_THIN_ARCHIVES=y
+CONFIG_HAVE_CONTEXT_TRACKING=y
+CONFIG_HAVE_VIRT_CPU_ACCOUNTING_GEN=y
+CONFIG_HAVE_IRQ_TIME_ACCOUNTING=y
+CONFIG_HAVE_MOD_ARCH_SPECIFIC=y
+CONFIG_MODULES_USE_ELF_REL=y
+CONFIG_ARCH_HAS_ELF_RANDOMIZE=y
+CONFIG_HAVE_ARCH_MMAP_RND_BITS=y
+CONFIG_HAVE_EXIT_THREAD=y
+CONFIG_ARCH_MMAP_RND_BITS_MIN=8
+CONFIG_ARCH_MMAP_RND_BITS_MAX=16
+CONFIG_ARCH_MMAP_RND_BITS=8
+# CONFIG_HAVE_ARCH_HASH is not set
+# CONFIG_ISA_BUS_API is not set
+CONFIG_CLONE_BACKWARDS=y
+CONFIG_OLD_SIGSUSPEND3=y
+CONFIG_OLD_SIGACTION=y
+# CONFIG_CPU_NO_EFFICIENT_FFS is not set
+# CONFIG_HAVE_ARCH_VMAP_STACK is not set
+CONFIG_ARCH_OPTIONAL_KERNEL_RWX=y
+# CONFIG_ARCH_OPTIONAL_KERNEL_RWX_DEFAULT is not set
+CONFIG_ARCH_HAS_STRICT_KERNEL_RWX=y
+CONFIG_STRICT_KERNEL_RWX=y
+CONFIG_ARCH_HAS_STRICT_MODULE_RWX=y
+CONFIG_STRICT_MODULE_RWX=y
+# CONFIG_REFCOUNT_FULL is not set
+
+#
+# GCOV-based kernel profiling
+#
+# CONFIG_GCOV_KERNEL is not set
+CONFIG_ARCH_HAS_GCOV_PROFILE_ALL=y
+CONFIG_HAVE_GENERIC_DMA_COHERENT=y
+CONFIG_SLABINFO=y
+CONFIG_RT_MUTEXES=y
+CONFIG_BASE_SMALL=0
+CONFIG_MODULES=y
+# CONFIG_MODULE_FORCE_LOAD is not set
+CONFIG_MODULE_UNLOAD=y
+# CONFIG_MODULE_FORCE_UNLOAD is not set
+# CONFIG_MODVERSIONS is not set
+# CONFIG_MODULE_SRCVERSION_ALL is not set
+# CONFIG_MODULE_SIG is not set
+# CONFIG_MODULE_COMPRESS is not set
+# CONFIG_TRIM_UNUSED_KSYMS is not set
+CONFIG_MODULES_TREE_LOOKUP=y
+CONFIG_BLOCK=y
+CONFIG_LBDAF=y
+CONFIG_BLK_SCSI_REQUEST=y
+CONFIG_BLK_DEV_BSG=y
+# CONFIG_BLK_DEV_BSGLIB is not set
+# CONFIG_BLK_DEV_INTEGRITY is not set
+# CONFIG_BLK_DEV_ZONED is not set
+# CONFIG_BLK_CMDLINE_PARSER is not set
+# CONFIG_BLK_WBT is not set
+CONFIG_BLK_DEBUG_FS=y
+# CONFIG_BLK_SED_OPAL is not set
+
+#
+# Partition Types
+#
+# CONFIG_PARTITION_ADVANCED is not set
+CONFIG_MSDOS_PARTITION=y
+CONFIG_EFI_PARTITION=y
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_CFQ=y
+# CONFIG_DEFAULT_DEADLINE is not set
+CONFIG_DEFAULT_CFQ=y
+# CONFIG_DEFAULT_NOOP is not set
+CONFIG_DEFAULT_IOSCHED="cfq"
+CONFIG_MQ_IOSCHED_DEADLINE=y
+CONFIG_MQ_IOSCHED_KYBER=y
+# CONFIG_IOSCHED_BFQ is not set
+CONFIG_ASN1=y
+CONFIG_INLINE_SPIN_UNLOCK_IRQ=y
+CONFIG_INLINE_READ_UNLOCK=y
+CONFIG_INLINE_READ_UNLOCK_IRQ=y
+CONFIG_INLINE_WRITE_UNLOCK=y
+CONFIG_INLINE_WRITE_UNLOCK_IRQ=y
+CONFIG_ARCH_SUPPORTS_ATOMIC_RMW=y
+CONFIG_FREEZER=y
+
+#
+# System Type
+#
+CONFIG_MMU=y
+CONFIG_ARCH_MULTIPLATFORM=y
+# CONFIG_ARCH_EBSA110 is not set
+# CONFIG_ARCH_EP93XX is not set
+# CONFIG_ARCH_FOOTBRIDGE is not set
+# CONFIG_ARCH_NETX is not set
+# CONFIG_ARCH_IOP13XX is not set
+# CONFIG_ARCH_IOP32X is not set
+# CONFIG_ARCH_IOP33X is not set
+# CONFIG_ARCH_IXP4XX is not set
+# CONFIG_ARCH_DOVE is not set
+# CONFIG_ARCH_KS8695 is not set
+# CONFIG_ARCH_W90X900 is not set
+# CONFIG_ARCH_LPC32XX is not set
+# CONFIG_ARCH_PXA is not set
+# CONFIG_ARCH_RPC is not set
+# CONFIG_ARCH_SA1100 is not set
+# CONFIG_ARCH_S3C24XX is not set
+# CONFIG_ARCH_DAVINCI is not set
+# CONFIG_ARCH_OMAP1 is not set
+
+#
+# Multiple platform selection
+#
+
+#
+# CPU Core family selection
+#
+# CONFIG_ARCH_MULTI_V4 is not set
+# CONFIG_ARCH_MULTI_V4T is not set
+CONFIG_ARCH_MULTI_V5=y
+CONFIG_ARCH_MULTI_V4_V5=y
+# CONFIG_ARCH_MULTI_V6 is not set
+# CONFIG_ARCH_MULTI_V7 is not set
+CONFIG_ARCH_MULTI_CPU_AUTO=y
+# CONFIG_ARCH_MVEBU is not set
+# CONFIG_MACH_ASM9260 is not set
+# CONFIG_ARCH_AT91 is not set
+# CONFIG_ARCH_INTEGRATOR is not set
+# CONFIG_ARCH_ASPEED is not set
+# CONFIG_ARCH_MV78XX0 is not set
+# CONFIG_ARCH_MXC is not set
+# CONFIG_ARCH_MXS is not set
+# CONFIG_ARCH_NOMADIK is not set
+# CONFIG_ARCH_NSPIRE is not set
+# CONFIG_ARCH_ORION5X is not set
+# CONFIG_ARCH_MMP is not set
+# CONFIG_ARCH_OXNAS is not set
+# CONFIG_ARCH_REALVIEW is not set
+# CONFIG_PLAT_SPEAR is not set
+CONFIG_ARCH_SUNXI=y
+CONFIG_ARCH_SUNXI_V5=y
+CONFIG_MACH_SUNIV=y
+# CONFIG_ARCH_U300 is not set
+# CONFIG_ARCH_VERSATILE is not set
+# CONFIG_ARCH_WM8505 is not set
+
+#
+# Processor Type
+#
+CONFIG_CPU_ARM926T=y
+CONFIG_CPU_THUMB_CAPABLE=y
+CONFIG_CPU_32v5=y
+CONFIG_CPU_ABRT_EV5TJ=y
+CONFIG_CPU_PABRT_LEGACY=y
+CONFIG_CPU_CACHE_VIVT=y
+CONFIG_CPU_COPY_V4WB=y
+CONFIG_CPU_TLB_V4WBI=y
+CONFIG_CPU_CP15=y
+CONFIG_CPU_CP15_MMU=y
+CONFIG_CPU_USE_DOMAINS=y
+
+#
+# Processor Features
+#
+# CONFIG_ARCH_PHYS_ADDR_T_64BIT is not set
+CONFIG_ARM_THUMB=y
+# CONFIG_CPU_ICACHE_DISABLE is not set
+# CONFIG_CPU_DCACHE_DISABLE is not set
+# CONFIG_CPU_DCACHE_WRITETHROUGH is not set
+# CONFIG_CPU_CACHE_ROUND_ROBIN is not set
+CONFIG_NEED_KUSER_HELPERS=y
+CONFIG_KUSER_HELPERS=y
+# CONFIG_CACHE_L2X0 is not set
+CONFIG_ARM_L1_CACHE_SHIFT=5
+CONFIG_DEBUG_ALIGN_RODATA=y
+CONFIG_MULTI_IRQ_HANDLER=y
+
+#
+# Bus support
+#
+# CONFIG_PCI is not set
+# CONFIG_PCI_DOMAINS_GENERIC is not set
+# CONFIG_PCI_SYSCALL is not set
+
+#
+# DesignWare PCI Core Support
+#
+
+#
+# PCI Endpoint
+#
+# CONFIG_PCI_ENDPOINT is not set
+# CONFIG_PCCARD is not set
+
+#
+# Kernel Features
+#
+CONFIG_VMSPLIT_3G=y
+# CONFIG_VMSPLIT_3G_OPT is not set
+# CONFIG_VMSPLIT_2G is not set
+# CONFIG_VMSPLIT_1G is not set
+CONFIG_PAGE_OFFSET=0xC0000000
+CONFIG_ARCH_NR_GPIO=416
+CONFIG_PREEMPT_NONE=y
+# CONFIG_PREEMPT_VOLUNTARY is not set
+# CONFIG_PREEMPT is not set
+CONFIG_HZ_FIXED=0
+CONFIG_HZ_100=y
+# CONFIG_HZ_200 is not set
+# CONFIG_HZ_250 is not set
+# CONFIG_HZ_300 is not set
+# CONFIG_HZ_500 is not set
+# CONFIG_HZ_1000 is not set
+CONFIG_HZ=100
+CONFIG_SCHED_HRTICK=y
+CONFIG_AEABI=y
+CONFIG_OABI_COMPAT=y
+# CONFIG_ARCH_SPARSEMEM_DEFAULT is not set
+# CONFIG_ARCH_SELECT_MEMORY_MODEL is not set
+CONFIG_HAVE_ARCH_PFN_VALID=y
+CONFIG_HIGHMEM=y
+CONFIG_HIGHPTE=y
+CONFIG_CPU_SW_DOMAIN_PAN=y
+CONFIG_HW_PERF_EVENTS=y
+CONFIG_ARCH_WANT_GENERAL_HUGETLB=y
+# CONFIG_ARM_MODULE_PLTS is not set
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+CONFIG_HAVE_MEMBLOCK=y
+CONFIG_NO_BOOTMEM=y
+# CONFIG_HAVE_BOOTMEM_INFO_NODE is not set
+CONFIG_SPLIT_PTLOCK_CPUS=999999
+CONFIG_COMPACTION=y
+CONFIG_MIGRATION=y
+# CONFIG_PHYS_ADDR_T_64BIT is not set
+CONFIG_BOUNCE=y
+# CONFIG_KSM is not set
+CONFIG_DEFAULT_MMAP_MIN_ADDR=4096
+# CONFIG_ARCH_WANTS_THP_SWAP is not set
+CONFIG_NEED_PER_CPU_KM=y
+# CONFIG_CLEANCACHE is not set
+# CONFIG_FRONTSWAP is not set
+# CONFIG_CMA is not set
+# CONFIG_ZPOOL is not set
+# CONFIG_ZBUD is not set
+# CONFIG_ZSMALLOC is not set
+CONFIG_GENERIC_EARLY_IOREMAP=y
+# CONFIG_IDLE_PAGE_TRACKING is not set
+# CONFIG_PERCPU_STATS is not set
+CONFIG_FORCE_MAX_ZONEORDER=11
+CONFIG_ALIGNMENT_TRAP=y
+# CONFIG_UACCESS_WITH_MEMCPY is not set
+# CONFIG_SECCOMP is not set
+CONFIG_SWIOTLB=y
+CONFIG_IOMMU_HELPER=y
+# CONFIG_PARAVIRT is not set
+# CONFIG_PARAVIRT_TIME_ACCOUNTING is not set
+
+#
+# Boot options
+#
+CONFIG_USE_OF=y
+CONFIG_ATAGS=y
+# CONFIG_DEPRECATED_PARAM_STRUCT is not set
+CONFIG_ZBOOT_ROM_TEXT=0
+CONFIG_ZBOOT_ROM_BSS=0
+CONFIG_ARM_APPENDED_DTB=y
+CONFIG_ARM_ATAG_DTB_COMPAT=y
+CONFIG_ARM_ATAG_DTB_COMPAT_CMDLINE_FROM_BOOTLOADER=y
+# CONFIG_ARM_ATAG_DTB_COMPAT_CMDLINE_EXTEND is not set
+CONFIG_CMDLINE=""
+# CONFIG_KEXEC is not set
+# CONFIG_CRASH_DUMP is not set
+CONFIG_AUTO_ZRELADDR=y
+# CONFIG_EFI is not set
+
+#
+# CPU Power Management
+#
+
+#
+# CPU Frequency scaling
+#
+CONFIG_CPU_FREQ=y
+# CONFIG_CPU_FREQ_STAT is not set
+CONFIG_CPU_FREQ_DEFAULT_GOV_PERFORMANCE=y
+# CONFIG_CPU_FREQ_DEFAULT_GOV_POWERSAVE is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_USERSPACE is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_ONDEMAND is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_CONSERVATIVE is not set
+CONFIG_CPU_FREQ_GOV_PERFORMANCE=y
+# CONFIG_CPU_FREQ_GOV_POWERSAVE is not set
+# CONFIG_CPU_FREQ_GOV_USERSPACE is not set
+# CONFIG_CPU_FREQ_GOV_ONDEMAND is not set
+# CONFIG_CPU_FREQ_GOV_CONSERVATIVE is not set
+
+#
+# CPU frequency scaling drivers
+#
+CONFIG_CPUFREQ_DT=y
+CONFIG_CPUFREQ_DT_PLATDEV=y
+# CONFIG_ARM_KIRKWOOD_CPUFREQ is not set
+# CONFIG_QORIQ_CPUFREQ is not set
+
+#
+# CPU Idle
+#
+CONFIG_CPU_IDLE=y
+CONFIG_CPU_IDLE_MULTIPLE_DRIVERS=y
+# CONFIG_CPU_IDLE_GOV_LADDER is not set
+CONFIG_CPU_IDLE_GOV_MENU=y
+CONFIG_DT_IDLE_STATES=y
+
+#
+# ARM CPU Idle Drivers
+#
+CONFIG_ARM_CPUIDLE=y
+# CONFIG_ARCH_NEEDS_CPU_IDLE_COUPLED is not set
+
+#
+# Floating point emulation
+#
+
+#
+# At least one emulation must be selected
+#
+CONFIG_FPE_NWFPE=y
+# CONFIG_FPE_NWFPE_XP is not set
+# CONFIG_FPE_FASTFPE is not set
+# CONFIG_VFP is not set
+
+#
+# Userspace binary formats
+#
+CONFIG_BINFMT_ELF=y
+CONFIG_ELFCORE=y
+CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS=y
+CONFIG_BINFMT_SCRIPT=y
+# CONFIG_BINFMT_FLAT is not set
+# CONFIG_HAVE_AOUT is not set
+# CONFIG_BINFMT_MISC is not set
+CONFIG_COREDUMP=y
+
+#
+# Power management options
+#
+CONFIG_SUSPEND=y
+CONFIG_SUSPEND_FREEZER=y
+# CONFIG_HIBERNATION is not set
+CONFIG_PM_SLEEP=y
+# CONFIG_PM_AUTOSLEEP is not set
+# CONFIG_PM_WAKELOCKS is not set
+CONFIG_PM=y
+# CONFIG_PM_DEBUG is not set
+# CONFIG_APM_EMULATION is not set
+CONFIG_PM_OPP=y
+CONFIG_PM_CLK=y
+# CONFIG_WQ_POWER_EFFICIENT_DEFAULT is not set
+CONFIG_CPU_PM=y
+CONFIG_ARCH_SUSPEND_POSSIBLE=y
+CONFIG_ARM_CPU_SUSPEND=y
+CONFIG_ARCH_HIBERNATION_POSSIBLE=y
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+# CONFIG_PACKET_DIAG is not set
+CONFIG_UNIX=y
+# CONFIG_UNIX_DIAG is not set
+# CONFIG_TLS is not set
+# CONFIG_XFRM_USER is not set
+# CONFIG_NET_KEY is not set
+CONFIG_INET=y
+# CONFIG_IP_MULTICAST is not set
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_DHCP=y
+CONFIG_IP_PNP_BOOTP=y
+# CONFIG_IP_PNP_RARP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE_DEMUX is not set
+# CONFIG_NET_IP_TUNNEL is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_NET_UDP_TUNNEL is not set
+# CONFIG_NET_FOU is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_XFRM_TUNNEL is not set
+# CONFIG_INET_TUNNEL is not set
+# CONFIG_INET_XFRM_MODE_TRANSPORT is not set
+# CONFIG_INET_XFRM_MODE_TUNNEL is not set
+# CONFIG_INET_XFRM_MODE_BEET is not set
+# CONFIG_INET_DIAG is not set
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_CUBIC=y
+CONFIG_DEFAULT_TCP_CONG="cubic"
+# CONFIG_TCP_MD5SIG is not set
+# CONFIG_IPV6 is not set
+# CONFIG_NETWORK_SECMARK is not set
+CONFIG_NET_PTP_CLASSIFY=y
+# CONFIG_NETWORK_PHY_TIMESTAMPING is not set
+# CONFIG_NETFILTER is not set
+# CONFIG_IP_DCCP is not set
+# CONFIG_IP_SCTP is not set
+# CONFIG_RDS is not set
+# CONFIG_TIPC is not set
+# CONFIG_ATM is not set
+# CONFIG_L2TP is not set
+# CONFIG_BRIDGE is not set
+CONFIG_HAVE_NET_DSA=y
+# CONFIG_NET_DSA is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_PHONET is not set
+# CONFIG_IEEE802154 is not set
+# CONFIG_NET_SCHED is not set
+# CONFIG_DCB is not set
+CONFIG_DNS_RESOLVER=y
+# CONFIG_BATMAN_ADV is not set
+# CONFIG_OPENVSWITCH is not set
+# CONFIG_VSOCKETS is not set
+# CONFIG_NETLINK_DIAG is not set
+# CONFIG_MPLS is not set
+# CONFIG_NET_NSH is not set
+# CONFIG_HSR is not set
+# CONFIG_NET_SWITCHDEV is not set
+# CONFIG_NET_L3_MASTER_DEV is not set
+# CONFIG_NET_NCSI is not set
+# CONFIG_CGROUP_NET_PRIO is not set
+# CONFIG_CGROUP_NET_CLASSID is not set
+CONFIG_NET_RX_BUSY_POLL=y
+CONFIG_BQL=y
+# CONFIG_BPF_JIT is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_CAN is not set
+# CONFIG_BT is not set
+# CONFIG_AF_RXRPC is not set
+# CONFIG_AF_KCM is not set
+# CONFIG_STREAM_PARSER is not set
+CONFIG_WIRELESS=y
+CONFIG_WIRELESS_EXT=y
+CONFIG_WEXT_CORE=y
+CONFIG_WEXT_PROC=y
+CONFIG_WEXT_PRIV=y
+CONFIG_CFG80211=y
+# CONFIG_NL80211_TESTMODE is not set
+# CONFIG_CFG80211_DEVELOPER_WARNINGS is not set
+CONFIG_CFG80211_DEFAULT_PS=y
+# CONFIG_CFG80211_DEBUGFS is not set
+# CONFIG_CFG80211_INTERNAL_REGDB is not set
+CONFIG_CFG80211_CRDA_SUPPORT=y
+CONFIG_CFG80211_WEXT=y
+# CONFIG_LIB80211 is not set
+CONFIG_MAC80211=y
+CONFIG_MAC80211_HAS_RC=y
+CONFIG_MAC80211_RC_MINSTREL=y
+CONFIG_MAC80211_RC_MINSTREL_HT=y
+# CONFIG_MAC80211_RC_MINSTREL_VHT is not set
+CONFIG_MAC80211_RC_DEFAULT_MINSTREL=y
+CONFIG_MAC80211_RC_DEFAULT="minstrel_ht"
+# CONFIG_MAC80211_MESH is not set
+CONFIG_MAC80211_LEDS=y
+# CONFIG_MAC80211_DEBUGFS is not set
+# CONFIG_MAC80211_MESSAGE_TRACING is not set
+# CONFIG_MAC80211_DEBUG_MENU is not set
+CONFIG_MAC80211_STA_HASH_MAX_SIZE=0
+# CONFIG_WIMAX is not set
+# CONFIG_RFKILL is not set
+# CONFIG_NET_9P is not set
+# CONFIG_CAIF is not set
+# CONFIG_CEPH_LIB is not set
+# CONFIG_NFC is not set
+# CONFIG_PSAMPLE is not set
+# CONFIG_NET_IFE is not set
+# CONFIG_LWTUNNEL is not set
+# CONFIG_DST_CACHE is not set
+# CONFIG_GRO_CELLS is not set
+# CONFIG_NET_DEVLINK is not set
+CONFIG_MAY_USE_DEVLINK=y
+CONFIG_HAVE_EBPF_JIT=y
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_UEVENT_HELPER=y
+CONFIG_UEVENT_HELPER_PATH=""
+CONFIG_DEVTMPFS=y
+CONFIG_DEVTMPFS_MOUNT=y
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+CONFIG_FW_LOADER=y
+CONFIG_FIRMWARE_IN_KERNEL=y
+CONFIG_EXTRA_FIRMWARE=""
+# CONFIG_FW_LOADER_USER_HELPER_FALLBACK is not set
+CONFIG_ALLOW_DEV_COREDUMP=y
+# CONFIG_DEBUG_DRIVER is not set
+# CONFIG_DEBUG_DEVRES is not set
+# CONFIG_DEBUG_TEST_DRIVER_REMOVE is not set
+# CONFIG_TEST_ASYNC_DRIVER_PROBE is not set
+# CONFIG_SYS_HYPERVISOR is not set
+# CONFIG_GENERIC_CPU_DEVICES is not set
+CONFIG_GENERIC_CPU_AUTOPROBE=y
+CONFIG_REGMAP=y
+CONFIG_REGMAP_I2C=y
+CONFIG_REGMAP_SPI=y
+CONFIG_REGMAP_MMIO=y
+CONFIG_REGMAP_IRQ=y
+CONFIG_DMA_SHARED_BUFFER=y
+# CONFIG_DMA_FENCE_TRACE is not set
+
+#
+# Bus devices
+#
+# CONFIG_ARM_CCN is not set
+# CONFIG_BRCMSTB_GISB_ARB is not set
+# CONFIG_SIMPLE_PM_BUS is not set
+CONFIG_SUNXI_RSB=y
+# CONFIG_VEXPRESS_CONFIG is not set
+# CONFIG_CONNECTOR is not set
+CONFIG_MTD=y
+# CONFIG_MTD_TESTS is not set
+# CONFIG_MTD_REDBOOT_PARTS is not set
+# CONFIG_MTD_CMDLINE_PARTS is not set
+# CONFIG_MTD_AFS_PARTS is not set
+CONFIG_MTD_OF_PARTS=y
+# CONFIG_MTD_AR7_PARTS is not set
+
+#
+# Partition parsers
+#
+
+#
+# User Modules And Translation Layers
+#
+# CONFIG_MTD_BLOCK is not set
+# CONFIG_MTD_BLOCK_RO is not set
+# CONFIG_FTL is not set
+# CONFIG_NFTL is not set
+# CONFIG_INFTL is not set
+# CONFIG_RFD_FTL is not set
+# CONFIG_SSFDC is not set
+# CONFIG_SM_FTL is not set
+# CONFIG_MTD_OOPS is not set
+# CONFIG_MTD_SWAP is not set
+# CONFIG_MTD_PARTITIONED_MASTER is not set
+
+#
+# RAM/ROM/Flash chip drivers
+#
+# CONFIG_MTD_CFI is not set
+# CONFIG_MTD_JEDECPROBE is not set
+CONFIG_MTD_MAP_BANK_WIDTH_1=y
+CONFIG_MTD_MAP_BANK_WIDTH_2=y
+CONFIG_MTD_MAP_BANK_WIDTH_4=y
+# CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
+CONFIG_MTD_CFI_I1=y
+CONFIG_MTD_CFI_I2=y
+# CONFIG_MTD_CFI_I4 is not set
+# CONFIG_MTD_CFI_I8 is not set
+# CONFIG_MTD_RAM is not set
+# CONFIG_MTD_ROM is not set
+# CONFIG_MTD_ABSENT is not set
+
+#
+# Mapping drivers for chip access
+#
+# CONFIG_MTD_COMPLEX_MAPPINGS is not set
+# CONFIG_MTD_PLATRAM is not set
+
+#
+# Self-contained MTD device drivers
+#
+# CONFIG_MTD_DATAFLASH is not set
+CONFIG_MTD_M25P80=y
+# CONFIG_MTD_MCHP23K256 is not set
+# CONFIG_MTD_SST25L is not set
+# CONFIG_MTD_SLRAM is not set
+# CONFIG_MTD_PHRAM is not set
+# CONFIG_MTD_MTDRAM is not set
+# CONFIG_MTD_BLOCK2MTD is not set
+
+#
+# Disk-On-Chip Device Drivers
+#
+# CONFIG_MTD_DOCG3 is not set
+# CONFIG_MTD_NAND is not set
+# CONFIG_MTD_ONENAND is not set
+
+#
+# LPDDR & LPDDR2 PCM memory drivers
+#
+# CONFIG_MTD_LPDDR is not set
+# CONFIG_MTD_LPDDR2_NVM is not set
+CONFIG_MTD_SPI_NOR=y
+# CONFIG_MTD_MT81xx_NOR is not set
+CONFIG_MTD_SPI_NOR_USE_4K_SECTORS=y
+# CONFIG_SPI_CADENCE_QUADSPI is not set
+# CONFIG_MTD_UBI is not set
+CONFIG_DTC=y
+CONFIG_OF=y
+# CONFIG_OF_UNITTEST is not set
+CONFIG_OF_FLATTREE=y
+CONFIG_OF_EARLY_FLATTREE=y
+CONFIG_OF_ADDRESS=y
+CONFIG_OF_IRQ=y
+CONFIG_OF_NET=y
+CONFIG_OF_RESERVED_MEM=y
+# CONFIG_OF_OVERLAY is not set
+CONFIG_ARCH_MIGHT_HAVE_PC_PARPORT=y
+# CONFIG_PARPORT is not set
+CONFIG_BLK_DEV=y
+# CONFIG_BLK_DEV_NULL_BLK is not set
+# CONFIG_BLK_DEV_COW_COMMON is not set
+# CONFIG_BLK_DEV_LOOP is not set
+# CONFIG_BLK_DEV_DRBD is not set
+# CONFIG_BLK_DEV_NBD is not set
+# CONFIG_BLK_DEV_RAM is not set
+# CONFIG_CDROM_PKTCDVD is not set
+# CONFIG_ATA_OVER_ETH is not set
+# CONFIG_BLK_DEV_RBD is not set
+# CONFIG_NVME_FC is not set
+# CONFIG_NVME_TARGET is not set
+
+#
+# Misc devices
+#
+# CONFIG_SENSORS_LIS3LV02D is not set
+# CONFIG_AD525X_DPOT is not set
+# CONFIG_DUMMY_IRQ is not set
+# CONFIG_ICS932S401 is not set
+# CONFIG_ENCLOSURE_SERVICES is not set
+# CONFIG_APDS9802ALS is not set
+# CONFIG_ISL29003 is not set
+# CONFIG_ISL29020 is not set
+# CONFIG_SENSORS_TSL2550 is not set
+# CONFIG_SENSORS_BH1770 is not set
+# CONFIG_SENSORS_APDS990X is not set
+# CONFIG_HMC6352 is not set
+# CONFIG_DS1682 is not set
+# CONFIG_TI_DAC7512 is not set
+# CONFIG_USB_SWITCH_FSA9480 is not set
+# CONFIG_LATTICE_ECP3_CONFIG is not set
+# CONFIG_SRAM is not set
+# CONFIG_C2PORT is not set
+
+#
+# EEPROM support
+#
+# CONFIG_EEPROM_AT24 is not set
+# CONFIG_EEPROM_AT25 is not set
+# CONFIG_EEPROM_LEGACY is not set
+# CONFIG_EEPROM_MAX6875 is not set
+# CONFIG_EEPROM_93CX6 is not set
+# CONFIG_EEPROM_93XX46 is not set
+# CONFIG_EEPROM_IDT_89HPESX is not set
+
+#
+# Texas Instruments shared transport line discipline
+#
+# CONFIG_TI_ST is not set
+# CONFIG_SENSORS_LIS3_SPI is not set
+# CONFIG_SENSORS_LIS3_I2C is not set
+
+#
+# Altera FPGA firmware download module
+#
+# CONFIG_ALTERA_STAPL is not set
+
+#
+# Intel MIC Bus Driver
+#
+
+#
+# SCIF Bus Driver
+#
+
+#
+# VOP Bus Driver
+#
+
+#
+# Intel MIC Host Driver
+#
+
+#
+# Intel MIC Card Driver
+#
+
+#
+# SCIF Driver
+#
+
+#
+# Intel MIC Coprocessor State Management (COSM) Drivers
+#
+
+#
+# VOP Driver
+#
+# CONFIG_ECHO is not set
+# CONFIG_CXL_BASE is not set
+# CONFIG_CXL_AFU_DRIVER_OPS is not set
+# CONFIG_CXL_LIB is not set
+
+#
+# SCSI device support
+#
+CONFIG_SCSI_MOD=y
+# CONFIG_RAID_ATTRS is not set
+CONFIG_SCSI=y
+CONFIG_SCSI_DMA=y
+# CONFIG_SCSI_NETLINK is not set
+# CONFIG_SCSI_MQ_DEFAULT is not set
+CONFIG_SCSI_PROC_FS=y
+
+#
+# SCSI support type (disk, tape, CD-ROM)
+#
+CONFIG_BLK_DEV_SD=y
+# CONFIG_CHR_DEV_ST is not set
+# CONFIG_CHR_DEV_OSST is not set
+# CONFIG_BLK_DEV_SR is not set
+CONFIG_CHR_DEV_SG=y
+CONFIG_CHR_DEV_SCH=y
+# CONFIG_SCSI_CONSTANTS is not set
+# CONFIG_SCSI_LOGGING is not set
+# CONFIG_SCSI_SCAN_ASYNC is not set
+
+#
+# SCSI Transports
+#
+# CONFIG_SCSI_SPI_ATTRS is not set
+# CONFIG_SCSI_FC_ATTRS is not set
+# CONFIG_SCSI_ISCSI_ATTRS is not set
+# CONFIG_SCSI_SAS_ATTRS is not set
+# CONFIG_SCSI_SAS_LIBSAS is not set
+# CONFIG_SCSI_SRP_ATTRS is not set
+CONFIG_SCSI_LOWLEVEL=y
+# CONFIG_ISCSI_TCP is not set
+# CONFIG_ISCSI_BOOT_SYSFS is not set
+# CONFIG_SCSI_UFSHCD is not set
+# CONFIG_SCSI_DEBUG is not set
+# CONFIG_SCSI_DH is not set
+# CONFIG_SCSI_OSD_INITIATOR is not set
+# CONFIG_ATA is not set
+# CONFIG_MD is not set
+# CONFIG_TARGET_CORE is not set
+CONFIG_NETDEVICES=y
+CONFIG_MII=m
+CONFIG_NET_CORE=y
+# CONFIG_BONDING is not set
+# CONFIG_DUMMY is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_NET_TEAM is not set
+# CONFIG_MACVLAN is not set
+# CONFIG_VXLAN is not set
+# CONFIG_MACSEC is not set
+# CONFIG_NETCONSOLE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+# CONFIG_TUN is not set
+# CONFIG_TUN_VNET_CROSS_LE is not set
+# CONFIG_VETH is not set
+# CONFIG_NLMON is not set
+
+#
+# CAIF transport drivers
+#
+
+#
+# Distributed Switch Architecture drivers
+#
+# CONFIG_ETHERNET is not set
+CONFIG_MDIO_DEVICE=y
+CONFIG_MDIO_BUS=y
+# CONFIG_MDIO_BITBANG is not set
+# CONFIG_MDIO_SUN4I is not set
+# CONFIG_PHYLIB is not set
+# CONFIG_MICREL_KS8995MA is not set
+# CONFIG_PPP is not set
+# CONFIG_SLIP is not set
+CONFIG_USB_NET_DRIVERS=m
+# CONFIG_USB_CATC is not set
+# CONFIG_USB_KAWETH is not set
+# CONFIG_USB_PEGASUS is not set
+CONFIG_USB_RTL8150=m
+# CONFIG_USB_RTL8152 is not set
+# CONFIG_USB_LAN78XX is not set
+# CONFIG_USB_USBNET is not set
+# CONFIG_USB_IPHETH is not set
+CONFIG_WLAN=y
+# CONFIG_WLAN_VENDOR_ADMTEK is not set
+# CONFIG_WLAN_VENDOR_ATH is not set
+# CONFIG_WLAN_VENDOR_ATMEL is not set
+# CONFIG_WLAN_VENDOR_BROADCOM is not set
+# CONFIG_WLAN_VENDOR_CISCO is not set
+# CONFIG_WLAN_VENDOR_INTEL is not set
+# CONFIG_WLAN_VENDOR_INTERSIL is not set
+# CONFIG_WLAN_VENDOR_MARVELL is not set
+# CONFIG_WLAN_VENDOR_MEDIATEK is not set
+# CONFIG_WLAN_VENDOR_RALINK is not set
+# CONFIG_WLAN_VENDOR_REALTEK is not set
+# CONFIG_WLAN_VENDOR_RSI is not set
+# CONFIG_WLAN_VENDOR_ST is not set
+# CONFIG_WLAN_VENDOR_TI is not set
+# CONFIG_WLAN_VENDOR_ZYDAS is not set
+# CONFIG_WLAN_VENDOR_QUANTENNA is not set
+# CONFIG_MAC80211_HWSIM is not set
+# CONFIG_USB_NET_RNDIS_WLAN is not set
+
+#
+# Enable WiMAX (Networking options) to see the WiMAX drivers
+#
+# CONFIG_WAN is not set
+# CONFIG_ISDN is not set
+# CONFIG_NVM is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+CONFIG_INPUT_LEDS=y
+# CONFIG_INPUT_FF_MEMLESS is not set
+CONFIG_INPUT_POLLDEV=y
+# CONFIG_INPUT_SPARSEKMAP is not set
+# CONFIG_INPUT_MATRIXKMAP is not set
+
+#
+# Userland interfaces
+#
+# CONFIG_INPUT_MOUSEDEV is not set
+# CONFIG_INPUT_JOYDEV is not set
+CONFIG_INPUT_EVDEV=y
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input Device Drivers
+#
+CONFIG_INPUT_KEYBOARD=y
+# CONFIG_KEYBOARD_ADP5588 is not set
+# CONFIG_KEYBOARD_ADP5589 is not set
+# CONFIG_KEYBOARD_ATKBD is not set
+# CONFIG_KEYBOARD_QT1070 is not set
+# CONFIG_KEYBOARD_QT2160 is not set
+# CONFIG_KEYBOARD_DLINK_DIR685 is not set
+# CONFIG_KEYBOARD_LKKBD is not set
+# CONFIG_KEYBOARD_GPIO is not set
+# CONFIG_KEYBOARD_GPIO_POLLED is not set
+# CONFIG_KEYBOARD_TCA6416 is not set
+# CONFIG_KEYBOARD_TCA8418 is not set
+# CONFIG_KEYBOARD_MATRIX is not set
+# CONFIG_KEYBOARD_LM8323 is not set
+# CONFIG_KEYBOARD_LM8333 is not set
+# CONFIG_KEYBOARD_MAX7359 is not set
+# CONFIG_KEYBOARD_MCS is not set
+# CONFIG_KEYBOARD_MPR121 is not set
+# CONFIG_KEYBOARD_NEWTON is not set
+# CONFIG_KEYBOARD_OPENCORES is not set
+# CONFIG_KEYBOARD_SAMSUNG is not set
+# CONFIG_KEYBOARD_STOWAWAY is not set
+# CONFIG_KEYBOARD_SUNKBD is not set
+CONFIG_KEYBOARD_SUN4I_LRADC=y
+# CONFIG_KEYBOARD_OMAP4 is not set
+# CONFIG_KEYBOARD_TM2_TOUCHKEY is not set
+# CONFIG_KEYBOARD_XTKBD is not set
+# CONFIG_KEYBOARD_CAP11XX is not set
+# CONFIG_KEYBOARD_BCM is not set
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TABLET is not set
+CONFIG_INPUT_TOUCHSCREEN=y
+CONFIG_TOUCHSCREEN_PROPERTIES=y
+# CONFIG_TOUCHSCREEN_ADS7846 is not set
+# CONFIG_TOUCHSCREEN_AD7877 is not set
+# CONFIG_TOUCHSCREEN_AD7879 is not set
+# CONFIG_TOUCHSCREEN_AR1021_I2C is not set
+# CONFIG_TOUCHSCREEN_ATMEL_MXT is not set
+# CONFIG_TOUCHSCREEN_AUO_PIXCIR is not set
+# CONFIG_TOUCHSCREEN_BU21013 is not set
+# CONFIG_TOUCHSCREEN_CHIPONE_ICN8318 is not set
+# CONFIG_TOUCHSCREEN_CY8CTMG110 is not set
+# CONFIG_TOUCHSCREEN_CYTTSP_CORE is not set
+# CONFIG_TOUCHSCREEN_CYTTSP4_CORE is not set
+# CONFIG_TOUCHSCREEN_DYNAPRO is not set
+# CONFIG_TOUCHSCREEN_HAMPSHIRE is not set
+# CONFIG_TOUCHSCREEN_EETI is not set
+# CONFIG_TOUCHSCREEN_EGALAX is not set
+# CONFIG_TOUCHSCREEN_EGALAX_SERIAL is not set
+# CONFIG_TOUCHSCREEN_FUJITSU is not set
+CONFIG_TOUCHSCREEN_GOODIX=m
+# CONFIG_TOUCHSCREEN_ILI210X is not set
+# CONFIG_TOUCHSCREEN_GUNZE is not set
+# CONFIG_TOUCHSCREEN_EKTF2127 is not set
+# CONFIG_TOUCHSCREEN_ELAN is not set
+# CONFIG_TOUCHSCREEN_ELO is not set
+# CONFIG_TOUCHSCREEN_WACOM_W8001 is not set
+# CONFIG_TOUCHSCREEN_WACOM_I2C is not set
+# CONFIG_TOUCHSCREEN_MAX11801 is not set
+# CONFIG_TOUCHSCREEN_MCS5000 is not set
+# CONFIG_TOUCHSCREEN_MMS114 is not set
+# CONFIG_TOUCHSCREEN_MELFAS_MIP4 is not set
+# CONFIG_TOUCHSCREEN_MTOUCH is not set
+# CONFIG_TOUCHSCREEN_IMX6UL_TSC is not set
+# CONFIG_TOUCHSCREEN_INEXIO is not set
+# CONFIG_TOUCHSCREEN_MK712 is not set
+# CONFIG_TOUCHSCREEN_PENMOUNT is not set
+# CONFIG_TOUCHSCREEN_EDT_FT5X06 is not set
+# CONFIG_TOUCHSCREEN_TOUCHRIGHT is not set
+# CONFIG_TOUCHSCREEN_TOUCHWIN is not set
+# CONFIG_TOUCHSCREEN_PIXCIR is not set
+# CONFIG_TOUCHSCREEN_WDT87XX_I2C is not set
+# CONFIG_TOUCHSCREEN_USB_COMPOSITE is not set
+# CONFIG_TOUCHSCREEN_TOUCHIT213 is not set
+# CONFIG_TOUCHSCREEN_TSC_SERIO is not set
+# CONFIG_TOUCHSCREEN_TSC2004 is not set
+# CONFIG_TOUCHSCREEN_TSC2005 is not set
+# CONFIG_TOUCHSCREEN_TSC2007 is not set
+# CONFIG_TOUCHSCREEN_RM_TS is not set
+# CONFIG_TOUCHSCREEN_SILEAD is not set
+# CONFIG_TOUCHSCREEN_SIS_I2C is not set
+# CONFIG_TOUCHSCREEN_ST1232 is not set
+# CONFIG_TOUCHSCREEN_STMFTS is not set
+# CONFIG_TOUCHSCREEN_SURFACE3_SPI is not set
+# CONFIG_TOUCHSCREEN_SX8654 is not set
+# CONFIG_TOUCHSCREEN_TPS6507X is not set
+# CONFIG_TOUCHSCREEN_ZET6223 is not set
+# CONFIG_TOUCHSCREEN_ZFORCE is not set
+# CONFIG_TOUCHSCREEN_ROHM_BU21023 is not set
+CONFIG_INPUT_MISC=y
+# CONFIG_INPUT_AD714X is not set
+# CONFIG_INPUT_ATMEL_CAPTOUCH is not set
+# CONFIG_INPUT_BMA150 is not set
+# CONFIG_INPUT_E3X0_BUTTON is not set
+# CONFIG_INPUT_MMA8450 is not set
+# CONFIG_INPUT_GP2A is not set
+# CONFIG_INPUT_GPIO_BEEPER is not set
+# CONFIG_INPUT_GPIO_TILT_POLLED is not set
+# CONFIG_INPUT_GPIO_DECODER is not set
+# CONFIG_INPUT_ATI_REMOTE2 is not set
+# CONFIG_INPUT_KEYSPAN_REMOTE is not set
+# CONFIG_INPUT_KXTJ9 is not set
+# CONFIG_INPUT_POWERMATE is not set
+# CONFIG_INPUT_YEALINK is not set
+# CONFIG_INPUT_CM109 is not set
+# CONFIG_INPUT_REGULATOR_HAPTIC is not set
+# CONFIG_INPUT_AXP20X_PEK is not set
+# CONFIG_INPUT_UINPUT is not set
+# CONFIG_INPUT_PCF8574 is not set
+# CONFIG_INPUT_PWM_BEEPER is not set
+# CONFIG_INPUT_PWM_VIBRA is not set
+# CONFIG_INPUT_GPIO_ROTARY_ENCODER is not set
+# CONFIG_INPUT_ADXL34X is not set
+# CONFIG_INPUT_IMS_PCU is not set
+# CONFIG_INPUT_CMA3000 is not set
+# CONFIG_INPUT_DRV260X_HAPTICS is not set
+# CONFIG_INPUT_DRV2665_HAPTICS is not set
+# CONFIG_INPUT_DRV2667_HAPTICS is not set
+# CONFIG_RMI4_CORE is not set
+
+#
+# Hardware I/O ports
+#
+CONFIG_SERIO=y
+# CONFIG_SERIO_SERPORT is not set
+# CONFIG_SERIO_LIBPS2 is not set
+# CONFIG_SERIO_RAW is not set
+# CONFIG_SERIO_ALTERA_PS2 is not set
+# CONFIG_SERIO_PS2MULT is not set
+# CONFIG_SERIO_ARC_PS2 is not set
+# CONFIG_SERIO_APBPS2 is not set
+# CONFIG_SERIO_SUN4I_PS2 is not set
+# CONFIG_SERIO_GPIO_PS2 is not set
+# CONFIG_USERIO is not set
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+CONFIG_TTY=y
+CONFIG_VT=y
+CONFIG_CONSOLE_TRANSLATIONS=y
+CONFIG_VT_CONSOLE=y
+CONFIG_VT_CONSOLE_SLEEP=y
+CONFIG_HW_CONSOLE=y
+CONFIG_VT_HW_CONSOLE_BINDING=y
+CONFIG_UNIX98_PTYS=y
+CONFIG_LEGACY_PTYS=y
+CONFIG_LEGACY_PTY_COUNT=256
+# CONFIG_SERIAL_NONSTANDARD is not set
+# CONFIG_N_GSM is not set
+# CONFIG_TRACE_SINK is not set
+CONFIG_DEVMEM=y
+# CONFIG_DEVKMEM is not set
+
+#
+# Serial drivers
+#
+CONFIG_SERIAL_EARLYCON=y
+CONFIG_SERIAL_8250=y
+CONFIG_SERIAL_8250_DEPRECATED_OPTIONS=y
+# CONFIG_SERIAL_8250_FINTEK is not set
+CONFIG_SERIAL_8250_CONSOLE=y
+CONFIG_SERIAL_8250_DMA=y
+CONFIG_SERIAL_8250_NR_UARTS=8
+CONFIG_SERIAL_8250_RUNTIME_UARTS=8
+# CONFIG_SERIAL_8250_EXTENDED is not set
+# CONFIG_SERIAL_8250_ASPEED_VUART is not set
+CONFIG_SERIAL_8250_FSL=y
+CONFIG_SERIAL_8250_DW=y
+# CONFIG_SERIAL_8250_EM is not set
+# CONFIG_SERIAL_8250_RT288X is not set
+CONFIG_SERIAL_OF_PLATFORM=y
+
+#
+# Non-8250 serial port support
+#
+# CONFIG_SERIAL_EARLYCON_ARM_SEMIHOST is not set
+# CONFIG_SERIAL_MAX3100 is not set
+# CONFIG_SERIAL_MAX310X is not set
+# CONFIG_SERIAL_UARTLITE is not set
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+# CONFIG_SERIAL_SCCNXP is not set
+# CONFIG_SERIAL_SC16IS7XX is not set
+# CONFIG_SERIAL_BCM63XX is not set
+# CONFIG_SERIAL_ALTERA_JTAGUART is not set
+# CONFIG_SERIAL_ALTERA_UART is not set
+# CONFIG_SERIAL_IFX6X60 is not set
+# CONFIG_SERIAL_XILINX_PS_UART is not set
+# CONFIG_SERIAL_ARC is not set
+# CONFIG_SERIAL_FSL_LPUART is not set
+# CONFIG_SERIAL_CONEXANT_DIGICOLOR is not set
+# CONFIG_SERIAL_ST_ASC is not set
+# CONFIG_SERIAL_DEV_BUS is not set
+# CONFIG_HVC_DCC is not set
+# CONFIG_IPMI_HANDLER is not set
+# CONFIG_HW_RANDOM is not set
+# CONFIG_R3964 is not set
+# CONFIG_RAW_DRIVER is not set
+# CONFIG_TCG_TPM is not set
+# CONFIG_XILLYBUS is not set
+
+#
+# I2C support
+#
+CONFIG_I2C=y
+CONFIG_I2C_BOARDINFO=y
+CONFIG_I2C_COMPAT=y
+CONFIG_I2C_CHARDEV=y
+# CONFIG_I2C_MUX is not set
+CONFIG_I2C_HELPER_AUTO=y
+CONFIG_I2C_ALGOBIT=y
+
+#
+# I2C Hardware Bus support
+#
+
+#
+# I2C system bus drivers (mostly embedded / system-on-chip)
+#
+# CONFIG_I2C_CBUS_GPIO is not set
+# CONFIG_I2C_DESIGNWARE_PLATFORM is not set
+# CONFIG_I2C_EMEV2 is not set
+# CONFIG_I2C_GPIO is not set
+CONFIG_I2C_MV64XXX=y
+# CONFIG_I2C_OCORES is not set
+# CONFIG_I2C_PCA_PLATFORM is not set
+# CONFIG_I2C_PXA_PCI is not set
+# CONFIG_I2C_RK3X is not set
+# CONFIG_I2C_SIMTEC is not set
+# CONFIG_I2C_XILINX is not set
+
+#
+# External I2C/SMBus adapter drivers
+#
+# CONFIG_I2C_DIOLAN_U2C is not set
+# CONFIG_I2C_PARPORT_LIGHT is not set
+# CONFIG_I2C_ROBOTFUZZ_OSIF is not set
+# CONFIG_I2C_TAOS_EVM is not set
+# CONFIG_I2C_TINY_USB is not set
+
+#
+# Other I2C/SMBus bus drivers
+#
+# CONFIG_I2C_STUB is not set
+# CONFIG_I2C_SLAVE is not set
+# CONFIG_I2C_DEBUG_CORE is not set
+# CONFIG_I2C_DEBUG_ALGO is not set
+# CONFIG_I2C_DEBUG_BUS is not set
+CONFIG_SPI=y
+# CONFIG_SPI_DEBUG is not set
+CONFIG_SPI_MASTER=y
+
+#
+# SPI Master Controller Drivers
+#
+# CONFIG_SPI_ALTERA is not set
+# CONFIG_SPI_AXI_SPI_ENGINE is not set
+CONFIG_SPI_BITBANG=y
+# CONFIG_SPI_CADENCE is not set
+# CONFIG_SPI_DESIGNWARE is not set
+CONFIG_SPI_GPIO=y
+# CONFIG_SPI_FSL_SPI is not set
+# CONFIG_SPI_OC_TINY is not set
+# CONFIG_SPI_PXA2XX_PCI is not set
+# CONFIG_SPI_ROCKCHIP is not set
+# CONFIG_SPI_SC18IS602 is not set
+CONFIG_SPI_SUN4I=y
+# CONFIG_SPI_SUN6I is not set
+# CONFIG_SPI_XCOMM is not set
+# CONFIG_SPI_XILINX is not set
+# CONFIG_SPI_ZYNQMP_GQSPI is not set
+
+#
+# SPI Protocol Masters
+#
+CONFIG_SPI_SPIDEV=y
+# CONFIG_SPI_LOOPBACK_TEST is not set
+# CONFIG_SPI_TLE62X0 is not set
+# CONFIG_SPI_SLAVE is not set
+# CONFIG_SPMI is not set
+# CONFIG_HSI is not set
+CONFIG_PPS=y
+# CONFIG_PPS_DEBUG is not set
+
+#
+# PPS clients support
+#
+# CONFIG_PPS_CLIENT_KTIMER is not set
+# CONFIG_PPS_CLIENT_LDISC is not set
+# CONFIG_PPS_CLIENT_GPIO is not set
+
+#
+# PPS generators support
+#
+
+#
+# PTP clock support
+#
+CONFIG_PTP_1588_CLOCK=y
+
+#
+# Enable PHYLIB and NETWORK_PHY_TIMESTAMPING to see the additional clocks.
+#
+CONFIG_PINCTRL=y
+
+#
+# Pin controllers
+#
+CONFIG_PINMUX=y
+CONFIG_PINCONF=y
+CONFIG_GENERIC_PINCONF=y
+# CONFIG_DEBUG_PINCTRL is not set
+# CONFIG_PINCTRL_AMD is not set
+# CONFIG_PINCTRL_MCP23S08 is not set
+# CONFIG_PINCTRL_SINGLE is not set
+# CONFIG_PINCTRL_SX150X is not set
+CONFIG_PINCTRL_SUNXI=y
+CONFIG_PINCTRL_SUNIV=y
+# CONFIG_PINCTRL_SUN4I_A10 is not set
+# CONFIG_PINCTRL_SUN5I is not set
+# CONFIG_PINCTRL_SUN6I_A31 is not set
+# CONFIG_PINCTRL_SUN6I_A31_R is not set
+# CONFIG_PINCTRL_SUN8I_A23 is not set
+# CONFIG_PINCTRL_SUN8I_A33 is not set
+# CONFIG_PINCTRL_SUN8I_A83T is not set
+# CONFIG_PINCTRL_SUN8I_A83T_R is not set
+# CONFIG_PINCTRL_SUN8I_A23_R is not set
+# CONFIG_PINCTRL_SUN8I_H3 is not set
+# CONFIG_PINCTRL_SUN8I_H3_R is not set
+# CONFIG_PINCTRL_SUN8I_V3S is not set
+# CONFIG_PINCTRL_SUN9I_A80 is not set
+# CONFIG_PINCTRL_SUN9I_A80_R is not set
+# CONFIG_PINCTRL_SUN50I_A64 is not set
+# CONFIG_PINCTRL_SUN50I_A64_R is not set
+# CONFIG_PINCTRL_SUN50I_H5 is not set
+CONFIG_ARCH_HAVE_CUSTOM_GPIO_H=y
+CONFIG_GPIOLIB=y
+CONFIG_OF_GPIO=y
+# CONFIG_DEBUG_GPIO is not set
+CONFIG_GPIO_SYSFS=y
+
+#
+# Memory mapped GPIO drivers
+#
+# CONFIG_GPIO_74XX_MMIO is not set
+# CONFIG_GPIO_ALTERA is not set
+# CONFIG_GPIO_AXP209 is not set
+# CONFIG_GPIO_DWAPB is not set
+# CONFIG_GPIO_FTGPIO010 is not set
+# CONFIG_GPIO_GENERIC_PLATFORM is not set
+# CONFIG_GPIO_GRGPIO is not set
+# CONFIG_GPIO_MOCKUP is not set
+# CONFIG_GPIO_MPC8XXX is not set
+# CONFIG_GPIO_SYSCON is not set
+# CONFIG_GPIO_XILINX is not set
+# CONFIG_GPIO_ZEVIO is not set
+
+#
+# I2C GPIO expanders
+#
+# CONFIG_GPIO_ADP5588 is not set
+# CONFIG_GPIO_ADNP is not set
+# CONFIG_GPIO_MAX7300 is not set
+# CONFIG_GPIO_MAX732X is not set
+# CONFIG_GPIO_PCA953X is not set
+# CONFIG_GPIO_PCF857X is not set
+# CONFIG_GPIO_SX150X is not set
+# CONFIG_GPIO_TPIC2810 is not set
+
+#
+# MFD GPIO expanders
+#
+# CONFIG_HTC_EGPIO is not set
+
+#
+# SPI GPIO expanders
+#
+# CONFIG_GPIO_74X164 is not set
+# CONFIG_GPIO_MAX7301 is not set
+# CONFIG_GPIO_MC33880 is not set
+# CONFIG_GPIO_PISOSR is not set
+# CONFIG_GPIO_XRA1403 is not set
+
+#
+# USB GPIO expanders
+#
+# CONFIG_W1 is not set
+# CONFIG_POWER_AVS is not set
+# CONFIG_POWER_RESET is not set
+CONFIG_POWER_SUPPLY=y
+# CONFIG_POWER_SUPPLY_DEBUG is not set
+# CONFIG_PDA_POWER is not set
+# CONFIG_TEST_POWER is not set
+# CONFIG_BATTERY_DS2780 is not set
+# CONFIG_BATTERY_DS2781 is not set
+# CONFIG_BATTERY_DS2782 is not set
+# CONFIG_BATTERY_SBS is not set
+# CONFIG_CHARGER_SBS is not set
+# CONFIG_BATTERY_BQ27XXX is not set
+# CONFIG_BATTERY_MAX17040 is not set
+# CONFIG_BATTERY_MAX17042 is not set
+# CONFIG_CHARGER_ISP1704 is not set
+# CONFIG_CHARGER_MAX8903 is not set
+# CONFIG_CHARGER_LP8727 is not set
+# CONFIG_CHARGER_GPIO is not set
+# CONFIG_CHARGER_MANAGER is not set
+# CONFIG_CHARGER_LTC3651 is not set
+# CONFIG_CHARGER_DETECTOR_MAX14656 is not set
+# CONFIG_CHARGER_BQ2415X is not set
+# CONFIG_CHARGER_BQ24190 is not set
+# CONFIG_CHARGER_BQ24257 is not set
+# CONFIG_CHARGER_BQ24735 is not set
+# CONFIG_CHARGER_BQ25890 is not set
+# CONFIG_CHARGER_SMB347 is not set
+# CONFIG_BATTERY_GAUGE_LTC2941 is not set
+# CONFIG_CHARGER_RT9455 is not set
+# CONFIG_HWMON is not set
+CONFIG_THERMAL=y
+CONFIG_THERMAL_EMERGENCY_POWEROFF_DELAY_MS=0
+CONFIG_THERMAL_OF=y
+# CONFIG_THERMAL_WRITABLE_TRIPS is not set
+CONFIG_THERMAL_DEFAULT_GOV_STEP_WISE=y
+# CONFIG_THERMAL_DEFAULT_GOV_FAIR_SHARE is not set
+# CONFIG_THERMAL_DEFAULT_GOV_USER_SPACE is not set
+# CONFIG_THERMAL_DEFAULT_GOV_POWER_ALLOCATOR is not set
+# CONFIG_THERMAL_GOV_FAIR_SHARE is not set
+CONFIG_THERMAL_GOV_STEP_WISE=y
+# CONFIG_THERMAL_GOV_BANG_BANG is not set
+# CONFIG_THERMAL_GOV_USER_SPACE is not set
+# CONFIG_THERMAL_GOV_POWER_ALLOCATOR is not set
+CONFIG_CPU_THERMAL=y
+# CONFIG_CLOCK_THERMAL is not set
+# CONFIG_THERMAL_EMULATION is not set
+# CONFIG_QORIQ_THERMAL is not set
+
+#
+# ACPI INT340X thermal drivers
+#
+# CONFIG_WATCHDOG is not set
+CONFIG_SSB_POSSIBLE=y
+
+#
+# Sonics Silicon Backplane
+#
+# CONFIG_SSB is not set
+CONFIG_BCMA_POSSIBLE=y
+# CONFIG_BCMA is not set
+
+#
+# Multifunction device drivers
+#
+CONFIG_MFD_CORE=y
+# CONFIG_MFD_ACT8945A is not set
+# CONFIG_MFD_SUN4I_GPADC is not set
+# CONFIG_MFD_AS3711 is not set
+# CONFIG_MFD_AS3722 is not set
+# CONFIG_PMIC_ADP5520 is not set
+# CONFIG_MFD_AAT2870_CORE is not set
+# CONFIG_MFD_ATMEL_FLEXCOM is not set
+# CONFIG_MFD_ATMEL_HLCDC is not set
+# CONFIG_MFD_BCM590XX is not set
+# CONFIG_MFD_BD9571MWV is not set
+# CONFIG_MFD_AC100 is not set
+CONFIG_MFD_AXP20X=y
+CONFIG_MFD_AXP20X_I2C=y
+CONFIG_MFD_AXP20X_RSB=y
+# CONFIG_MFD_CROS_EC is not set
+# CONFIG_MFD_ASIC3 is not set
+# CONFIG_PMIC_DA903X is not set
+# CONFIG_MFD_DA9052_SPI is not set
+# CONFIG_MFD_DA9052_I2C is not set
+# CONFIG_MFD_DA9055 is not set
+# CONFIG_MFD_DA9062 is not set
+# CONFIG_MFD_DA9063 is not set
+# CONFIG_MFD_DA9150 is not set
+# CONFIG_MFD_DLN2 is not set
+# CONFIG_MFD_MC13XXX_SPI is not set
+# CONFIG_MFD_MC13XXX_I2C is not set
+# CONFIG_MFD_HI6421_PMIC is not set
+# CONFIG_HTC_PASIC3 is not set
+# CONFIG_HTC_I2CPLD is not set
+# CONFIG_MFD_KEMPLD is not set
+# CONFIG_MFD_88PM800 is not set
+# CONFIG_MFD_88PM805 is not set
+# CONFIG_MFD_88PM860X is not set
+# CONFIG_MFD_MAX14577 is not set
+# CONFIG_MFD_MAX77620 is not set
+# CONFIG_MFD_MAX77686 is not set
+# CONFIG_MFD_MAX77693 is not set
+# CONFIG_MFD_MAX77843 is not set
+# CONFIG_MFD_MAX8907 is not set
+# CONFIG_MFD_MAX8925 is not set
+# CONFIG_MFD_MAX8997 is not set
+# CONFIG_MFD_MAX8998 is not set
+# CONFIG_MFD_MT6397 is not set
+# CONFIG_MFD_MENF21BMC is not set
+# CONFIG_EZX_PCAP is not set
+# CONFIG_MFD_CPCAP is not set
+# CONFIG_MFD_VIPERBOARD is not set
+# CONFIG_MFD_RETU is not set
+# CONFIG_MFD_PCF50633 is not set
+# CONFIG_MFD_PM8XXX is not set
+# CONFIG_MFD_RT5033 is not set
+# CONFIG_MFD_RTSX_USB is not set
+# CONFIG_MFD_RC5T583 is not set
+# CONFIG_MFD_RK808 is not set
+# CONFIG_MFD_RN5T618 is not set
+# CONFIG_MFD_SEC_CORE is not set
+# CONFIG_MFD_SI476X_CORE is not set
+# CONFIG_MFD_SM501 is not set
+# CONFIG_MFD_SKY81452 is not set
+# CONFIG_MFD_SMSC is not set
+# CONFIG_ABX500_CORE is not set
+# CONFIG_MFD_STMPE is not set
+CONFIG_MFD_SUN6I_PRCM=y
+CONFIG_MFD_SYSCON=y
+# CONFIG_MFD_TI_AM335X_TSCADC is not set
+# CONFIG_MFD_LP3943 is not set
+# CONFIG_MFD_LP8788 is not set
+# CONFIG_MFD_TI_LMU is not set
+# CONFIG_MFD_PALMAS is not set
+# CONFIG_TPS6105X is not set
+# CONFIG_TPS65010 is not set
+# CONFIG_TPS6507X is not set
+# CONFIG_MFD_TPS65086 is not set
+# CONFIG_MFD_TPS65090 is not set
+# CONFIG_MFD_TPS65217 is not set
+# CONFIG_MFD_TI_LP873X is not set
+# CONFIG_MFD_TI_LP87565 is not set
+# CONFIG_MFD_TPS65218 is not set
+# CONFIG_MFD_TPS6586X is not set
+# CONFIG_MFD_TPS65910 is not set
+# CONFIG_MFD_TPS65912_I2C is not set
+# CONFIG_MFD_TPS65912_SPI is not set
+# CONFIG_MFD_TPS80031 is not set
+# CONFIG_TWL4030_CORE is not set
+# CONFIG_TWL6040_CORE is not set
+# CONFIG_MFD_WL1273_CORE is not set
+# CONFIG_MFD_LM3533 is not set
+# CONFIG_MFD_TC3589X is not set
+# CONFIG_MFD_TMIO is not set
+# CONFIG_MFD_T7L66XB is not set
+# CONFIG_MFD_TC6387XB is not set
+# CONFIG_MFD_TC6393XB is not set
+# CONFIG_MFD_ARIZONA_I2C is not set
+# CONFIG_MFD_ARIZONA_SPI is not set
+# CONFIG_MFD_WM8400 is not set
+# CONFIG_MFD_WM831X_I2C is not set
+# CONFIG_MFD_WM831X_SPI is not set
+# CONFIG_MFD_WM8350_I2C is not set
+# CONFIG_MFD_WM8994 is not set
+CONFIG_REGULATOR=y
+# CONFIG_REGULATOR_DEBUG is not set
+CONFIG_REGULATOR_FIXED_VOLTAGE=y
+# CONFIG_REGULATOR_VIRTUAL_CONSUMER is not set
+# CONFIG_REGULATOR_USERSPACE_CONSUMER is not set
+# CONFIG_REGULATOR_ACT8865 is not set
+# CONFIG_REGULATOR_AD5398 is not set
+# CONFIG_REGULATOR_ANATOP is not set
+# CONFIG_REGULATOR_AXP20X is not set
+# CONFIG_REGULATOR_DA9210 is not set
+# CONFIG_REGULATOR_DA9211 is not set
+# CONFIG_REGULATOR_FAN53555 is not set
+# CONFIG_REGULATOR_GPIO is not set
+# CONFIG_REGULATOR_ISL9305 is not set
+# CONFIG_REGULATOR_ISL6271A is not set
+# CONFIG_REGULATOR_LP3971 is not set
+# CONFIG_REGULATOR_LP3972 is not set
+# CONFIG_REGULATOR_LP872X is not set
+# CONFIG_REGULATOR_LP8755 is not set
+# CONFIG_REGULATOR_LTC3589 is not set
+# CONFIG_REGULATOR_LTC3676 is not set
+# CONFIG_REGULATOR_MAX1586 is not set
+# CONFIG_REGULATOR_MAX8649 is not set
+# CONFIG_REGULATOR_MAX8660 is not set
+# CONFIG_REGULATOR_MAX8952 is not set
+# CONFIG_REGULATOR_MAX8973 is not set
+# CONFIG_REGULATOR_MT6311 is not set
+# CONFIG_REGULATOR_PFUZE100 is not set
+# CONFIG_REGULATOR_PV88060 is not set
+# CONFIG_REGULATOR_PV88080 is not set
+# CONFIG_REGULATOR_PV88090 is not set
+# CONFIG_REGULATOR_PWM is not set
+# CONFIG_REGULATOR_TPS51632 is not set
+# CONFIG_REGULATOR_TPS62360 is not set
+# CONFIG_REGULATOR_TPS65023 is not set
+# CONFIG_REGULATOR_TPS6507X is not set
+# CONFIG_REGULATOR_TPS65132 is not set
+# CONFIG_REGULATOR_TPS6524X is not set
+# CONFIG_REGULATOR_VCTRL is not set
+# CONFIG_RC_CORE is not set
+CONFIG_MEDIA_SUPPORT=y
+
+#
+# Multimedia core support
+#
+# CONFIG_MEDIA_CAMERA_SUPPORT is not set
+# CONFIG_MEDIA_ANALOG_TV_SUPPORT is not set
+# CONFIG_MEDIA_DIGITAL_TV_SUPPORT is not set
+# CONFIG_MEDIA_RADIO_SUPPORT is not set
+# CONFIG_MEDIA_SDR_SUPPORT is not set
+# CONFIG_MEDIA_CEC_SUPPORT is not set
+# CONFIG_VIDEO_ADV_DEBUG is not set
+# CONFIG_VIDEO_FIXED_MINOR_RANGES is not set
+# CONFIG_TTPCI_EEPROM is not set
+
+#
+# Media drivers
+#
+# CONFIG_MEDIA_USB_SUPPORT is not set
+
+#
+# Supported MMC/SDIO adapters
+#
+# CONFIG_CYPRESS_FIRMWARE is not set
+
+#
+# Media ancillary drivers (tuners, sensors, i2c, spi, frontends)
+#
+
+#
+# Customise DVB Frontends
+#
+
+#
+# Tools to develop new frontends
+#
+
+#
+# Graphics support
+#
+# CONFIG_IMX_IPUV3_CORE is not set
+CONFIG_DRM=y
+# CONFIG_DRM_DP_AUX_CHARDEV is not set
+# CONFIG_DRM_DEBUG_MM is not set
+# CONFIG_DRM_DEBUG_MM_SELFTEST is not set
+CONFIG_DRM_KMS_HELPER=y
+CONFIG_DRM_KMS_FB_HELPER=y
+CONFIG_DRM_FBDEV_EMULATION=y
+CONFIG_DRM_FBDEV_OVERALLOC=100
+# CONFIG_DRM_LOAD_EDID_FIRMWARE is not set
+CONFIG_DRM_GEM_CMA_HELPER=y
+CONFIG_DRM_KMS_CMA_HELPER=y
+
+#
+# I2C encoder or helper chips
+#
+# CONFIG_DRM_I2C_CH7006 is not set
+# CONFIG_DRM_I2C_SIL164 is not set
+# CONFIG_DRM_I2C_NXP_TDA998X is not set
+# CONFIG_DRM_HDLCD is not set
+# CONFIG_DRM_MALI_DISPLAY is not set
+
+#
+# ACP (Audio CoProcessor) Configuration
+#
+# CONFIG_DRM_VGEM is not set
+# CONFIG_DRM_EXYNOS is not set
+# CONFIG_DRM_UDL is not set
+# CONFIG_DRM_ARMADA is not set
+# CONFIG_DRM_RCAR_DW_HDMI is not set
+CONFIG_DRM_SUN4I=y
+CONFIG_DRM_SUN4I_HDMI=y
+# CONFIG_DRM_SUN4I_HDMI_CEC is not set
+CONFIG_DRM_SUN4I_BACKEND=y
+CONFIG_DRM_SUN8I_MIXER=y
+# CONFIG_DRM_OMAP is not set
+# CONFIG_DRM_TILCDC is not set
+# CONFIG_DRM_FSL_DCU is not set
+# CONFIG_DRM_STM is not set
+CONFIG_DRM_PANEL=y
+
+#
+# Display Panels
+#
+# CONFIG_DRM_PANEL_LVDS is not set
+CONFIG_DRM_PANEL_SIMPLE=y
+# CONFIG_DRM_PANEL_SAMSUNG_LD9040 is not set
+# CONFIG_DRM_PANEL_LG_LG4573 is not set
+# CONFIG_DRM_PANEL_SAMSUNG_S6E8AA0 is not set
+# CONFIG_DRM_PANEL_SITRONIX_ST7789V is not set
+CONFIG_DRM_BRIDGE=y
+CONFIG_DRM_PANEL_BRIDGE=y
+
+#
+# Display Interface Bridges
+#
+# CONFIG_DRM_ANALOGIX_ANX78XX is not set
+CONFIG_DRM_DUMB_VGA_DAC=y
+# CONFIG_DRM_LVDS_ENCODER is not set
+# CONFIG_DRM_MEGACHIPS_STDPXXXX_GE_B850V3_FW is not set
+# CONFIG_DRM_NXP_PTN3460 is not set
+# CONFIG_DRM_PARADE_PS8622 is not set
+# CONFIG_DRM_SIL_SII8620 is not set
+# CONFIG_DRM_SII902X is not set
+# CONFIG_DRM_TOSHIBA_TC358767 is not set
+# CONFIG_DRM_TI_TFP410 is not set
+# CONFIG_DRM_I2C_ADV7511 is not set
+# CONFIG_DRM_STI is not set
+# CONFIG_DRM_ARCPGU is not set
+# CONFIG_DRM_MXSFB is not set
+# CONFIG_DRM_TINYDRM is not set
+# CONFIG_DRM_PL111 is not set
+# CONFIG_DRM_LEGACY is not set
+# CONFIG_DRM_LIB_RANDOM is not set
+
+#
+# Frame buffer Devices
+#
+CONFIG_FB=y
+# CONFIG_FIRMWARE_EDID is not set
+CONFIG_FB_CMDLINE=y
+CONFIG_FB_NOTIFY=y
+# CONFIG_FB_DDC is not set
+# CONFIG_FB_BOOT_VESA_SUPPORT is not set
+CONFIG_FB_CFB_FILLRECT=y
+CONFIG_FB_CFB_COPYAREA=y
+CONFIG_FB_CFB_IMAGEBLIT=y
+# CONFIG_FB_CFB_REV_PIXELS_IN_BYTE is not set
+CONFIG_FB_SYS_FILLRECT=y
+CONFIG_FB_SYS_COPYAREA=y
+CONFIG_FB_SYS_IMAGEBLIT=y
+# CONFIG_FB_PROVIDE_GET_FB_UNMAPPED_AREA is not set
+# CONFIG_FB_FOREIGN_ENDIAN is not set
+CONFIG_FB_SYS_FOPS=y
+CONFIG_FB_DEFERRED_IO=y
+# CONFIG_FB_SVGALIB is not set
+# CONFIG_FB_MACMODES is not set
+CONFIG_FB_BACKLIGHT=y
+# CONFIG_FB_MODE_HELPERS is not set
+# CONFIG_FB_TILEBLITTING is not set
+
+#
+# Frame buffer hardware drivers
+#
+# CONFIG_FB_OPENCORES is not set
+# CONFIG_FB_S1D13XXX is not set
+# CONFIG_FB_SMSCUFX is not set
+# CONFIG_FB_UDL is not set
+# CONFIG_FB_IBM_GXT4500 is not set
+# CONFIG_FB_VIRTUAL is not set
+# CONFIG_FB_METRONOME is not set
+# CONFIG_FB_BROADSHEET is not set
+# CONFIG_FB_AUO_K190X is not set
+# CONFIG_FB_SIMPLE is not set
+# CONFIG_FB_SSD1307 is not set
+CONFIG_BACKLIGHT_LCD_SUPPORT=y
+CONFIG_LCD_CLASS_DEVICE=m
+# CONFIG_LCD_L4F00242T03 is not set
+# CONFIG_LCD_LMS283GF05 is not set
+# CONFIG_LCD_LTV350QV is not set
+# CONFIG_LCD_ILI922X is not set
+# CONFIG_LCD_ILI9320 is not set
+# CONFIG_LCD_TDO24M is not set
+# CONFIG_LCD_VGG2432A4 is not set
+# CONFIG_LCD_PLATFORM is not set
+# CONFIG_LCD_S6E63M0 is not set
+# CONFIG_LCD_LD9040 is not set
+# CONFIG_LCD_AMS369FG06 is not set
+# CONFIG_LCD_LMS501KF03 is not set
+# CONFIG_LCD_HX8357 is not set
+CONFIG_BACKLIGHT_CLASS_DEVICE=y
+CONFIG_BACKLIGHT_GENERIC=y
+CONFIG_BACKLIGHT_PWM=y
+# CONFIG_BACKLIGHT_PM8941_WLED is not set
+# CONFIG_BACKLIGHT_ADP8860 is not set
+# CONFIG_BACKLIGHT_ADP8870 is not set
+# CONFIG_BACKLIGHT_LM3630A is not set
+# CONFIG_BACKLIGHT_LM3639 is not set
+# CONFIG_BACKLIGHT_LP855X is not set
+# CONFIG_BACKLIGHT_GPIO is not set
+# CONFIG_BACKLIGHT_LV5207LP is not set
+# CONFIG_BACKLIGHT_BD6107 is not set
+# CONFIG_BACKLIGHT_ARCXCNN is not set
+# CONFIG_VGASTATE is not set
+CONFIG_VIDEOMODE_HELPERS=y
+CONFIG_HDMI=y
+
+#
+# Console display driver support
+#
+CONFIG_DUMMY_CONSOLE=y
+CONFIG_FRAMEBUFFER_CONSOLE=y
+CONFIG_FRAMEBUFFER_CONSOLE_DETECT_PRIMARY=y
+# CONFIG_FRAMEBUFFER_CONSOLE_ROTATION is not set
+# CONFIG_LOGO is not set
+CONFIG_SOUND=y
+CONFIG_SOUND_OSS_CORE=y
+CONFIG_SOUND_OSS_CORE_PRECLAIM=y
+CONFIG_SND=y
+CONFIG_SND_TIMER=y
+CONFIG_SND_PCM=y
+CONFIG_SND_DMAENGINE_PCM=y
+CONFIG_SND_JACK=y
+CONFIG_SND_JACK_INPUT_DEV=y
+CONFIG_SND_OSSEMUL=y
+CONFIG_SND_MIXER_OSS=y
+CONFIG_SND_PCM_OSS=y
+CONFIG_SND_PCM_OSS_PLUGINS=y
+CONFIG_SND_PCM_TIMER=y
+# CONFIG_SND_HRTIMER is not set
+# CONFIG_SND_DYNAMIC_MINORS is not set
+CONFIG_SND_SUPPORT_OLD_API=y
+CONFIG_SND_PROC_FS=y
+CONFIG_SND_VERBOSE_PROCFS=y
+# CONFIG_SND_VERBOSE_PRINTK is not set
+# CONFIG_SND_DEBUG is not set
+# CONFIG_SND_SEQUENCER is not set
+# CONFIG_SND_OPL3_LIB_SEQ is not set
+# CONFIG_SND_OPL4_LIB_SEQ is not set
+CONFIG_SND_DRIVERS=y
+# CONFIG_SND_DUMMY is not set
+CONFIG_SND_ALOOP=y
+# CONFIG_SND_MTPAV is not set
+# CONFIG_SND_SERIAL_U16550 is not set
+# CONFIG_SND_MPU401 is not set
+
+#
+# HD-Audio
+#
+CONFIG_SND_HDA_PREALLOC_SIZE=64
+CONFIG_SND_ARM=y
+# CONFIG_SND_SPI is not set
+CONFIG_SND_USB=y
+# CONFIG_SND_USB_AUDIO is not set
+# CONFIG_SND_USB_UA101 is not set
+# CONFIG_SND_USB_CAIAQ is not set
+# CONFIG_SND_USB_6FIRE is not set
+# CONFIG_SND_USB_HIFACE is not set
+# CONFIG_SND_BCD2000 is not set
+# CONFIG_SND_USB_POD is not set
+# CONFIG_SND_USB_PODHD is not set
+# CONFIG_SND_USB_TONEPORT is not set
+# CONFIG_SND_USB_VARIAX is not set
+CONFIG_SND_SOC=y
+CONFIG_SND_SOC_GENERIC_DMAENGINE_PCM=y
+# CONFIG_SND_SOC_AMD_ACP is not set
+# CONFIG_SND_ATMEL_SOC is not set
+# CONFIG_SND_DESIGNWARE_I2S is not set
+
+#
+# SoC Audio for Freescale CPUs
+#
+
+#
+# Common SoC Audio options for Freescale CPUs:
+#
+# CONFIG_SND_SOC_FSL_ASRC is not set
+# CONFIG_SND_SOC_FSL_SAI is not set
+# CONFIG_SND_SOC_FSL_SSI is not set
+# CONFIG_SND_SOC_FSL_SPDIF is not set
+# CONFIG_SND_SOC_FSL_ESAI is not set
+# CONFIG_SND_SOC_IMX_AUDMUX is not set
+# CONFIG_SND_I2S_HI6210_I2S is not set
+# CONFIG_SND_SOC_IMG is not set
+
+#
+# STMicroelectronics STM32 SOC audio support
+#
+
+#
+# Allwinner SoC Audio support
+#
+CONFIG_SND_SUN4I_CODEC=y
+CONFIG_SND_SUN4I_I2S=y
+CONFIG_SND_SUN4I_SPDIF=y
+# CONFIG_SND_SOC_XTFPGA_I2S is not set
+# CONFIG_ZX_TDM is not set
+CONFIG_SND_SOC_I2C_AND_SPI=y
+
+#
+# CODEC drivers
+#
+# CONFIG_SND_SOC_AC97_CODEC is not set
+# CONFIG_SND_SOC_ADAU1701 is not set
+# CONFIG_SND_SOC_ADAU1761_I2C is not set
+# CONFIG_SND_SOC_ADAU1761_SPI is not set
+# CONFIG_SND_SOC_ADAU7002 is not set
+# CONFIG_SND_SOC_AK4104 is not set
+# CONFIG_SND_SOC_AK4554 is not set
+# CONFIG_SND_SOC_AK4613 is not set
+# CONFIG_SND_SOC_AK4642 is not set
+# CONFIG_SND_SOC_AK5386 is not set
+# CONFIG_SND_SOC_ALC5623 is not set
+# CONFIG_SND_SOC_BT_SCO is not set
+# CONFIG_SND_SOC_CS35L32 is not set
+# CONFIG_SND_SOC_CS35L33 is not set
+# CONFIG_SND_SOC_CS35L34 is not set
+# CONFIG_SND_SOC_CS35L35 is not set
+# CONFIG_SND_SOC_CS42L42 is not set
+# CONFIG_SND_SOC_CS42L51_I2C is not set
+# CONFIG_SND_SOC_CS42L52 is not set
+# CONFIG_SND_SOC_CS42L56 is not set
+# CONFIG_SND_SOC_CS42L73 is not set
+# CONFIG_SND_SOC_CS4265 is not set
+# CONFIG_SND_SOC_CS4270 is not set
+# CONFIG_SND_SOC_CS4271_I2C is not set
+# CONFIG_SND_SOC_CS4271_SPI is not set
+# CONFIG_SND_SOC_CS42XX8_I2C is not set
+# CONFIG_SND_SOC_CS43130 is not set
+# CONFIG_SND_SOC_CS4349 is not set
+# CONFIG_SND_SOC_CS53L30 is not set
+# CONFIG_SND_SOC_DIO2125 is not set
+# CONFIG_SND_SOC_ES7134 is not set
+# CONFIG_SND_SOC_ES8316 is not set
+# CONFIG_SND_SOC_ES8328_I2C is not set
+# CONFIG_SND_SOC_ES8328_SPI is not set
+# CONFIG_SND_SOC_GTM601 is not set
+# CONFIG_SND_SOC_INNO_RK3036 is not set
+# CONFIG_SND_SOC_MAX98504 is not set
+# CONFIG_SND_SOC_MAX98927 is not set
+# CONFIG_SND_SOC_MAX9860 is not set
+# CONFIG_SND_SOC_MSM8916_WCD_DIGITAL is not set
+# CONFIG_SND_SOC_PCM1681 is not set
+# CONFIG_SND_SOC_PCM179X_I2C is not set
+# CONFIG_SND_SOC_PCM179X_SPI is not set
+# CONFIG_SND_SOC_PCM3168A_I2C is not set
+# CONFIG_SND_SOC_PCM3168A_SPI is not set
+# CONFIG_SND_SOC_PCM512x_I2C is not set
+# CONFIG_SND_SOC_PCM512x_SPI is not set
+# CONFIG_SND_SOC_RT5616 is not set
+# CONFIG_SND_SOC_RT5631 is not set
+# CONFIG_SND_SOC_RT5677_SPI is not set
+# CONFIG_SND_SOC_SGTL5000 is not set
+# CONFIG_SND_SOC_SIRF_AUDIO_CODEC is not set
+# CONFIG_SND_SOC_SPDIF is not set
+# CONFIG_SND_SOC_SSM2602_SPI is not set
+# CONFIG_SND_SOC_SSM2602_I2C is not set
+# CONFIG_SND_SOC_SSM4567 is not set
+# CONFIG_SND_SOC_STA32X is not set
+# CONFIG_SND_SOC_STA350 is not set
+# CONFIG_SND_SOC_STI_SAS is not set
+# CONFIG_SND_SOC_TAS2552 is not set
+# CONFIG_SND_SOC_TAS5086 is not set
+# CONFIG_SND_SOC_TAS571X is not set
+# CONFIG_SND_SOC_TAS5720 is not set
+# CONFIG_SND_SOC_TFA9879 is not set
+# CONFIG_SND_SOC_TLV320AIC23_I2C is not set
+# CONFIG_SND_SOC_TLV320AIC23_SPI is not set
+# CONFIG_SND_SOC_TLV320AIC31XX is not set
+# CONFIG_SND_SOC_TLV320AIC3X is not set
+# CONFIG_SND_SOC_TS3A227E is not set
+# CONFIG_SND_SOC_WM8510 is not set
+# CONFIG_SND_SOC_WM8523 is not set
+# CONFIG_SND_SOC_WM8524 is not set
+# CONFIG_SND_SOC_WM8580 is not set
+# CONFIG_SND_SOC_WM8711 is not set
+# CONFIG_SND_SOC_WM8728 is not set
+# CONFIG_SND_SOC_WM8731 is not set
+# CONFIG_SND_SOC_WM8737 is not set
+# CONFIG_SND_SOC_WM8741 is not set
+# CONFIG_SND_SOC_WM8750 is not set
+# CONFIG_SND_SOC_WM8753 is not set
+# CONFIG_SND_SOC_WM8770 is not set
+# CONFIG_SND_SOC_WM8776 is not set
+# CONFIG_SND_SOC_WM8804_I2C is not set
+# CONFIG_SND_SOC_WM8804_SPI is not set
+# CONFIG_SND_SOC_WM8903 is not set
+# CONFIG_SND_SOC_WM8960 is not set
+# CONFIG_SND_SOC_WM8962 is not set
+# CONFIG_SND_SOC_WM8974 is not set
+# CONFIG_SND_SOC_WM8978 is not set
+# CONFIG_SND_SOC_WM8985 is not set
+# CONFIG_SND_SOC_ZX_AUD96P22 is not set
+# CONFIG_SND_SOC_NAU8540 is not set
+# CONFIG_SND_SOC_NAU8810 is not set
+# CONFIG_SND_SOC_NAU8824 is not set
+# CONFIG_SND_SOC_TPA6130A2 is not set
+CONFIG_SND_SIMPLE_CARD_UTILS=y
+CONFIG_SND_SIMPLE_CARD=y
+# CONFIG_SND_SIMPLE_SCU_CARD is not set
+# CONFIG_SND_AUDIO_GRAPH_CARD is not set
+# CONFIG_SND_AUDIO_GRAPH_SCU_CARD is not set
+
+#
+# HID support
+#
+CONFIG_HID=y
+# CONFIG_HID_BATTERY_STRENGTH is not set
+# CONFIG_HIDRAW is not set
+# CONFIG_UHID is not set
+CONFIG_HID_GENERIC=y
+
+#
+# Special HID drivers
+#
+CONFIG_HID_A4TECH=y
+# CONFIG_HID_ACCUTOUCH is not set
+# CONFIG_HID_ACRUX is not set
+CONFIG_HID_APPLE=y
+# CONFIG_HID_APPLEIR is not set
+# CONFIG_HID_ASUS is not set
+# CONFIG_HID_AUREAL is not set
+CONFIG_HID_BELKIN=y
+# CONFIG_HID_BETOP_FF is not set
+CONFIG_HID_CHERRY=y
+CONFIG_HID_CHICONY=y
+# CONFIG_HID_CORSAIR is not set
+# CONFIG_HID_PRODIKEYS is not set
+# CONFIG_HID_CMEDIA is not set
+# CONFIG_HID_CP2112 is not set
+CONFIG_HID_CYPRESS=y
+# CONFIG_HID_DRAGONRISE is not set
+# CONFIG_HID_EMS_FF is not set
+# CONFIG_HID_ELECOM is not set
+# CONFIG_HID_ELO is not set
+CONFIG_HID_EZKEY=y
+# CONFIG_HID_GEMBIRD is not set
+# CONFIG_HID_GFRM is not set
+# CONFIG_HID_HOLTEK is not set
+# CONFIG_HID_GT683R is not set
+# CONFIG_HID_KEYTOUCH is not set
+# CONFIG_HID_KYE is not set
+# CONFIG_HID_UCLOGIC is not set
+# CONFIG_HID_WALTOP is not set
+# CONFIG_HID_GYRATION is not set
+# CONFIG_HID_ICADE is not set
+CONFIG_HID_ITE=y
+# CONFIG_HID_TWINHAN is not set
+CONFIG_HID_KENSINGTON=y
+# CONFIG_HID_LCPOWER is not set
+# CONFIG_HID_LED is not set
+# CONFIG_HID_LENOVO is not set
+CONFIG_HID_LOGITECH=y
+# CONFIG_HID_LOGITECH_HIDPP is not set
+# CONFIG_LOGITECH_FF is not set
+# CONFIG_LOGIRUMBLEPAD2_FF is not set
+# CONFIG_LOGIG940_FF is not set
+# CONFIG_LOGIWHEELS_FF is not set
+# CONFIG_HID_MAGICMOUSE is not set
+# CONFIG_HID_MAYFLASH is not set
+CONFIG_HID_MICROSOFT=y
+CONFIG_HID_MONTEREY=y
+# CONFIG_HID_MULTITOUCH is not set
+# CONFIG_HID_NTI is not set
+# CONFIG_HID_NTRIG is not set
+# CONFIG_HID_ORTEK is not set
+# CONFIG_HID_PANTHERLORD is not set
+# CONFIG_HID_PENMOUNT is not set
+# CONFIG_HID_PETALYNX is not set
+# CONFIG_HID_PICOLCD is not set
+# CONFIG_HID_PLANTRONICS is not set
+# CONFIG_HID_PRIMAX is not set
+# CONFIG_HID_RETRODE is not set
+# CONFIG_HID_ROCCAT is not set
+# CONFIG_HID_SAITEK is not set
+# CONFIG_HID_SAMSUNG is not set
+# CONFIG_HID_SONY is not set
+# CONFIG_HID_SPEEDLINK is not set
+# CONFIG_HID_STEELSERIES is not set
+# CONFIG_HID_SUNPLUS is not set
+# CONFIG_HID_RMI is not set
+# CONFIG_HID_GREENASIA is not set
+# CONFIG_HID_SMARTJOYPLUS is not set
+# CONFIG_HID_TIVO is not set
+# CONFIG_HID_TOPSEED is not set
+# CONFIG_HID_THINGM is not set
+# CONFIG_HID_THRUSTMASTER is not set
+# CONFIG_HID_UDRAW_PS3 is not set
+# CONFIG_HID_WACOM is not set
+# CONFIG_HID_WIIMOTE is not set
+# CONFIG_HID_XINMO is not set
+# CONFIG_HID_ZEROPLUS is not set
+# CONFIG_HID_ZYDACRON is not set
+# CONFIG_HID_SENSOR_HUB is not set
+# CONFIG_HID_ALPS is not set
+
+#
+# USB HID support
+#
+CONFIG_USB_HID=y
+# CONFIG_HID_PID is not set
+CONFIG_USB_HIDDEV=y
+
+#
+# I2C HID support
+#
+# CONFIG_I2C_HID is not set
+CONFIG_USB_OHCI_LITTLE_ENDIAN=y
+CONFIG_USB_SUPPORT=y
+CONFIG_USB_COMMON=y
+CONFIG_USB_ARCH_HAS_HCD=y
+CONFIG_USB=y
+# CONFIG_USB_ANNOUNCE_NEW_DEVICES is not set
+
+#
+# Miscellaneous USB options
+#
+CONFIG_USB_DEFAULT_PERSIST=y
+CONFIG_USB_DYNAMIC_MINORS=y
+CONFIG_USB_OTG=y
+# CONFIG_USB_OTG_WHITELIST is not set
+# CONFIG_USB_OTG_BLACKLIST_HUB is not set
+# CONFIG_USB_OTG_FSM is not set
+# CONFIG_USB_LEDS_TRIGGER_USBPORT is not set
+CONFIG_USB_MON=m
+# CONFIG_USB_WUSB_CBAF is not set
+
+#
+# USB Host Controller Drivers
+#
+# CONFIG_USB_C67X00_HCD is not set
+# CONFIG_USB_XHCI_HCD is not set
+CONFIG_USB_EHCI_HCD=y
+# CONFIG_USB_EHCI_ROOT_HUB_TT is not set
+# CONFIG_USB_EHCI_TT_NEWSCHED is not set
+CONFIG_USB_EHCI_HCD_PLATFORM=y
+# CONFIG_USB_OXU210HP_HCD is not set
+# CONFIG_USB_ISP116X_HCD is not set
+# CONFIG_USB_ISP1362_HCD is not set
+# CONFIG_USB_FOTG210_HCD is not set
+# CONFIG_USB_MAX3421_HCD is not set
+CONFIG_USB_OHCI_HCD=y
+CONFIG_USB_OHCI_HCD_PLATFORM=y
+# CONFIG_USB_SL811_HCD is not set
+# CONFIG_USB_R8A66597_HCD is not set
+# CONFIG_USB_HCD_TEST_MODE is not set
+
+#
+# USB Device Class drivers
+#
+# CONFIG_USB_ACM is not set
+# CONFIG_USB_PRINTER is not set
+# CONFIG_USB_WDM is not set
+# CONFIG_USB_TMC is not set
+
+#
+# NOTE: USB_STORAGE depends on SCSI but BLK_DEV_SD may
+#
+
+#
+# also be needed; see USB_STORAGE Help for more info
+#
+CONFIG_USB_STORAGE=y
+# CONFIG_USB_STORAGE_DEBUG is not set
+# CONFIG_USB_STORAGE_REALTEK is not set
+# CONFIG_USB_STORAGE_DATAFAB is not set
+# CONFIG_USB_STORAGE_FREECOM is not set
+# CONFIG_USB_STORAGE_ISD200 is not set
+# CONFIG_USB_STORAGE_USBAT is not set
+# CONFIG_USB_STORAGE_SDDR09 is not set
+# CONFIG_USB_STORAGE_SDDR55 is not set
+# CONFIG_USB_STORAGE_JUMPSHOT is not set
+# CONFIG_USB_STORAGE_ALAUDA is not set
+# CONFIG_USB_STORAGE_ONETOUCH is not set
+# CONFIG_USB_STORAGE_KARMA is not set
+# CONFIG_USB_STORAGE_CYPRESS_ATACB is not set
+# CONFIG_USB_STORAGE_ENE_UB6250 is not set
+# CONFIG_USB_UAS is not set
+
+#
+# USB Imaging devices
+#
+# CONFIG_USB_MDC800 is not set
+# CONFIG_USB_MICROTEK is not set
+# CONFIG_USBIP_CORE is not set
+CONFIG_USB_MUSB_HDRC=y
+CONFIG_USB_MUSB_HOST=y
+
+#
+# Platform Glue Layer
+#
+CONFIG_USB_MUSB_SUNXI=y
+
+#
+# MUSB DMA mode
+#
+# CONFIG_MUSB_PIO_ONLY is not set
+# CONFIG_USB_DWC3 is not set
+# CONFIG_USB_DWC2 is not set
+# CONFIG_USB_CHIPIDEA is not set
+# CONFIG_USB_ISP1760 is not set
+
+#
+# USB port drivers
+#
+# CONFIG_USB_SERIAL is not set
+
+#
+# USB Miscellaneous drivers
+#
+# CONFIG_USB_EMI62 is not set
+# CONFIG_USB_EMI26 is not set
+# CONFIG_USB_ADUTUX is not set
+# CONFIG_USB_SEVSEG is not set
+# CONFIG_USB_RIO500 is not set
+# CONFIG_USB_LEGOTOWER is not set
+# CONFIG_USB_LCD is not set
+# CONFIG_USB_CYPRESS_CY7C63 is not set
+# CONFIG_USB_CYTHERM is not set
+# CONFIG_USB_IDMOUSE is not set
+# CONFIG_USB_FTDI_ELAN is not set
+# CONFIG_USB_APPLEDISPLAY is not set
+# CONFIG_USB_SISUSBVGA is not set
+# CONFIG_USB_LD is not set
+# CONFIG_USB_TRANCEVIBRATOR is not set
+# CONFIG_USB_IOWARRIOR is not set
+# CONFIG_USB_TEST is not set
+# CONFIG_USB_EHSET_TEST_FIXTURE is not set
+# CONFIG_USB_ISIGHTFW is not set
+# CONFIG_USB_YUREX is not set
+# CONFIG_USB_EZUSB_FX2 is not set
+# CONFIG_USB_HUB_USB251XB is not set
+# CONFIG_USB_HSIC_USB3503 is not set
+# CONFIG_USB_HSIC_USB4604 is not set
+# CONFIG_USB_LINK_LAYER_TEST is not set
+
+#
+# USB Physical Layer drivers
+#
+CONFIG_USB_PHY=y
+CONFIG_NOP_USB_XCEIV=y
+# CONFIG_AM335X_PHY_USB is not set
+# CONFIG_USB_GPIO_VBUS is not set
+# CONFIG_USB_ISP1301 is not set
+# CONFIG_USB_ULPI is not set
+# CONFIG_USB_GADGET is not set
+
+#
+# USB Power Delivery and Type-C drivers
+#
+# CONFIG_TYPEC_UCSI is not set
+# CONFIG_USB_LED_TRIG is not set
+# CONFIG_USB_ULPI_BUS is not set
+# CONFIG_UWB is not set
+CONFIG_MMC=y
+CONFIG_PWRSEQ_EMMC=y
+CONFIG_PWRSEQ_SIMPLE=y
+CONFIG_MMC_BLOCK=y
+CONFIG_MMC_BLOCK_MINORS=8
+# CONFIG_SDIO_UART is not set
+# CONFIG_MMC_TEST is not set
+
+#
+# MMC/SD/SDIO Host Controller Drivers
+#
+# CONFIG_MMC_DEBUG is not set
+# CONFIG_MMC_SDHCI is not set
+# CONFIG_MMC_SPI is not set
+# CONFIG_MMC_DW is not set
+# CONFIG_MMC_VUB300 is not set
+# CONFIG_MMC_USHC is not set
+# CONFIG_MMC_USDHI6ROL0 is not set
+CONFIG_MMC_SUNXI=y
+# CONFIG_MMC_MTK is not set
+# CONFIG_MEMSTICK is not set
+CONFIG_NEW_LEDS=y
+CONFIG_LEDS_CLASS=y
+# CONFIG_LEDS_CLASS_FLASH is not set
+# CONFIG_LEDS_BRIGHTNESS_HW_CHANGED is not set
+
+#
+# LED drivers
+#
+# CONFIG_LEDS_BCM6328 is not set
+# CONFIG_LEDS_BCM6358 is not set
+# CONFIG_LEDS_LM3530 is not set
+# CONFIG_LEDS_LM3642 is not set
+# CONFIG_LEDS_PCA9532 is not set
+CONFIG_LEDS_GPIO=y
+# CONFIG_LEDS_LP3944 is not set
+# CONFIG_LEDS_LP3952 is not set
+# CONFIG_LEDS_LP5521 is not set
+# CONFIG_LEDS_LP5523 is not set
+# CONFIG_LEDS_LP5562 is not set
+# CONFIG_LEDS_LP8501 is not set
+# CONFIG_LEDS_LP8860 is not set
+# CONFIG_LEDS_PCA955X is not set
+# CONFIG_LEDS_PCA963X is not set
+# CONFIG_LEDS_DAC124S085 is not set
+# CONFIG_LEDS_PWM is not set
+# CONFIG_LEDS_REGULATOR is not set
+# CONFIG_LEDS_BD2802 is not set
+# CONFIG_LEDS_LT3593 is not set
+# CONFIG_LEDS_TCA6507 is not set
+# CONFIG_LEDS_TLC591XX is not set
+# CONFIG_LEDS_LM355x is not set
+# CONFIG_LEDS_IS31FL319X is not set
+# CONFIG_LEDS_IS31FL32XX is not set
+
+#
+# LED driver for blink(1) USB RGB LED is under Special HID drivers (HID_THINGM)
+#
+# CONFIG_LEDS_BLINKM is not set
+# CONFIG_LEDS_SYSCON is not set
+# CONFIG_LEDS_USER is not set
+
+#
+# LED Triggers
+#
+CONFIG_LEDS_TRIGGERS=y
+# CONFIG_LEDS_TRIGGER_TIMER is not set
+# CONFIG_LEDS_TRIGGER_ONESHOT is not set
+# CONFIG_LEDS_TRIGGER_MTD is not set
+CONFIG_LEDS_TRIGGER_HEARTBEAT=y
+# CONFIG_LEDS_TRIGGER_BACKLIGHT is not set
+# CONFIG_LEDS_TRIGGER_CPU is not set
+# CONFIG_LEDS_TRIGGER_GPIO is not set
+CONFIG_LEDS_TRIGGER_DEFAULT_ON=y
+
+#
+# iptables trigger is under Netfilter config (LED target)
+#
+# CONFIG_LEDS_TRIGGER_TRANSIENT is not set
+# CONFIG_LEDS_TRIGGER_CAMERA is not set
+# CONFIG_LEDS_TRIGGER_PANIC is not set
+# CONFIG_ACCESSIBILITY is not set
+CONFIG_EDAC_ATOMIC_SCRUB=y
+CONFIG_EDAC_SUPPORT=y
+CONFIG_RTC_LIB=y
+# CONFIG_RTC_CLASS is not set
+CONFIG_DMADEVICES=y
+# CONFIG_DMADEVICES_DEBUG is not set
+
+#
+# DMA Devices
+#
+CONFIG_DMA_ENGINE=y
+CONFIG_DMA_OF=y
+# CONFIG_ALTERA_MSGDMA is not set
+# CONFIG_FSL_EDMA is not set
+# CONFIG_INTEL_IDMA64 is not set
+# CONFIG_NBPFAXI_DMA is not set
+# CONFIG_QCOM_HIDMA_MGMT is not set
+# CONFIG_QCOM_HIDMA is not set
+# CONFIG_DW_DMAC is not set
+
+#
+# DMA Clients
+#
+# CONFIG_ASYNC_TX_DMA is not set
+# CONFIG_DMATEST is not set
+
+#
+# DMABUF options
+#
+CONFIG_SYNC_FILE=y
+# CONFIG_SW_SYNC is not set
+# CONFIG_AUXDISPLAY is not set
+# CONFIG_UIO is not set
+# CONFIG_VIRT_DRIVERS is not set
+
+#
+# Virtio drivers
+#
+# CONFIG_VIRTIO_MMIO is not set
+
+#
+# Microsoft Hyper-V guest support
+#
+# CONFIG_HYPERV_TSCPAGE is not set
+CONFIG_STAGING=y
+# CONFIG_IRDA is not set
+# CONFIG_PRISM2_USB is not set
+# CONFIG_COMEDI is not set
+# CONFIG_RTLLIB is not set
+CONFIG_RTL8723BS=m
+# CONFIG_R8712U is not set
+# CONFIG_R8188EU is not set
+# CONFIG_VT6656 is not set
+
+#
+# Speakup console speech
+#
+# CONFIG_SPEAKUP is not set
+# CONFIG_STAGING_MEDIA is not set
+
+#
+# Android
+#
+# CONFIG_STAGING_BOARD is not set
+# CONFIG_LTE_GDM724X is not set
+# CONFIG_LNET is not set
+# CONFIG_GS_FPGABOOT is not set
+# CONFIG_COMMON_CLK_XLNX_CLKWZRD is not set
+CONFIG_FB_TFT=y
+# CONFIG_FB_TFT_AGM1264K_FL is not set
+# CONFIG_FB_TFT_BD663474 is not set
+# CONFIG_FB_TFT_HX8340BN is not set
+# CONFIG_FB_TFT_HX8347D is not set
+# CONFIG_FB_TFT_HX8353D is not set
+# CONFIG_FB_TFT_HX8357D is not set
+# CONFIG_FB_TFT_ILI9163 is not set
+# CONFIG_FB_TFT_ILI9320 is not set
+# CONFIG_FB_TFT_ILI9325 is not set
+# CONFIG_FB_TFT_ILI9340 is not set
+# CONFIG_FB_TFT_ILI9341 is not set
+# CONFIG_FB_TFT_ILI9481 is not set
+# CONFIG_FB_TFT_ILI9486 is not set
+# CONFIG_FB_TFT_PCD8544 is not set
+# CONFIG_FB_TFT_RA8875 is not set
+# CONFIG_FB_TFT_S6D02A1 is not set
+# CONFIG_FB_TFT_S6D1121 is not set
+# CONFIG_FB_TFT_SH1106 is not set
+# CONFIG_FB_TFT_SSD1289 is not set
+# CONFIG_FB_TFT_SSD1305 is not set
+# CONFIG_FB_TFT_SSD1306 is not set
+# CONFIG_FB_TFT_SSD1325 is not set
+# CONFIG_FB_TFT_SSD1331 is not set
+# CONFIG_FB_TFT_SSD1351 is not set
+# CONFIG_FB_TFT_ST7735R is not set
+# CONFIG_FB_TFT_ST7789V is not set
+# CONFIG_FB_TFT_TINYLCD is not set
+# CONFIG_FB_TFT_TLS8204 is not set
+# CONFIG_FB_TFT_UC1611 is not set
+# CONFIG_FB_TFT_UC1701 is not set
+# CONFIG_FB_TFT_UPD161704 is not set
+# CONFIG_FB_TFT_WATTEROTT is not set
+CONFIG_FB_FLEX=y
+# CONFIG_FB_TFT_FBTFT_DEVICE is not set
+# CONFIG_WILC1000_SDIO is not set
+# CONFIG_WILC1000_SPI is not set
+# CONFIG_MOST is not set
+# CONFIG_KS7010 is not set
+# CONFIG_GREYBUS is not set
+# CONFIG_CRYPTO_DEV_CCREE is not set
+
+#
+# USB Power Delivery and Type-C drivers
+#
+# CONFIG_TYPEC_TCPM is not set
+# CONFIG_PI433 is not set
+# CONFIG_GOLDFISH is not set
+# CONFIG_CHROME_PLATFORMS is not set
+CONFIG_CLKDEV_LOOKUP=y
+CONFIG_HAVE_CLK_PREPARE=y
+CONFIG_COMMON_CLK=y
+
+#
+# Common Clock Framework
+#
+# CONFIG_CLK_HSDK is not set
+# CONFIG_COMMON_CLK_SI5351 is not set
+# CONFIG_COMMON_CLK_SI514 is not set
+# CONFIG_COMMON_CLK_SI570 is not set
+# CONFIG_COMMON_CLK_CDCE706 is not set
+# CONFIG_COMMON_CLK_CDCE925 is not set
+# CONFIG_COMMON_CLK_CS2000_CP is not set
+# CONFIG_CLK_QORIQ is not set
+# CONFIG_COMMON_CLK_NXP is not set
+# CONFIG_COMMON_CLK_PWM is not set
+# CONFIG_COMMON_CLK_PXA is not set
+# CONFIG_COMMON_CLK_PIC32 is not set
+# CONFIG_COMMON_CLK_VC5 is not set
+CONFIG_SUNXI_CCU=y
+CONFIG_SUNIV_CCU=y
+CONFIG_SUN8I_A83T_CCU=y
+CONFIG_SUN8I_DE2_CCU=y
+CONFIG_SUN8I_R_CCU=y
+# CONFIG_HWSPINLOCK is not set
+
+#
+# Clock Source drivers
+#
+CONFIG_TIMER_OF=y
+CONFIG_TIMER_PROBE=y
+CONFIG_CLKSRC_MMIO=y
+CONFIG_SUN4I_TIMER=y
+# CONFIG_ARM_TIMER_SP804 is not set
+# CONFIG_ATMEL_PIT is not set
+# CONFIG_SH_TIMER_CMT is not set
+# CONFIG_SH_TIMER_MTU2 is not set
+# CONFIG_SH_TIMER_TMU is not set
+# CONFIG_EM_TIMER_STI is not set
+# CONFIG_MAILBOX is not set
+# CONFIG_IOMMU_SUPPORT is not set
+
+#
+# Remoteproc drivers
+#
+# CONFIG_REMOTEPROC is not set
+
+#
+# Rpmsg drivers
+#
+
+#
+# SOC (System On Chip) specific Drivers
+#
+
+#
+# Amlogic SoC drivers
+#
+
+#
+# Broadcom SoC drivers
+#
+# CONFIG_SOC_BRCMSTB is not set
+
+#
+# i.MX SoC drivers
+#
+
+#
+# Qualcomm SoC drivers
+#
+CONFIG_SUNXI_SRAM=y
+# CONFIG_SOC_TI is not set
+# CONFIG_PM_DEVFREQ is not set
+CONFIG_EXTCON=y
+
+#
+# Extcon Device Drivers
+#
+# CONFIG_EXTCON_AXP288 is not set
+# CONFIG_EXTCON_GPIO is not set
+# CONFIG_EXTCON_MAX3355 is not set
+# CONFIG_EXTCON_RT8973A is not set
+# CONFIG_EXTCON_SM5502 is not set
+# CONFIG_EXTCON_USB_GPIO is not set
+# CONFIG_MEMORY is not set
+# CONFIG_IIO is not set
+CONFIG_PWM=y
+CONFIG_PWM_SYSFS=y
+# CONFIG_PWM_FSL_FTM is not set
+# CONFIG_PWM_PCA9685 is not set
+CONFIG_PWM_SUN4I=y
+CONFIG_IRQCHIP=y
+CONFIG_ARM_GIC_MAX_NR=1
+# CONFIG_IPACK_BUS is not set
+CONFIG_ARCH_HAS_RESET_CONTROLLER=y
+CONFIG_RESET_CONTROLLER=y
+# CONFIG_RESET_ATH79 is not set
+# CONFIG_RESET_BERLIN is not set
+# CONFIG_RESET_IMX7 is not set
+# CONFIG_RESET_LANTIQ is not set
+# CONFIG_RESET_LPC18XX is not set
+# CONFIG_RESET_MESON is not set
+# CONFIG_RESET_PISTACHIO is not set
+# CONFIG_RESET_SOCFPGA is not set
+# CONFIG_RESET_STM32 is not set
+CONFIG_RESET_SUNXI=y
+# CONFIG_RESET_TI_SYSCON is not set
+# CONFIG_RESET_ZYNQ is not set
+# CONFIG_RESET_TEGRA_BPMP is not set
+# CONFIG_FMC is not set
+
+#
+# PHY Subsystem
+#
+CONFIG_GENERIC_PHY=y
+CONFIG_PHY_SUN4I_USB=y
+# CONFIG_PHY_SUN9I_USB is not set
+# CONFIG_BCM_KONA_USB2_PHY is not set
+# CONFIG_PHY_PXA_28NM_HSIC is not set
+# CONFIG_PHY_PXA_28NM_USB2 is not set
+# CONFIG_POWERCAP is not set
+# CONFIG_MCB is not set
+
+#
+# Performance monitor support
+#
+CONFIG_ARM_PMU=y
+# CONFIG_RAS is not set
+
+#
+# Android
+#
+# CONFIG_ANDROID is not set
+# CONFIG_DAX is not set
+CONFIG_NVMEM=y
+CONFIG_NVMEM_SUNXI_SID=y
+# CONFIG_STM is not set
+# CONFIG_INTEL_TH is not set
+# CONFIG_FPGA is not set
+
+#
+# FSI support
+#
+# CONFIG_FSI is not set
+
+#
+# Firmware Drivers
+#
+# CONFIG_FIRMWARE_MEMMAP is not set
+# CONFIG_FW_CFG_SYSFS is not set
+# CONFIG_GOOGLE_FIRMWARE is not set
+
+#
+# Tegra firmware driver
+#
+
+#
+# File systems
+#
+CONFIG_EXT2_FS=y
+# CONFIG_EXT2_FS_XATTR is not set
+CONFIG_EXT3_FS=y
+# CONFIG_EXT3_FS_POSIX_ACL is not set
+# CONFIG_EXT3_FS_SECURITY is not set
+CONFIG_EXT4_FS=y
+# CONFIG_EXT4_FS_POSIX_ACL is not set
+# CONFIG_EXT4_FS_SECURITY is not set
+# CONFIG_EXT4_ENCRYPTION is not set
+# CONFIG_EXT4_DEBUG is not set
+CONFIG_JBD2=y
+# CONFIG_JBD2_DEBUG is not set
+CONFIG_FS_MBCACHE=y
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_XFS_FS is not set
+# CONFIG_GFS2_FS is not set
+# CONFIG_OCFS2_FS is not set
+# CONFIG_BTRFS_FS is not set
+# CONFIG_NILFS2_FS is not set
+# CONFIG_F2FS_FS is not set
+CONFIG_FS_POSIX_ACL=y
+CONFIG_EXPORTFS=y
+# CONFIG_EXPORTFS_BLOCK_OPS is not set
+CONFIG_FILE_LOCKING=y
+CONFIG_MANDATORY_FILE_LOCKING=y
+# CONFIG_FS_ENCRYPTION is not set
+CONFIG_FSNOTIFY=y
+CONFIG_DNOTIFY=y
+CONFIG_INOTIFY_USER=y
+# CONFIG_FANOTIFY is not set
+# CONFIG_QUOTA is not set
+# CONFIG_QUOTACTL is not set
+# CONFIG_AUTOFS4_FS is not set
+# CONFIG_FUSE_FS is not set
+# CONFIG_OVERLAY_FS is not set
+
+#
+# Caches
+#
+# CONFIG_FSCACHE is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+CONFIG_FAT_FS=y
+# CONFIG_MSDOS_FS is not set
+CONFIG_VFAT_FS=y
+CONFIG_FAT_DEFAULT_CODEPAGE=437
+CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
+# CONFIG_FAT_DEFAULT_UTF8 is not set
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_SYSCTL=y
+CONFIG_PROC_PAGE_MONITOR=y
+# CONFIG_PROC_CHILDREN is not set
+CONFIG_KERNFS=y
+CONFIG_SYSFS=y
+CONFIG_TMPFS=y
+# CONFIG_TMPFS_POSIX_ACL is not set
+# CONFIG_TMPFS_XATTR is not set
+# CONFIG_HUGETLB_PAGE is not set
+CONFIG_CONFIGFS_FS=y
+CONFIG_MISC_FILESYSTEMS=y
+# CONFIG_ORANGEFS_FS is not set
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_ECRYPT_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+# CONFIG_JFFS2_FS is not set
+# CONFIG_CRAMFS is not set
+# CONFIG_SQUASHFS is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_OMFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_QNX6FS_FS is not set
+# CONFIG_ROMFS_FS is not set
+# CONFIG_PSTORE is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+CONFIG_NETWORK_FILESYSTEMS=y
+CONFIG_NFS_FS=y
+CONFIG_NFS_V2=y
+CONFIG_NFS_V3=y
+CONFIG_NFS_V3_ACL=y
+CONFIG_NFS_V4=y
+# CONFIG_NFS_SWAP is not set
+# CONFIG_NFS_V4_1 is not set
+CONFIG_ROOT_NFS=y
+# CONFIG_NFS_USE_LEGACY_DNS is not set
+CONFIG_NFS_USE_KERNEL_DNS=y
+# CONFIG_NFSD is not set
+CONFIG_GRACE_PERIOD=y
+CONFIG_LOCKD=y
+CONFIG_LOCKD_V4=y
+CONFIG_NFS_ACL_SUPPORT=y
+CONFIG_NFS_COMMON=y
+CONFIG_SUNRPC=y
+CONFIG_SUNRPC_GSS=y
+# CONFIG_SUNRPC_DEBUG is not set
+# CONFIG_CEPH_FS is not set
+# CONFIG_CIFS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="iso8859-1"
+CONFIG_NLS_CODEPAGE_437=y
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+# CONFIG_NLS_CODEPAGE_850 is not set
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+# CONFIG_NLS_CODEPAGE_936 is not set
+# CONFIG_NLS_CODEPAGE_950 is not set
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+# CONFIG_NLS_ASCII is not set
+CONFIG_NLS_ISO8859_1=y
+# CONFIG_NLS_ISO8859_2 is not set
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+# CONFIG_NLS_ISO8859_15 is not set
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+# CONFIG_NLS_MAC_ROMAN is not set
+# CONFIG_NLS_MAC_CELTIC is not set
+# CONFIG_NLS_MAC_CENTEURO is not set
+# CONFIG_NLS_MAC_CROATIAN is not set
+# CONFIG_NLS_MAC_CYRILLIC is not set
+# CONFIG_NLS_MAC_GAELIC is not set
+# CONFIG_NLS_MAC_GREEK is not set
+# CONFIG_NLS_MAC_ICELAND is not set
+# CONFIG_NLS_MAC_INUIT is not set
+# CONFIG_NLS_MAC_ROMANIAN is not set
+# CONFIG_NLS_MAC_TURKISH is not set
+# CONFIG_NLS_UTF8 is not set
+# CONFIG_DLM is not set
+
+#
+# Kernel hacking
+#
+
+#
+# printk and dmesg options
+#
+CONFIG_PRINTK_TIME=y
+CONFIG_CONSOLE_LOGLEVEL_DEFAULT=7
+CONFIG_MESSAGE_LOGLEVEL_DEFAULT=4
+# CONFIG_BOOT_PRINTK_DELAY is not set
+# CONFIG_DYNAMIC_DEBUG is not set
+
+#
+# Compile-time checks and compiler options
+#
+# CONFIG_DEBUG_INFO is not set
+CONFIG_ENABLE_WARN_DEPRECATED=y
+CONFIG_ENABLE_MUST_CHECK=y
+CONFIG_FRAME_WARN=1024
+# CONFIG_STRIP_ASM_SYMS is not set
+# CONFIG_READABLE_ASM is not set
+# CONFIG_UNUSED_SYMBOLS is not set
+# CONFIG_PAGE_OWNER is not set
+CONFIG_DEBUG_FS=y
+# CONFIG_HEADERS_CHECK is not set
+# CONFIG_DEBUG_SECTION_MISMATCH is not set
+CONFIG_SECTION_MISMATCH_WARN_ONLY=y
+# CONFIG_DEBUG_FORCE_WEAK_PER_CPU is not set
+# CONFIG_MAGIC_SYSRQ is not set
+CONFIG_DEBUG_KERNEL=y
+
+#
+# Memory Debugging
+#
+# CONFIG_PAGE_EXTENSION is not set
+# CONFIG_DEBUG_PAGEALLOC is not set
+# CONFIG_PAGE_POISONING is not set
+# CONFIG_DEBUG_RODATA_TEST is not set
+# CONFIG_DEBUG_OBJECTS is not set
+# CONFIG_SLUB_DEBUG_ON is not set
+# CONFIG_SLUB_STATS is not set
+CONFIG_HAVE_DEBUG_KMEMLEAK=y
+# CONFIG_DEBUG_KMEMLEAK is not set
+# CONFIG_DEBUG_STACK_USAGE is not set
+# CONFIG_DEBUG_VM is not set
+CONFIG_ARCH_HAS_DEBUG_VIRTUAL=y
+# CONFIG_DEBUG_VIRTUAL is not set
+CONFIG_DEBUG_MEMORY_INIT=y
+# CONFIG_DEBUG_HIGHMEM is not set
+# CONFIG_DEBUG_SHIRQ is not set
+
+#
+# Debug Lockups and Hangs
+#
+# CONFIG_SOFTLOCKUP_DETECTOR is not set
+# CONFIG_DETECT_HUNG_TASK is not set
+# CONFIG_WQ_WATCHDOG is not set
+# CONFIG_PANIC_ON_OOPS is not set
+CONFIG_PANIC_ON_OOPS_VALUE=0
+CONFIG_PANIC_TIMEOUT=0
+CONFIG_SCHED_DEBUG=y
+# CONFIG_SCHED_INFO is not set
+# CONFIG_SCHEDSTATS is not set
+# CONFIG_SCHED_STACK_END_CHECK is not set
+# CONFIG_DEBUG_TIMEKEEPING is not set
+
+#
+# Lock Debugging (spinlocks, mutexes, etc...)
+#
+# CONFIG_DEBUG_RT_MUTEXES is not set
+# CONFIG_DEBUG_SPINLOCK is not set
+# CONFIG_DEBUG_MUTEXES is not set
+# CONFIG_DEBUG_WW_MUTEX_SLOWPATH is not set
+# CONFIG_DEBUG_LOCK_ALLOC is not set
+# CONFIG_PROVE_LOCKING is not set
+# CONFIG_LOCK_STAT is not set
+# CONFIG_DEBUG_ATOMIC_SLEEP is not set
+# CONFIG_DEBUG_LOCKING_API_SELFTESTS is not set
+# CONFIG_LOCK_TORTURE_TEST is not set
+# CONFIG_WW_MUTEX_SELFTEST is not set
+CONFIG_STACKTRACE=y
+# CONFIG_WARN_ALL_UNSEEDED_RANDOM is not set
+# CONFIG_DEBUG_KOBJECT is not set
+CONFIG_DEBUG_BUGVERBOSE=y
+# CONFIG_DEBUG_LIST is not set
+# CONFIG_DEBUG_PI_LIST is not set
+# CONFIG_DEBUG_SG is not set
+# CONFIG_DEBUG_NOTIFIERS is not set
+# CONFIG_DEBUG_CREDENTIALS is not set
+
+#
+# RCU Debugging
+#
+# CONFIG_PROVE_RCU is not set
+# CONFIG_TORTURE_TEST is not set
+# CONFIG_RCU_PERF_TEST is not set
+# CONFIG_RCU_TORTURE_TEST is not set
+CONFIG_RCU_TRACE=y
+# CONFIG_RCU_EQS_DEBUG is not set
+# CONFIG_DEBUG_WQ_FORCE_RR_CPU is not set
+# CONFIG_DEBUG_BLOCK_EXT_DEVT is not set
+# CONFIG_NOTIFIER_ERROR_INJECTION is not set
+# CONFIG_FAULT_INJECTION is not set
+# CONFIG_LATENCYTOP is not set
+CONFIG_HAVE_FUNCTION_TRACER=y
+CONFIG_HAVE_FUNCTION_GRAPH_TRACER=y
+CONFIG_HAVE_DYNAMIC_FTRACE=y
+CONFIG_HAVE_DYNAMIC_FTRACE_WITH_REGS=y
+CONFIG_HAVE_FTRACE_MCOUNT_RECORD=y
+CONFIG_HAVE_SYSCALL_TRACEPOINTS=y
+CONFIG_HAVE_C_RECORDMCOUNT=y
+CONFIG_TRACE_CLOCK=y
+CONFIG_TRACING_SUPPORT=y
+# CONFIG_FTRACE is not set
+# CONFIG_DMA_API_DEBUG is not set
+
+#
+# Runtime Testing
+#
+# CONFIG_LKDTM is not set
+# CONFIG_TEST_LIST_SORT is not set
+# CONFIG_TEST_SORT is not set
+# CONFIG_BACKTRACE_SELF_TEST is not set
+# CONFIG_RBTREE_TEST is not set
+# CONFIG_INTERVAL_TREE_TEST is not set
+# CONFIG_PERCPU_TEST is not set
+# CONFIG_ATOMIC64_SELFTEST is not set
+# CONFIG_TEST_HEXDUMP is not set
+# CONFIG_TEST_STRING_HELPERS is not set
+# CONFIG_TEST_KSTRTOX is not set
+# CONFIG_TEST_PRINTF is not set
+# CONFIG_TEST_BITMAP is not set
+# CONFIG_TEST_UUID is not set
+# CONFIG_TEST_RHASHTABLE is not set
+# CONFIG_TEST_HASH is not set
+# CONFIG_TEST_LKM is not set
+# CONFIG_TEST_USER_COPY is not set
+# CONFIG_TEST_BPF is not set
+# CONFIG_TEST_FIRMWARE is not set
+# CONFIG_TEST_SYSCTL is not set
+# CONFIG_TEST_UDELAY is not set
+# CONFIG_TEST_STATIC_KEYS is not set
+# CONFIG_TEST_KMOD is not set
+# CONFIG_MEMTEST is not set
+# CONFIG_BUG_ON_DATA_CORRUPTION is not set
+# CONFIG_SAMPLES is not set
+CONFIG_HAVE_ARCH_KGDB=y
+# CONFIG_KGDB is not set
+# CONFIG_ARCH_WANTS_UBSAN_NO_NULL is not set
+# CONFIG_UBSAN is not set
+CONFIG_ARCH_HAS_DEVMEM_IS_ALLOWED=y
+# CONFIG_STRICT_DEVMEM is not set
+# CONFIG_ARM_PTDUMP is not set
+CONFIG_ARM_UNWIND=y
+# CONFIG_DEBUG_USER is not set
+# CONFIG_DEBUG_LL is not set
+CONFIG_DEBUG_LL_INCLUDE="mach/debug-macro.S"
+# CONFIG_DEBUG_UART_8250 is not set
+CONFIG_UNCOMPRESS_INCLUDE="debug/uncompress.h"
+# CONFIG_CORESIGHT is not set
+
+#
+# Security options
+#
+CONFIG_KEYS=y
+# CONFIG_PERSISTENT_KEYRINGS is not set
+# CONFIG_BIG_KEYS is not set
+# CONFIG_ENCRYPTED_KEYS is not set
+# CONFIG_KEY_DH_OPERATIONS is not set
+# CONFIG_SECURITY_DMESG_RESTRICT is not set
+# CONFIG_SECURITY is not set
+# CONFIG_SECURITYFS is not set
+CONFIG_HAVE_HARDENED_USERCOPY_ALLOCATOR=y
+# CONFIG_HARDENED_USERCOPY is not set
+# CONFIG_STATIC_USERMODEHELPER is not set
+CONFIG_DEFAULT_SECURITY_DAC=y
+CONFIG_DEFAULT_SECURITY=""
+CONFIG_CRYPTO=y
+
+#
+# Crypto core or helper
+#
+CONFIG_CRYPTO_ALGAPI=y
+CONFIG_CRYPTO_ALGAPI2=y
+CONFIG_CRYPTO_AEAD=y
+CONFIG_CRYPTO_AEAD2=y
+CONFIG_CRYPTO_BLKCIPHER=y
+CONFIG_CRYPTO_BLKCIPHER2=y
+CONFIG_CRYPTO_HASH=y
+CONFIG_CRYPTO_HASH2=y
+CONFIG_CRYPTO_RNG=y
+CONFIG_CRYPTO_RNG2=y
+CONFIG_CRYPTO_RNG_DEFAULT=y
+CONFIG_CRYPTO_AKCIPHER2=y
+CONFIG_CRYPTO_AKCIPHER=y
+CONFIG_CRYPTO_KPP2=y
+CONFIG_CRYPTO_ACOMP2=y
+CONFIG_CRYPTO_RSA=y
+# CONFIG_CRYPTO_DH is not set
+# CONFIG_CRYPTO_ECDH is not set
+CONFIG_CRYPTO_MANAGER=y
+CONFIG_CRYPTO_MANAGER2=y
+# CONFIG_CRYPTO_USER is not set
+CONFIG_CRYPTO_MANAGER_DISABLE_TESTS=y
+CONFIG_CRYPTO_GF128MUL=y
+CONFIG_CRYPTO_NULL=y
+CONFIG_CRYPTO_NULL2=y
+CONFIG_CRYPTO_WORKQUEUE=y
+# CONFIG_CRYPTO_CRYPTD is not set
+# CONFIG_CRYPTO_MCRYPTD is not set
+# CONFIG_CRYPTO_AUTHENC is not set
+# CONFIG_CRYPTO_TEST is not set
+
+#
+# Authenticated Encryption with Associated Data
+#
+CONFIG_CRYPTO_CCM=y
+CONFIG_CRYPTO_GCM=y
+# CONFIG_CRYPTO_CHACHA20POLY1305 is not set
+CONFIG_CRYPTO_SEQIV=y
+CONFIG_CRYPTO_ECHAINIV=m
+
+#
+# Block modes
+#
+# CONFIG_CRYPTO_CBC is not set
+CONFIG_CRYPTO_CTR=y
+# CONFIG_CRYPTO_CTS is not set
+# CONFIG_CRYPTO_ECB is not set
+# CONFIG_CRYPTO_LRW is not set
+# CONFIG_CRYPTO_PCBC is not set
+# CONFIG_CRYPTO_XTS is not set
+# CONFIG_CRYPTO_KEYWRAP is not set
+
+#
+# Hash modes
+#
+CONFIG_CRYPTO_CMAC=y
+CONFIG_CRYPTO_HMAC=y
+# CONFIG_CRYPTO_XCBC is not set
+# CONFIG_CRYPTO_VMAC is not set
+
+#
+# Digest
+#
+CONFIG_CRYPTO_CRC32C=y
+# CONFIG_CRYPTO_CRC32 is not set
+# CONFIG_CRYPTO_CRCT10DIF is not set
+CONFIG_CRYPTO_GHASH=y
+# CONFIG_CRYPTO_POLY1305 is not set
+# CONFIG_CRYPTO_MD4 is not set
+CONFIG_CRYPTO_MD5=y
+# CONFIG_CRYPTO_MICHAEL_MIC is not set
+# CONFIG_CRYPTO_RMD128 is not set
+# CONFIG_CRYPTO_RMD160 is not set
+# CONFIG_CRYPTO_RMD256 is not set
+# CONFIG_CRYPTO_RMD320 is not set
+CONFIG_CRYPTO_SHA1=y
+CONFIG_CRYPTO_SHA256=y
+# CONFIG_CRYPTO_SHA512 is not set
+# CONFIG_CRYPTO_SHA3 is not set
+# CONFIG_CRYPTO_TGR192 is not set
+# CONFIG_CRYPTO_WP512 is not set
+
+#
+# Ciphers
+#
+CONFIG_CRYPTO_AES=y
+# CONFIG_CRYPTO_AES_TI is not set
+# CONFIG_CRYPTO_ANUBIS is not set
+CONFIG_CRYPTO_ARC4=y
+# CONFIG_CRYPTO_BLOWFISH is not set
+# CONFIG_CRYPTO_CAMELLIA is not set
+# CONFIG_CRYPTO_CAST5 is not set
+# CONFIG_CRYPTO_CAST6 is not set
+CONFIG_CRYPTO_DES=y
+# CONFIG_CRYPTO_FCRYPT is not set
+# CONFIG_CRYPTO_KHAZAD is not set
+# CONFIG_CRYPTO_SALSA20 is not set
+# CONFIG_CRYPTO_CHACHA20 is not set
+# CONFIG_CRYPTO_SEED is not set
+# CONFIG_CRYPTO_SERPENT is not set
+# CONFIG_CRYPTO_TEA is not set
+# CONFIG_CRYPTO_TWOFISH is not set
+
+#
+# Compression
+#
+# CONFIG_CRYPTO_DEFLATE is not set
+# CONFIG_CRYPTO_LZO is not set
+# CONFIG_CRYPTO_842 is not set
+# CONFIG_CRYPTO_LZ4 is not set
+# CONFIG_CRYPTO_LZ4HC is not set
+
+#
+# Random Number Generation
+#
+# CONFIG_CRYPTO_ANSI_CPRNG is not set
+CONFIG_CRYPTO_DRBG_MENU=y
+CONFIG_CRYPTO_DRBG_HMAC=y
+# CONFIG_CRYPTO_DRBG_HASH is not set
+# CONFIG_CRYPTO_DRBG_CTR is not set
+CONFIG_CRYPTO_DRBG=y
+CONFIG_CRYPTO_JITTERENTROPY=y
+# CONFIG_CRYPTO_USER_API_HASH is not set
+# CONFIG_CRYPTO_USER_API_SKCIPHER is not set
+# CONFIG_CRYPTO_USER_API_RNG is not set
+# CONFIG_CRYPTO_USER_API_AEAD is not set
+CONFIG_CRYPTO_HASH_INFO=y
+CONFIG_CRYPTO_HW=y
+# CONFIG_CRYPTO_DEV_FSL_CAAM_CRYPTO_API_DESC is not set
+CONFIG_CRYPTO_DEV_SUN4I_SS=y
+# CONFIG_CRYPTO_DEV_SUN4I_SS_PRNG is not set
+CONFIG_ASYMMETRIC_KEY_TYPE=y
+CONFIG_ASYMMETRIC_PUBLIC_KEY_SUBTYPE=y
+CONFIG_X509_CERTIFICATE_PARSER=y
+CONFIG_PKCS7_MESSAGE_PARSER=y
+
+#
+# Certificates for signature checking
+#
+CONFIG_SYSTEM_TRUSTED_KEYRING=y
+CONFIG_SYSTEM_TRUSTED_KEYS=""
+# CONFIG_SYSTEM_EXTRA_CERTIFICATE is not set
+# CONFIG_SECONDARY_TRUSTED_KEYRING is not set
+# CONFIG_SYSTEM_BLACKLIST_KEYRING is not set
+# CONFIG_ARM_CRYPTO is not set
+# CONFIG_BINARY_PRINTF is not set
+
+#
+# Library routines
+#
+CONFIG_BITREVERSE=y
+# CONFIG_HAVE_ARCH_BITREVERSE is not set
+CONFIG_RATIONAL=y
+CONFIG_GENERIC_STRNCPY_FROM_USER=y
+CONFIG_GENERIC_STRNLEN_USER=y
+CONFIG_GENERIC_NET_UTILS=y
+CONFIG_GENERIC_PCI_IOMAP=y
+CONFIG_GENERIC_IO=y
+CONFIG_ARCH_USE_CMPXCHG_LOCKREF=y
+# CONFIG_CRC_CCITT is not set
+CONFIG_CRC16=y
+# CONFIG_CRC_T10DIF is not set
+# CONFIG_CRC_ITU_T is not set
+CONFIG_CRC32=y
+# CONFIG_CRC32_SELFTEST is not set
+CONFIG_CRC32_SLICEBY8=y
+# CONFIG_CRC32_SLICEBY4 is not set
+# CONFIG_CRC32_SARWATE is not set
+# CONFIG_CRC32_BIT is not set
+# CONFIG_CRC4 is not set
+# CONFIG_CRC7 is not set
+# CONFIG_LIBCRC32C is not set
+# CONFIG_CRC8 is not set
+# CONFIG_AUDIT_ARCH_COMPAT_GENERIC is not set
+# CONFIG_RANDOM32_SELFTEST is not set
+CONFIG_ZLIB_INFLATE=y
+CONFIG_LZO_DECOMPRESS=y
+CONFIG_LZ4_DECOMPRESS=y
+CONFIG_XZ_DEC=y
+CONFIG_XZ_DEC_X86=y
+CONFIG_XZ_DEC_POWERPC=y
+CONFIG_XZ_DEC_IA64=y
+CONFIG_XZ_DEC_ARM=y
+CONFIG_XZ_DEC_ARMTHUMB=y
+CONFIG_XZ_DEC_SPARC=y
+CONFIG_XZ_DEC_BCJ=y
+# CONFIG_XZ_DEC_TEST is not set
+CONFIG_DECOMPRESS_GZIP=y
+CONFIG_DECOMPRESS_BZIP2=y
+CONFIG_DECOMPRESS_LZMA=y
+CONFIG_DECOMPRESS_XZ=y
+CONFIG_DECOMPRESS_LZO=y
+CONFIG_DECOMPRESS_LZ4=y
+CONFIG_GENERIC_ALLOCATOR=y
+CONFIG_ASSOCIATIVE_ARRAY=y
+CONFIG_HAS_IOMEM=y
+CONFIG_HAS_IOPORT_MAP=y
+CONFIG_HAS_DMA=y
+# CONFIG_DMA_NOOP_OPS is not set
+# CONFIG_DMA_VIRT_OPS is not set
+CONFIG_DQL=y
+CONFIG_NLATTR=y
+CONFIG_GENERIC_ATOMIC64=y
+CONFIG_CLZ_TAB=y
+# CONFIG_CORDIC is not set
+# CONFIG_DDR is not set
+# CONFIG_IRQ_POLL is not set
+CONFIG_MPILIB=y
+CONFIG_LIBFDT=y
+CONFIG_OID_REGISTRY=y
+CONFIG_FONT_SUPPORT=y
+# CONFIG_FONTS is not set
+CONFIG_FONT_8x8=y
+CONFIG_FONT_8x16=y
+# CONFIG_SG_SPLIT is not set
+CONFIG_SG_POOL=y
+CONFIG_ARCH_HAS_SG_CHAIN=y
+CONFIG_SBITMAP=y
+# CONFIG_STRING_SELFTEST is not set
+# CONFIG_VIRTUALIZATION is not set
diff --git a/arch/arm/configs/miyoo_defconfig b/arch/arm/configs/miyoo_defconfig
new file mode 100644
index 00000000..40736ec8
--- /dev/null
+++ b/arch/arm/configs/miyoo_defconfig
@@ -0,0 +1,139 @@
+CONFIG_LOCALVERSION="-miyoo"
+# CONFIG_LOCALVERSION_AUTO is not set
+CONFIG_DEFAULT_HOSTNAME="miyoo"
+CONFIG_CGROUPS=y
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_PERF_EVENTS=y
+CONFIG_STRICT_KERNEL_RWX=y
+CONFIG_STRICT_MODULE_RWX=y
+CONFIG_MODULES=y
+CONFIG_MODULE_UNLOAD=y
+CONFIG_MODULE_FORCE_UNLOAD=y
+CONFIG_DEFAULT_DEADLINE=y
+# CONFIG_ARCH_MULTI_V7 is not set
+CONFIG_ARCH_SUNXI_V5=y
+# CONFIG_DEBUG_ALIGN_RODATA is not set
+CONFIG_AEABI=y
+CONFIG_OABI_COMPAT=y
+CONFIG_HIGHMEM=y
+CONFIG_ARM_APPENDED_DTB=y
+CONFIG_ARM_ATAG_DTB_COMPAT=y
+CONFIG_CPU_FREQ=y
+CONFIG_CPUFREQ_DT=y
+CONFIG_CPU_IDLE=y
+CONFIG_CPU_IDLE_GOV_MENU=y
+CONFIG_ARM_CPUIDLE=y
+CONFIG_FPE_FASTFPE=y
+CONFIG_DEVTMPFS=y
+CONFIG_DEVTMPFS_MOUNT=y
+CONFIG_SUNXI_RSB=y
+CONFIG_MTD=y
+CONFIG_MTD_SPI_NOR=y
+CONFIG_BLK_DEV_LOOP=y
+CONFIG_SCSI=y
+CONFIG_BLK_DEV_SD=y
+CONFIG_CHR_DEV_SG=y
+CONFIG_CHR_DEV_SCH=y
+CONFIG_INPUT_MOUSEDEV=y
+CONFIG_INPUT_MOUSEDEV_SCREEN_X=320
+CONFIG_INPUT_MOUSEDEV_SCREEN_Y=240
+CONFIG_INPUT_JOYDEV=y
+CONFIG_INPUT_EVDEV=y
+CONFIG_KEYBOARD_MIYOO=y
+CONFIG_MOUSE_SYNAPTICS_USB=y
+CONFIG_INPUT_JOYSTICK=y
+CONFIG_JOYSTICK_ANALOG=y
+CONFIG_JOYSTICK_XPAD=y
+CONFIG_JOYSTICK_XPAD_FF=y
+CONFIG_INPUT_MISC=y
+CONFIG_INPUT_UINPUT=y
+CONFIG_SERIAL_8250=y
+CONFIG_SERIAL_8250_CONSOLE=y
+CONFIG_SERIAL_8250_NR_UARTS=8
+CONFIG_SERIAL_8250_RUNTIME_UARTS=8
+CONFIG_SERIAL_8250_DW=y
+CONFIG_SERIAL_OF_PLATFORM=y
+# CONFIG_HW_RANDOM is not set
+CONFIG_POWER_SUPPLY=y
+CONFIG_BATTERY_MIYOO=y
+# CONFIG_HWMON is not set
+CONFIG_WATCHDOG=y
+CONFIG_SUNXI_WATCHDOG=y
+CONFIG_MFD_AXP20X_RSB=y
+CONFIG_MFD_SUN6I_PRCM=y
+CONFIG_MFD_SYSCON=y
+CONFIG_REGULATOR=y
+CONFIG_REGULATOR_FIXED_VOLTAGE=y
+# CONFIG_RC_CORE is not set
+CONFIG_FB=y
+CONFIG_FB_R61520=m
+CONFIG_FB_GC9306=m
+CONFIG_FB_ST7789S=m
+CONFIG_FB_ST7789S_TE=m
+CONFIG_FB_RM68090=m
+CONFIG_FB_HX8347D=m
+CONFIG_FB_TVOUT=m
+CONFIG_BACKLIGHT_LCD_SUPPORT=y
+# CONFIG_LCD_CLASS_DEVICE is not set
+CONFIG_BACKLIGHT_CLASS_DEVICE=y
+# CONFIG_BACKLIGHT_GENERIC is not set
+CONFIG_BACKLIGHT_PWM=y
+CONFIG_FRAMEBUFFER_CONSOLE=y
+CONFIG_FRAMEBUFFER_CONSOLE_DETECT_PRIMARY=y
+CONFIG_SOUND=y
+CONFIG_SND=y
+# CONFIG_SND_VERBOSE_PROCFS is not set
+CONFIG_SND_ALOOP=m
+# CONFIG_SND_ARM is not set
+CONFIG_SND_SOC=y
+CONFIG_SND_SUNIV_CODEC=y
+CONFIG_USB_DYNAMIC_MINORS=y
+CONFIG_USB_OTG=y
+CONFIG_USB_EHCI_HCD=y
+CONFIG_USB_EHCI_HCD_PLATFORM=y
+CONFIG_USB_OHCI_HCD=y
+CONFIG_USB_OHCI_HCD_PLATFORM=y
+CONFIG_USB_STORAGE=y
+CONFIG_USB_MUSB_HDRC=y
+CONFIG_USB_MUSB_SUNXI=y
+CONFIG_NOP_USB_XCEIV=y
+CONFIG_USB_GADGET=y
+CONFIG_USB_GADGET_VBUS_DRAW=500
+CONFIG_USB_CONFIGFS=y
+CONFIG_USB_CONFIGFS_SERIAL=y
+CONFIG_USB_CONFIGFS_ACM=y
+CONFIG_USB_CONFIGFS_OBEX=y
+CONFIG_USB_CONFIGFS_MASS_STORAGE=y
+CONFIG_USB_CONFIGFS_F_LB_SS=y
+CONFIG_USB_CONFIGFS_F_FS=y
+CONFIG_USB_CONFIGFS_F_UAC1=y
+CONFIG_USB_CONFIGFS_F_UAC1_LEGACY=y
+CONFIG_USB_CONFIGFS_F_UAC2=y
+CONFIG_USB_CONFIGFS_F_MIDI=y
+CONFIG_USB_CONFIGFS_F_HID=y
+CONFIG_USB_CONFIGFS_F_PRINTER=y
+CONFIG_USB_FUNCTIONFS=m
+CONFIG_USB_MASS_STORAGE=m
+CONFIG_USB_G_ACM_MS=m
+CONFIG_MMC=y
+CONFIG_MMC_SUNXI=y
+CONFIG_STAGING=y
+# CONFIG_IOMMU_SUPPORT is not set
+CONFIG_PWM=y
+CONFIG_PWM_SUNIV=y
+CONFIG_PHY_SUN4I_USB=y
+CONFIG_NVMEM=y
+CONFIG_NVMEM_SUNXI_SID=y
+CONFIG_EXT2_FS=y
+CONFIG_EXT3_FS=y
+CONFIG_VFAT_FS=y
+CONFIG_TMPFS=y
+CONFIG_NLS_CODEPAGE_437=y
+CONFIG_NLS_ISO8859_1=y
+CONFIG_PRINTK_TIME=y
+CONFIG_CONSOLE_LOGLEVEL_DEFAULT=4
+CONFIG_KEYS=y
+# CONFIG_CRYPTO_MANAGER_DISABLE_TESTS is not set
+# CONFIG_CRYPTO_ECHAINIV is not set
+CONFIG_CRYPTO_DRBG_MENU=y
+# CONFIG_CRYPTO_HW is not set
diff --git a/arch/arm/include/asm/arch-suniv/clock.h b/arch/arm/include/asm/arch-suniv/clock.h
new file mode 100644
index 00000000..909addc4
--- /dev/null
+++ b/arch/arm/include/asm/arch-suniv/clock.h
@@ -0,0 +1,149 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option)any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+#ifndef __SUNIV_CCM_H__
+#define __SUNIV_CCM_H__
+
+#define PLL_CPU_CTRL_REG          0x0000 //PLL_CPU Control Register
+#define PLL_AUDIO_CTRL_REG        0x0008 //PLL_AUDIO Control Register
+#define PLL_VIDEO_CTRL_REG        0x0010 //PLL_VIDEO Control Register
+#define PLL_VE_CTRL_REG           0x0018 //PLL_VE Control Register
+#define PLL_DDR_CTRL_REG          0x0020 //PLL_DDR Control Register
+#define PLL_PERIPH_CTRL_REG       0x0028 //PLL_PERIPH Control Register
+#define CPU_CLK_SRC_REG           0x0050 //CPU Clock Source Register
+#define AHB_APB_HCLKC_CFG_REG     0x0054 //AHB/APB/HCLKC Configuration Register
+#define BUS_CLK_GATING_REG0       0x0060 //Bus Clock Gating Register 0
+#define BUS_CLK_GATING_REG1       0x0064 //Bus Clock Gating Register 1
+#define BUS_CLK_GATING_REG2       0x0068 //Bus Clock Gating Register 2
+#define SDMMC0_CLK_REG            0x0088 //SDMMC0 Clock Register
+#define SDMMC1_CLK_REG            0x008C //SDMMC1 Clock Register
+#define DAUDIO_CLK_REG            0x00B0 //DAUDIO Clock Register
+#define OWA_CLK_REG               0x00B4 //OWA Clock Register
+#define CIR_CLK_REG               0x00B8 //CIR Clock Register
+#define USBPHY_CLK_REG            0x00CC //USBPHY Clock Register
+#define DRAM_GATING_REG           0x0100 //DRAM GATING Register
+#define BE_CLK_REG                0x0104 //BE Clock Register
+#define FE_CLK_REG                0x010C //FE Clock Register
+#define TCON_CLK_REG              0x0118 //TCON Clock Register
+#define DI_CLK_REG                0x011C //De-interlacer Clock Register
+#define TVE_CLK_REG               0x0120 //TVE Clock Register
+#define TVD_CLK_REG               0x0124 //TVD Clock Register
+#define CSI_CLK_REG               0x0134 //CSI Clock Register
+#define VE_CLK_REG                0x013C //VE Clock Register
+#define AUDIO_CODEC_CLK_REG       0x0140 //Audio Codec Clock Register
+#define AVS_CLK_REG               0x0144 //AVS Clock Register
+#define PLL_STABLE_TIME_REG0      0x0200 //PLL Stable Time Register 0
+#define PLL_STABLE_TIME_REG1      0x0204 //PLL Stable Time Register 1
+#define PLL_CPU_BIAS_REG          0x0220 //PLL_CPU Bias Register
+#define PLL_AUDIO_BIAS_REG        0x0224 //PLL_AUDIO Bias Register
+#define PLL_VIDEO_BIAS_REG        0x0228 //PLL_VIDEO Bias Register
+#define PLL_VE_BIAS_REG           0x022C //PLL_VE Bias Register
+#define PLL_DDR_BIAS_REG          0x0230 //PLL_DDR Bias Register
+#define PLL_PERIPH_BIAS_REG       0x0234 //PLL_PERIPH Bias Register
+#define PLL_CPU_TUN_REG           0x0250 //PLL_CPU Tuning Register
+#define PLL_DDR_TUN_REG           0x0260 //PLL_DDR Tuning Register
+#define PLL_AUDIO_PAT_CTRL_REG    0x0284 //PLL_AUDIO Pattern Control Register
+#define PLL_VIDEO_PAT_CTRL_REG    0x0288 //PLL_VIDEO Pattern Control Register
+#define PLL_DDR_PAT_CTRL_REG      0x0290 //PLL_DDR Pattern Control Register
+#define BUS_SOFT_RST_REG0         0x02C0 //Bus Software Reset Register 0
+#define BUS_SOFT_RST_REG1         0x02C4 //Bus Software Reset Register 1
+#define BUS_SOFT_RST_REG2         0x02D0 //Bus Software Reset Register 2
+
+typedef enum
+{
+    CCU_PLL_CPU_CTRL     = 0x000,
+    CCU_PLL_AUDIO_CTRL   = 0x008,
+    CCU_PLL_VIDEO_CTRL   = 0x010,
+    CCU_PLL_VE_CTRL      = 0x018,
+    CCU_PLL_DDR_CTRL     = 0x020,
+    CCU_PLL_PERIPH_CTRL  = 0x028,
+    CCU_CPU_CFG          = 0x050,
+    CCU_AHB_APB_CFG      = 0x054,
+
+    CCU_BUS_CLK_GATE0    = 0x060,
+    CCU_BUS_CLK_GATE1    = 0x064,
+    CCU_BUS_CLK_GATE2    = 0x068,
+
+    CCU_SDMMC0_CLK       = 0x088,
+    CCU_SDMMC1_CLK       = 0x08c,
+    CCU_DAUDIO_CLK       = 0x0b0,
+    CCU_SPDIF_CLK        = 0x0b4,
+    CCU_I2S_CLK          = 0x0b8,
+    CCU_USBPHY_CFG       = 0x0cc,
+    CCU_DRAM_CLK_GATE    = 0x100,
+    CCU_DEBE_CLK         = 0x104,
+    CCU_DEFE_CLK         = 0x10c,
+    CCU_TCON_CLK         = 0x118,
+    CCU_DEINTERLACE_CLK  = 0x11c,
+    CCU_TVE_CLK          = 0x120,
+    CCU_TVD_CLK          = 0x124,
+    CCU_CSI_CLK          = 0x134,
+    CCU_VE_CLK           = 0x13c,
+    CCU_ADDA_CLK         = 0x140,
+    CCU_AVS_CLK          = 0x144,
+
+    CCU_PLL_STABLE_TIME0 = 0x200,
+    CCU_PLL_STABLE_TIME1 = 0x204,
+    CCU_PLL_CPU_BIAS     = 0x220,
+    CCU_PLL_AUDIO_BIAS   = 0x224,
+    CCU_PLL_VIDEO_BIAS   = 0x228,
+    CCU_PLL_VE_BIAS      = 0x22c,
+    CCU_PLL_DDR0_BIAS    = 0x230,
+    CCU_PLL_PERIPH_BIAS  = 0x234,
+    CCU_PLL_CPU_TUN      = 0x250,
+    CCU_PLL_DDR_TUN      = 0x260,
+    CCU_PLL_AUDIO_PAT    = 0x284,
+    CCU_PLL_VIDEO_PAT    = 0x288,
+    CCU_PLL_DDR0_PAT     = 0x290,
+
+    CCU_BUS_SOFT_RST0    = 0x2c0,
+    CCU_BUS_SOFT_RST1    = 0x2c4,
+    CCU_BUS_SOFT_RST2    = 0x2d0,
+} ccu_reg_e;
+
+typedef enum
+{
+    CLK_CPU_SRC_LOSC = 0, // not used?
+    CLK_CPU_SRC_OSC24M = 1,
+    CLK_CPU_SRC_PLL_CPU = 2,
+} clk_source_cpu_e;
+
+typedef enum
+{
+    PLL_CPU = CCU_PLL_CPU_CTRL,
+    PLL_AUDIO = CCU_PLL_AUDIO_CTRL,
+    PLL_VIDEO = CCU_PLL_VIDEO_CTRL,
+    PLL_VE = CCU_PLL_VE_CTRL,
+    PLL_DDR = CCU_PLL_DDR_CTRL,
+    PLL_PERIPH = CCU_PLL_PERIPH_CTRL,
+} pll_ch_e;
+
+typedef enum
+{
+    CLK_AHB_SRC_LOSC = 0,
+    CLK_AHB_SRC_OSC24M = 1,
+    CLK_AHB_SRC_CPUCLK = 2,
+    CLK_AHB_SRC_PLL_PERIPH_PREDIV = 3,
+} clk_source_ahb_e;
+
+typedef enum
+{
+    CLK_APB_DIV_2 = 1,
+    CLK_APB_DIV_4 = 2,
+    CLK_APB_DIV_8 = 3,
+} clk_div_apb_e;
+
+#endif
+
diff --git a/arch/arm/include/asm/arch-suniv/codec.h b/arch/arm/include/asm/arch-suniv/codec.h
new file mode 100644
index 00000000..81465e7d
--- /dev/null
+++ b/arch/arm/include/asm/arch-suniv/codec.h
@@ -0,0 +1,49 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option)any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+#ifndef __SUNIV_CODEC_H__
+#define __SUNIV_CODEC_H__
+
+#define AC_DAC_DPC_REG            0x00 //DAC Digital Part Control Register
+#define AC_DAC_FIFOC_REG          0x04 //DAC FIFO Control Register
+#define AC_DAC_FIFOS_REG          0x08 //DAC FIFO Status Register
+#define AC_DAC_TXDATA_REG         0x0c //DAC TX Data Register
+#define AC_ADC_FIFOC_REG          0x10 //ADC FIFO Control Register
+#define AC_ADC_FIFOS_REG          0x14 //ADC FIFO Status Register
+#define AC_ADC_RXDATA_REG         0x18 //ADC RX Data Register
+#define DAC_MIXER_CTRL_REG        0x20 //DAC&MIXER Control Register
+#define ADC_MIXER_CTRL_REG        0x24 //ADC Analog and Input mixer Control Register
+#define ADDA_TUNE_REG             0x28 //ADC&DAC performance tuning Register
+#define BIAS_DA16_CAL_CTRL_REG0   0x2C //Bias&DA16 Calibration Control Register 0
+#define BIAS_DA16_CAL_CTRL_REG1   0x34 //Bias&DA16 Calibration Control Register 1
+#define AC_DAC_CNT_REG            0x40 //DAC TX FIFO Counter Register
+#define AC_ADC_CNT_REG            0x44 //ADC RX FIFO Counter Register
+#define AC_DAC_DG_REG             0x48 //DAC Debug Register
+#define AC_ADC_DG_REG             0x4c //ADC Debug Register
+#define AC_ADC_DAP_CTR_REG        0x70 //ADC DAP Control Register
+#define AC_ADC_DAP_LCTR_REG       0x74 //ADC DAP Left Control Register
+#define AC_ADC_DAP_RCTR_REG       0x78 //ADC DAP Right Control Register
+#define AC_ADC_DAP_PARA_REG       0x7C //ADC DAP Parameter Register
+#define AC_ADC_DAP_LAC_REG        0x80 //ADC DAP Left Average Coef Register
+#define AC_ADC_DAP_LDAT_REG       0x84 //ADC DAP Left Decay and Attack Time Register
+#define AC_ADC_DAP_RAC_REG        0x88 //ADC DAP Right Average Coef Register
+#define AC_ADC_DAP_RDAT_REG       0x8C //ADC DAP Right Decay and Attack Time Register
+#define ADC_DAP_HPFC_REG          0x90 //ADC DAP HPF Coef Register
+#define ADC_DAP_LINAC_REG         0x94 //ADC DAP Left Input Signal Low Average Coef Register
+#define ADC_DAP_RINAC_REG         0x98 //ADC DAP Right Input Signal Low Average Coef Register
+#define ADC_DAP_ORT_REG           0x9c //ADC DAP Optimum Register
+
+#endif
+
diff --git a/arch/arm/include/asm/arch-suniv/common.h b/arch/arm/include/asm/arch-suniv/common.h
new file mode 100644
index 00000000..36fd3ce5
--- /dev/null
+++ b/arch/arm/include/asm/arch-suniv/common.h
@@ -0,0 +1,23 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option)any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+#ifndef __SUNIV_COMMON_H__
+#define __SUNIV_COMMON_H__
+
+void suniv_clrbits(void __iomem *reg, u32 clr_val);
+void suniv_setbits(void __iomem *reg, u32 set_val);
+void suniv_clrsetbits(void __iomem *reg, u32 clr_val, u32 set_val);
+
+#endif
diff --git a/arch/arm/include/asm/arch-suniv/cpu.h b/arch/arm/include/asm/arch-suniv/cpu.h
new file mode 100644
index 00000000..c52ab94d
--- /dev/null
+++ b/arch/arm/include/asm/arch-suniv/cpu.h
@@ -0,0 +1,32 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option)any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+#ifndef __SUNIV_CPU_H__
+#define __SUNIV_CPU_H__
+
+#define SUNIV_DMA_BASE      0x01c02000
+#define SUNIV_CCM_BASE      0x01c20000
+#define SUNIV_DEFE_BASE     0x01e00000
+#define SUNIV_DEBE_BASE     0x01e60000
+#define SUNIV_LCDC_BASE     0x01c0C000
+#define SUNIV_GPIO_BASE     0x01c20800
+#define SUNIV_INTC_BASE     0x01c20400
+#define SUNIV_DA_BASE       0x01C22000
+#define SUNIV_CODEC_BASE    0x01C23C00
+#define SUNIV_LRADC_BASE    0x01C23400
+#define SUNIV_TVE_BASE      0x01C0A000
+
+#endif
+
diff --git a/arch/arm/include/asm/arch-suniv/debe.h b/arch/arm/include/asm/arch-suniv/debe.h
new file mode 100644
index 00000000..4cc1dab7
--- /dev/null
+++ b/arch/arm/include/asm/arch-suniv/debe.h
@@ -0,0 +1,113 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option)any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+#ifndef __SUNIV_DEBE_H__
+#define __SUNIV_DEBE_H__
+
+#define DEBE_MODE_CTRL_REG        0x800 //DEBE Mode Control Register
+#define DEBE_COLOR_CTRL_REG       0x804 //DEBE Color Control Register
+#define DEBE_DISP_SIZE_REG        0x808 //DEBE Display Size (Undocument)
+#define DEBE_LAY0_SIZE_REG        0x810 //DEBE Layer 0 Size Register
+#define DEBE_LAY1_SIZE_REG        0x814 //DEBE Layer 1 Size Register
+#define DEBE_LAY2_SIZE_REG        0x818 //DEBE Layer 2 Size Register
+#define DEBE_LAY3_SIZE_REG        0x81C //DEBE Layer 3 Size Register
+#define DEBE_LAY0_CODNT_REG       0x820 //DEBE layer 0 Coordinate Control Register
+#define DEBE_LAY1_CODNT_REG       0x824 //DEBE Layer 1 Coordinate Control Register
+#define DEBE_LAY2_CODNT_REG       0x828 //DEBE Layer 2 Coordinate Control Register
+#define DEBE_LAY3_CODNT_REG       0x82C //DEBE Layer 3 Coordinate Control Register
+#define DEBE_LAY0_LINEWIDTH_REG   0x840 //DEBE Layer 0 Frame Buffer Line Width Register
+#define DEBE_LAY1_LINEWIDTH_REG   0x844 //DEBE Layer 1 Frame Buffer Line Width Register
+#define DEBE_LAY2_LINEWIDTH_REG   0x848 //DEBE Layer 2 Frame Buffer Line Width Register
+#define DEBE_LAY3_LINEWIDTH_REG   0x84C //DEBE Layer 3 Frame Buffer Line Width Register
+#define DEBE_LAY0_FB_ADDR_REG     0x850 //DEBE Layer 0 Frame Buffer Address Register
+#define DEBE_LAY1_FB_ADDR_REG     0x854 //DEBE Layer 1 Frame Buffer Address Register
+#define DEBE_LAY2_FB_ADDR_REG     0x858 //DEBE Layer 2 Frame Buffer Address Register
+#define DEBE_LAY3_FB_ADDR_REG     0x85C //DEBE Layer 3 Frame Buffer Address Register
+#define DEBE_LAY0_FB_HI_ADDR_REG  0x860 //DEBE Layer 0 Frame Buffer High Address Register (Undocument)
+#define DEBE_LAY1_FB_HI_ADDR_REG  0x864 //DEBE Layer 1 Frame Buffer High Address Register (Undocument)
+#define DEBE_LAY2_FB_HI_ADDR_REG  0x868 //DEBE Layer 2 Frame Buffer High Address Register (Undocument)
+#define DEBE_LAY3_FB_HI_ADDR_REG  0x86c //DEBE Layer 3 Frame Buffer High Address Register (Undocument)
+#define DEBE_REGBUFF_CTRL_REG     0x870 //DEBE Register Buffer Control Register
+#define DEBE_CK_MAX_REG           0x880 //DEBE Color Key Max Register
+#define DEBE_CK_MIN_REG           0x884 //DEBE Color Key Min register
+#define DEBE_CK_CFG_REG           0x888 //DEBE Color Key Configuration Register
+#define DEBE_LAY0_ATT_CTRL_REG0   0x890 //DEBE Layer 0 Attribute Control Register 0
+#define DEBE_LAY1_ATT_CTRL_REG0   0x894 //DEBE Layer 1 Attribute Control register 1
+#define DEBE_LAY2_ATT_CTRL_REG0   0x898 //DEBE Layer2 Attribute Control Register 0
+#define DEBE_LAY3_ATT_CTRL_REG0   0x89C //DEBE Layer3 Attribute Control Register 0
+#define DEBE_LAY0_ATT_CTRL_REG1   0x8A0 //DEBE Layer0 Attribute Control Register 1
+#define DEBE_LAY1_ATT_CTRL_REG1   0x8A4 //DEBE Layer 1 Attribute Control Register 1
+#define DEBE_LAY2_ATT_CTRL_REG1   0x8A8 //DEBE Layer 2 Attribute Control Register 1
+#define DEBE_LAY3_ATT_CTRL_REG1   0x8AC //DEBE Layer 3 Attribute Control Register 1
+#define DEBE_HWC_CTRL_REG         0x8D8 //DEBE HWC Coordinate Control Register
+#define DEBE_HWCFB_CTRL_REG       0x8E0 //DEBE HWC Frame Buffer Format Register
+#define DEBE_WB_CTRL_REG          0x8F0 //DEBE Write Back Control Register
+#define DEBE_WB_ADDR_REG          0x8F4 //DEBE Write Back Address Register
+#define DEBE_WB_LW_REG            0x8F8 //DEBE Write Back Buffer Line Width Register
+#define DEBE_IYUV_CH_CTRL_REG     0x920 //DEBE Input YUV Channel Control Register
+#define DEBE_CH0_YUV_FB_ADDR_REG  0x930 //DEBE YUV Channel 0 Frame Buffer Address Register
+#define DEBE_CH1_YUV_FB_ADDR_REG  0x934 //DEBE YUV Channel 1 Frame Buffer Address Register
+#define DEBE_CH2_YUV_FB_ADDR_REG  0x938 //DEBE YUV Channel 2 Frame Buffer Address Register
+#define DEBE_CH0_YUV_BLW_REG      0x940 //DEBE YUV Channel 0 Buffer Line Width Register
+#define DEBE_CH1_YUV_BLW_REG      0x944 //DEBE YUV Channel 1 Buffer Line Width Register
+#define DEBE_CH2_YUV_BLW_REG      0x948 //DEBE YUV Channel 2 Buffer Line Width Register
+#define DEBE_COEF00_REG           0x950 //DEBE Coefficient 00 Register
+#define DEBE_COEF01_REG           0x954 //DEBE Coefficient 01 Register
+#define DEBE_COEF02_REG           0x958 //DEBE Coefficient 02 Register
+#define DEBE_COEF03_REG           0x95C //DEBE Coefficient 03 Register
+#define DEBE_COEF10_REG           0x960 //DEBE Coefficient 10 Register
+#define DEBE_COEF11_REG           0x964 //DEBE Coefficient 11 Register
+#define DEBE_COEF12_REG           0x968 //DEBE Coefficient 12 Register
+#define DEBE_COEF13_REG           0x96C //DEBE Coefficient 13 Register
+#define DEBE_COEF20_REG           0x970 //DEBE Coefficient 20 Register
+#define DEBE_COEF21_REG           0x974 //DEBE Coefficient 21 Register
+#define DEBE_COEF22_REG           0x978 //DEBE Coefficient 22 Register
+#define DEBE_COEF23_REG           0x97C //DEBE Coefficient 23 Register
+
+typedef enum
+{
+    DEFE_EN         = 0x000,
+    DEFE_FRM_CTRL   = 0x004,
+    DEFE_BYPASS     = 0x008,
+    DEFE_AGTH_SEL   = 0x00C,
+    DEFE_INT_LINE   = 0x010,
+    DEFE_ADDR0      = 0x020,
+    DEFE_ADDR1      = 0x024,
+    DEFE_ADDR2      = 0x028,
+    DEFE_FIELD_CTRL = 0x02C,
+    DEFE_TB_OFF0    = 0x030,
+    DEFE_TB_OFF1    = 0x034,
+    DEFE_TB_OFF2    = 0x038,
+    DEFE_STRIDE0    = 0x040,
+    DEFE_STRIDE1    = 0x044,
+    DEFE_STRIDE2    = 0x048,
+    DEFE_IN_FMT     = 0x04C,
+    DEFE_WB_ADDR    = 0x050,
+    DEFE_OUT_FMT    = 0x05C,
+    DEFE_INT_EN     = 0x060,
+    DEFE_INT_STATUS = 0x064,
+    DEFE_STATUS     = 0x068,
+    DEFE_CSC_COEF   = 0x070,
+    DEFE_IN_SIZE    = 0x100,
+    DEFE_OUT_SIZE   = 0x104,
+    DEFE_H_FACT     = 0x108,
+    DEFE_V_FACT     = 0x10C,
+    DEFE_CH0_H_COEF = 0x400,
+    DEFE_CH0_V_COEF = 0x500,
+    DEFE_CH1_H_COEF = 0x600,
+    DEFE_CH1_V_COEF = 0x700,
+} defe_reg_e;
+#endif
+
diff --git a/arch/arm/include/asm/arch-suniv/dma.h b/arch/arm/include/asm/arch-suniv/dma.h
new file mode 100644
index 00000000..603942b3
--- /dev/null
+++ b/arch/arm/include/asm/arch-suniv/dma.h
@@ -0,0 +1,65 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option)any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+#ifndef __SUNIV_DMA_H__
+#define __SUNIV_DMA_H__
+
+#define DMA_INT_CTRL_REG      0x00                  //DMA Interrupt Control Register
+#define DMA_INT_STA_REG       0x04                  //DMA Interrupt Status Register
+#define DMA_PTY_CFG_REG       0x08                  //DMA Priority Configure Register
+#define NDMA0_CFG_REG         (0x100+(0*0x20)+0x0)  //Normal DMA Configure Register n (n=0~3)
+#define NDMA0_SRC_ADR_REG     (0x100+(0*0x20)+0x4)  //Normal DMA Source Address Register n (n=0~3)
+#define NDMA0_DES_ADR_REG     (0x100+(0*0x20)+0x8)  //Normal DMA Destination Address Register n (n=0~3)
+#define NDMA0_BYTE_CNT_REG    (0x100+(0*0x20)+0xC)  //Normal DMA Byte Counter Register n (n=0~3)
+#define NDMA1_CFG_REG         (0x100+(1*0x20)+0x0)  //Normal DMA Configure Register n (n=0~3)
+#define NDMA1_SRC_ADR_REG     (0x100+(1*0x20)+0x4)  //Normal DMA Source Address Register n (n=0~3)
+#define NDMA1_DES_ADR_REG     (0x100+(1*0x20)+0x8)  //Normal DMA Destination Address Register n (n=0~3)
+#define NDMA1_BYTE_CNT_REG    (0x100+(1*0x20)+0xC)  //Normal DMA Byte Counter Register n (n=0~3)
+#define NDMA2_CFG_REG         (0x100+(2*0x20)+0x0)  //Normal DMA Configure Register n (n=0~3)
+#define NDMA2_SRC_ADR_REG     (0x100+(2*0x20)+0x4)  //Normal DMA Source Address Register n (n=0~3)
+#define NDMA2_DES_ADR_REG     (0x100+(2*0x20)+0x8)  //Normal DMA Destination Address Register n (n=0~3)
+#define NDMA2_BYTE_CNT_REG    (0x100+(2*0x20)+0xC)  //Normal DMA Byte Counter Register n (n=0~3)
+#define NDMA3_CFG_REG         (0x100+(3*0x20)+0x0)  //Normal DMA Configure Register n (n=0~3)
+#define NDMA3_SRC_ADR_REG     (0x100+(3*0x20)+0x4)  //Normal DMA Source Address Register n (n=0~3)
+#define NDMA3_DES_ADR_REG     (0x100+(3*0x20)+0x8)  //Normal DMA Destination Address Register n (n=0~3)
+#define NDMA3_BYTE_CNT_REG    (0x100+(3*0x20)+0xC)  //Normal DMA Byte Counter Register n (n=0~3)
+
+
+#define DDMA0_CFG_REG         (0x300+(0*0x20)+0x0)  //Dedicated DMA Configure Register n (n=0~3)
+#define DDMA0_SRC_ADR_REG     (0x300+(0*0x20)+0x4)  //Dedicated DMA Source Address Register n (n=0~3)
+#define DDMA0_DES_ADR_REG     (0x300+(0*0x20)+0x8)  //Dedicated DMA Destination Address Register n (n=0~3)
+#define DDMA0_BYTE_CNT_REG    (0x300+(0*0x20)+0xC)  //Dedicated DMA Byte Counter Register n (n=0~3)
+#define DDMA0_PAR_REG         (0x300+(0*0x20)+0x18) //Dedicated DMA Parameter Register n (n=0~3)
+#define DDMA0_GEN_DATA        (0x300+(0*0x20)+0x1c) //Dedicated DMA General DATA Register 3
+#define DDMA1_CFG_REG         (0x300+(1*0x20)+0x0)  //Dedicated DMA Configure Register n (n=0~3)
+#define DDMA1_SRC_ADR_REG     (0x300+(1*0x20)+0x4)  //Dedicated DMA Source Address Register n (n=0~3)
+#define DDMA1_DES_ADR_REG     (0x300+(1*0x20)+0x8)  //Dedicated DMA Destination Address Register n (n=0~3)
+#define DDMA1_BYTE_CNT_REG    (0x300+(1*0x20)+0xC)  //Dedicated DMA Byte Counter Register n (n=0~3)
+#define DDMA1_PAR_REG         (0x300+(1*0x20)+0x18) //Dedicated DMA Parameter Register n (n=0~3)
+#define DDMA1_GEN_DATA        (0x300+(1*0x20)+0x1c) //Dedicated DMA General DATA Register 3
+#define DDMA2_CFG_REG         (0x300+(2*0x20)+0x0)  //Dedicated DMA Configure Register n (n=0~3)
+#define DDMA2_SRC_ADR_REG     (0x300+(2*0x20)+0x4)  //Dedicated DMA Source Address Register n (n=0~3)
+#define DDMA2_DES_ADR_REG     (0x300+(2*0x20)+0x8)  //Dedicated DMA Destination Address Register n (n=0~3)
+#define DDMA2_BYTE_CNT_REG    (0x300+(2*0x20)+0xC)  //Dedicated DMA Byte Counter Register n (n=0~3)
+#define DDMA2_PAR_REG         (0x300+(2*0x20)+0x18) //Dedicated DMA Parameter Register n (n=0~3)
+#define DDMA2_GEN_DATA        (0x300+(2*0x20)+0x1c) //Dedicated DMA General DATA Register 3
+#define DDMA3_CFG_REG         (0x300+(3*0x20)+0x0)  //Dedicated DMA Configure Register n (n=0~3)
+#define DDMA3_SRC_ADR_REG     (0x300+(3*0x20)+0x4)  //Dedicated DMA Source Address Register n (n=0~3)
+#define DDMA3_DES_ADR_REG     (0x300+(3*0x20)+0x8)  //Dedicated DMA Destination Address Register n (n=0~3)
+#define DDMA3_BYTE_CNT_REG    (0x300+(3*0x20)+0xC)  //Dedicated DMA Byte Counter Register n (n=0~3)
+#define DDMA3_PAR_REG         (0x300+(3*0x20)+0x18) //Dedicated DMA Parameter Register n (n=0~3)
+#define DDMA3_GEN_DATA        (0x300+(3*0x20)+0x1c) //Dedicated DMA General DATA Register 3
+
+#endif
diff --git a/arch/arm/include/asm/arch-suniv/dram.h b/arch/arm/include/asm/arch-suniv/dram.h
new file mode 100644
index 00000000..088eb5b9
--- /dev/null
+++ b/arch/arm/include/asm/arch-suniv/dram.h
@@ -0,0 +1,47 @@
+/*
+ * suniv DRAM controller register definition
+ *
+ * Copyright (C) 2018 Icenowy Zheng <icenowy@aosc.io>
+ *
+ * Based on xboot's arch/arm32/mach-f1c100s/sys-dram.c, which is:
+ *
+ * Copyright(c) 2007-2018 Jianjun Jiang <8192542@qq.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#define PIO_SDRAM_DRV			(0x2c0)
+#define PIO_SDRAM_PULL			(0x2c4)
+
+#define DRAM_SCONR			(0x00)
+#define DRAM_STMG0R			(0x04)
+#define DRAM_STMG1R			(0x08)
+#define DRAM_SCTLR			(0x0c)
+#define DRAM_SREFR			(0x10)
+#define DRAM_SEXTMR			(0x14)
+#define DRAM_DDLYR			(0x24)
+#define DRAM_DADRR			(0x28)
+#define DRAM_DVALR			(0x2c)
+#define DRAM_DRPTR0			(0x30)
+#define DRAM_DRPTR1			(0x34)
+#define DRAM_DRPTR2			(0x38)
+#define DRAM_DRPTR3			(0x3c)
+#define DRAM_SEFR			(0x40)
+#define DRAM_MAE			(0x44)
+#define DRAM_ASPR			(0x48)
+#define DRAM_SDLY0			(0x4C)
+#define DRAM_SDLY1			(0x50)
+#define DRAM_SDLY2			(0x54)
+#define DRAM_MCR0			(0x100)
+#define DRAM_MCR1			(0x104)
+#define DRAM_MCR2			(0x108)
+#define DRAM_MCR3			(0x10c)
+#define DRAM_MCR4			(0x110)
+#define DRAM_MCR5			(0x114)
+#define DRAM_MCR6			(0x118)
+#define DRAM_MCR7			(0x11c)
+#define DRAM_MCR8			(0x120)
+#define DRAM_MCR9			(0x124)
+#define DRAM_MCR10			(0x128)
+#define DRAM_MCR11			(0x12c)
+#define DRAM_BWCR			(0x140)
diff --git a/arch/arm/include/asm/arch-suniv/gpio.h b/arch/arm/include/asm/arch-suniv/gpio.h
new file mode 100644
index 00000000..0bfeebed
--- /dev/null
+++ b/arch/arm/include/asm/arch-suniv/gpio.h
@@ -0,0 +1,79 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option)any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+#ifndef __SUNIV_GPIO_H__
+#define __SUNIV_GPIO_H__
+
+#define PA_CFG0     ((0*0x24)+0x00)       //Port n Configure Register 0 (n=0~5)
+#define PA_CFG1     ((0*0x24)+0x04)       //Port n Configure Register 1 (n=0~5)
+#define PA_CFG2     ((0*0x24)+0x08)       //Port n Configure Register 2 (n=0~5)
+#define PA_CFG3     ((0*0x24)+0x0C)       //Port n Configure Register 3 (n=0~5)
+#define PA_DATA     ((0*0x24)+0x10)       //Port n Data Register (n=0~5)
+#define PA_DRV0     ((0*0x24)+0x14)       //Port n Multi-Driving Register 0 (n=0~5)
+#define PA_DRV1     ((0*0x24)+0x18)       //Port n Multi-Driving Register 1 (n=0~5)
+#define PA_PUL0     ((0*0x24)+0x1C)       //Port n Pull Register 0 (n=0~5)
+#define PA_PUL1     ((0*0x24)+0x20)       //Port n Pull Register 1 (n=0~5)
+
+#define PC_CFG0     ((2*0x24)+0x00)       //Port n Configure Register 0 (n=0~5)
+#define PC_CFG1     ((2*0x24)+0x04)       //Port n Configure Register 1 (n=0~5)
+#define PC_CFG2     ((2*0x24)+0x08)       //Port n Configure Register 2 (n=0~5)
+#define PC_CFG3     ((2*0x24)+0x0C)       //Port n Configure Register 3 (n=0~5)
+#define PC_DATA     ((2*0x24)+0x10)       //Port n Data Register (n=0~5)
+#define PC_DRV0     ((2*0x24)+0x14)       //Port n Multi-Driving Register 0 (n=0~5)
+#define PC_DRV1     ((2*0x24)+0x18)       //Port n Multi-Driving Register 1 (n=0~5)
+#define PC_PUL0     ((2*0x24)+0x1C)       //Port n Pull Register 0 (n=0~5)
+#define PC_PUL1     ((2*0x24)+0x20)       //Port n Pull Register 1 (n=0~5)
+
+#define PD_CFG0     ((3*0x24)+0x00)       //Port n Configure Register 0 (n=0~5)
+#define PD_CFG1     ((3*0x24)+0x04)       //Port n Configure Register 1 (n=0~5)
+#define PD_CFG2     ((3*0x24)+0x08)       //Port n Configure Register 2 (n=0~5)
+#define PD_CFG3     ((3*0x24)+0x0C)       //Port n Configure Register 3 (n=0~5)
+#define PD_DATA     ((3*0x24)+0x10)       //Port n Data Register (n=0~5)
+#define PD_DRV0     ((3*0x24)+0x14)       //Port n Multi-Driving Register 0 (n=0~5)
+#define PD_DRV1     ((3*0x24)+0x18)       //Port n Multi-Driving Register 1 (n=0~5)
+#define PD_PUL0     ((3*0x24)+0x1C)       //Port n Pull Register 0 (n=0~5)
+#define PD_PUL1     ((3*0x24)+0x20)       //Port n Pull Register 1 (n=0~5)
+
+#define PE_CFG0     ((4*0x24)+0x00)       //Port n Configure Register 0 (n=0~5)
+#define PE_CFG1     ((4*0x24)+0x04)       //Port n Configure Register 1 (n=0~5)
+#define PE_CFG2     ((4*0x24)+0x08)       //Port n Configure Register 2 (n=0~5)
+#define PE_CFG3     ((4*0x24)+0x0C)       //Port n Configure Register 3 (n=0~5)
+#define PE_DATA     ((4*0x24)+0x10)       //Port n Data Register (n=0~5)
+#define PE_DRV0     ((4*0x24)+0x14)       //Port n Multi-Driving Register 0 (n=0~5)
+#define PE_DRV1     ((4*0x24)+0x18)       //Port n Multi-Driving Register 1 (n=0~5)
+#define PE_PUL0     ((4*0x24)+0x1C)       //Port n Pull Register 0 (n=0~5)
+#define PE_PUL1     ((4*0x24)+0x20)       //Port n Pull Register 1 (n=0~5)
+
+#define PD_INT_CFG0 (0x200+(3*0x20)+0x0)  //PIO Interrupt Configure Register 0 (n=0~2)
+#define PD_INT_CFG1 (0x200+(3*0x20)+0x4)  //PIO Interrupt Configure Register 1 (n=0~2)
+#define PD_INT_CFG2 (0x200+(3*0x20)+0x8)  //PIO Interrupt Configure Register 2 (n=0~2)
+#define PD_INT_CFG3 (0x200+(3*0x20)+0xC)  //PIO Interrupt Configure Register 3 (n=0~2)
+#define PD_INT_CTRL (0x200+(3*0x20)+0x10) //PIO Interrupt Control Register (n=0~2)
+#define PD_INT_STA  (0x200+(3*0x20)+0x14) //PIO Interrupt Status Register (n=0~2)
+#define PD_INT_DEB  (0x200+(3*0x20)+0x18) //PIO Interrupt Debounce Register (n=0~2)
+
+#define PE_INT_CFG0 (0x200+(4*0x20)+0x0)  //PIO Interrupt Configure Register 0 (n=0~2)
+#define PE_INT_CFG1 (0x200+(4*0x20)+0x4)  //PIO Interrupt Configure Register 1 (n=0~2)
+#define PE_INT_CFG2 (0x200+(4*0x20)+0x8)  //PIO Interrupt Configure Register 2 (n=0~2)
+#define PE_INT_CFG3 (0x200+(4*0x20)+0xC)  //PIO Interrupt Configure Register 3 (n=0~2)
+#define PE_INT_CTRL (0x200+(4*0x20)+0x10) //PIO Interrupt Control Register (n=0~2)
+#define PE_INT_STA  (0x200+(4*0x20)+0x14) //PIO Interrupt Status Register (n=0~2)
+#define PE_INT_DEB  (0x200+(4*0x20)+0x18) //PIO Interrupt Debounce Register (n=0~2)
+
+#define SDR_PAD_DRV 0x2C0                 //SDRAM Pad Multi-Driving Register
+#define SDR_PAD_PUL 0x2C4                 //SDRAM Pad Pull Register
+
+#endif
+
diff --git a/arch/arm/include/asm/arch-suniv/i2c.h b/arch/arm/include/asm/arch-suniv/i2c.h
new file mode 100644
index 00000000..4dfd313f
--- /dev/null
+++ b/arch/arm/include/asm/arch-suniv/i2c.h
@@ -0,0 +1,33 @@
+/*
+ * Copyright 2014 - Hans de Goede <hdegoede@redhat.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+#ifndef _SUNXI_I2C_H_
+#define _SUNXI_I2C_H_
+
+#include <asm/arch/cpu.h>
+
+#ifdef CONFIG_I2C0_ENABLE
+#define CONFIG_I2C_MVTWSI_BASE0	SUNXI_TWI0_BASE
+#endif
+#ifdef CONFIG_I2C1_ENABLE
+#define CONFIG_I2C_MVTWSI_BASE1	SUNXI_TWI1_BASE
+#endif
+#ifdef CONFIG_I2C2_ENABLE
+#define CONFIG_I2C_MVTWSI_BASE2	SUNXI_TWI2_BASE
+#endif
+#ifdef CONFIG_I2C3_ENABLE
+#define CONFIG_I2C_MVTWSI_BASE3	SUNXI_TWI3_BASE
+#endif
+#ifdef CONFIG_I2C4_ENABLE
+#define CONFIG_I2C_MVTWSI_BASE4	SUNXI_TWI4_BASE
+#endif
+#ifdef CONFIG_R_I2C_ENABLE
+#define CONFIG_I2C_MVTWSI_BASE5 SUNXI_R_TWI_BASE
+#endif
+
+/* This is abp0-clk on sun4i/5i/7i / abp1-clk on sun6i/sun8i which is 24MHz */
+#define CONFIG_SYS_TCLK		24000000
+
+#endif
diff --git a/arch/arm/include/asm/arch-suniv/intc.h b/arch/arm/include/asm/arch-suniv/intc.h
new file mode 100644
index 00000000..bb2c4e3b
--- /dev/null
+++ b/arch/arm/include/asm/arch-suniv/intc.h
@@ -0,0 +1,38 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option)any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+#ifndef __SUNIV_INTC_H__
+#define __SUNIV_INTC_H__
+
+#define INTC_VECTOR_REG     0x00 //Interrupt Vector Register
+#define INTC_BASE_ADDR_REG  0x04 //Interrupt Base Address Register
+#define NMI_INT_CTRL_REG    0x0C //NMI Interrupt Control Register
+#define INTC_PEND_REG0      0x10 //Interrupt Pending Register 0
+#define INTC_PEND_REG1      0x14 //Interrupt Pending Register 1
+#define INTC_EN_REG0        0x20 //Interrupt Enable Register 0
+#define INTC_EN_REG1        0x24 //Interrupt Enable Register 1
+#define INTC_MASK_REG0      0x30 //Interrupt Mask Register 0
+#define INTC_MASK_REG1      0x34 //Interrupt Mask Register 1
+#define INTC_RESP_REG0      0x40 //Interrupt Response Register 0
+#define INTC_RESP_REG1      0x44 //Interrupt Response Register 1
+#define INTC_FF_REG0        0x50 //Interrupt Fast Forcing Register 0
+#define INTC_FF_REG1        0x54 //Interrupt Fast Forcing Register 1
+#define INTC_PRIO_REG0      0x60 //Interrupt Source Priority Register 0
+#define INTC_PRIO_REG1      0x64 //Interrupt Source Priority Register 1
+#define INTC_PRIO_REG2      0x68 //Interrupt Source Priority Register 2
+#define INTC_PRIO_REG3      0x6C //Interrupt Source Priority Register 3
+
+#endif
+
diff --git a/arch/arm/include/asm/arch-suniv/lcdc.h b/arch/arm/include/asm/arch-suniv/lcdc.h
new file mode 100644
index 00000000..18f1ec9e
--- /dev/null
+++ b/arch/arm/include/asm/arch-suniv/lcdc.h
@@ -0,0 +1,60 @@
+/*
+ * Copyright (C) 2018 Steward Fu <steward.fu@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option)any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+#ifndef __SUNIV_LCDC_H__
+#define __SUNIV_LCDC_H__
+
+#define TCON_CTRL_REG             0x000 //TCON Control Register
+#define TCON_INT_REG0             0x004 //TCON Interrupt Register 0
+#define TCON_INT_REG1             0x008 //TCON Interrupt Register 1
+#define TCON_FRM_CTRL_REG         0x010 //TCON FRM Control Register
+#define TCON_FRM_SEED0_R_REG      0x014 //TCON FRM Seed0 Red Register
+#define TCON_FRM_SEED0_G_REG      0x018 //TCON FRM Seed0 Green Register
+#define TCON_FRM_SEED0_B_REG      0x01C //TCON FRM Seed0 Blue Register
+#define TCON_FRM_SEED1_R_REG      0x020 //TCON FRM Seed1 Red Register
+#define TCON_FRM_SEED1_G_REG      0x024 //TCON FRM Seed1 Green Register
+#define TCON_FRM_SEED1_B_REG      0x028 //TCON FRM Seed1 Blue Register
+#define TCON_FRM_TBL_REG0         0x02C //TCON FRM Table Register 0
+#define TCON_FRM_TBL_REG1         0x030 //TCON FRM Table Register 1
+#define TCON_FRM_TBL_REG2         0x034 //TCON FRM Table Register 2
+#define TCON_FRM_TBL_REG3         0x038 //TCON FRM Table Register 3
+#define TCON0_CTRL_REG            0x040 //TCON0 Control Register
+#define TCON_CLK_CTRL_REG         0x044 //TCON Clock Control Register
+#define TCON0_BASIC_TIMING_REG0   0x048 //TCON0 Basic Timing Register 0
+#define TCON0_BASIC_TIMING_REG1   0x04C //TCON0 Basic Timing Register 1
+#define TCON0_BASIC_TIMING_REG2   0x050 //TCON0 Basic Timing Register 2
+#define TCON0_BASIC_TIMING_REG3   0x054 //TCON0 Basic Timing Register 3
+#define TCON0_HV_TIMING_REG       0x058 //TCON0 HV Timing Register
+#define TCON0_CPU_IF_REG          0x060 //TCON0 CPU Interface Control Register
+#define TCON0_CPU_WR_REG          0x064 //TCON0 CPU Mode Write Register
+#define TCON0_CPU_RD_REG          0x068 //TCON0 CPU Mode Read Register
+#define TCON0_CPU_RD_NX_REG       0x06C //TCON0 CPU Mode Read NX Register
+#define TCON0_IO_CTRL_REG0        0x088 //TCON0 IO Control Register 0
+#define TCON0_IO_CTRL_REG1        0x08C //TCON0 IO Control Register 1
+#define TCON1_CTRL_REG            0x090 //TCON1 Control Register
+#define TCON1_BASIC_REG0          0x094 //TCON1 Basic Timing Register 0
+#define TCON1_BASIC_REG1          0x098 //TCON1 Basic Timing Register 1
+#define TCON1_BASIC_REG2          0x09C //TCON1 Basic Timing Register 2
+#define TCON1_BASIC_REG3          0x0A0 //TCON1 Basic Timing Register 3
+#define TCON1_BASIC_REG4          0x0A4 //TCON1 Basic Timing Register 4
+#define TCON1_BASIC_REG5          0x0A8 //TCON1 Basic Timing Register 5
+#define TCON1_IO_CTRL_REG0        0x0F0 //TCON1 IO Control Register 0
+#define TCON1_IO_CTRL_REG1        0x0F4 //TCON1 IO Control Register 1
+#define TCON_DEBUG_INFO_REG       0x0FC //TCON Debug Information Register
+
+#endif
+
diff --git a/arch/arm/include/asm/arch-suniv/mmc.h b/arch/arm/include/asm/arch-suniv/mmc.h
new file mode 100644
index 00000000..69f737f3
--- /dev/null
+++ b/arch/arm/include/asm/arch-suniv/mmc.h
@@ -0,0 +1,135 @@
+/*
+ * (C) Copyright 2007-2011
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Aaron <leafy.myeh@allwinnertech.com>
+ *
+ * MMC register definition for allwinner sunxi platform.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef _SUNXI_MMC_H
+#define _SUNXI_MMC_H
+
+#include <linux/types.h>
+
+struct sunxi_mmc {
+	u32 gctrl;		/* 0x00 global control */
+	u32 clkcr;		/* 0x04 clock control */
+	u32 timeout;		/* 0x08 time out */
+	u32 width;		/* 0x0c bus width */
+	u32 blksz;		/* 0x10 block size */
+	u32 bytecnt;		/* 0x14 byte count */
+	u32 cmd;		/* 0x18 command */
+	u32 arg;		/* 0x1c argument */
+	u32 resp0;		/* 0x20 response 0 */
+	u32 resp1;		/* 0x24 response 1 */
+	u32 resp2;		/* 0x28 response 2 */
+	u32 resp3;		/* 0x2c response 3 */
+	u32 imask;		/* 0x30 interrupt mask */
+	u32 mint;		/* 0x34 masked interrupt status */
+	u32 rint;		/* 0x38 raw interrupt status */
+	u32 status;		/* 0x3c status */
+	u32 ftrglevel;		/* 0x40 FIFO threshold watermark*/
+	u32 funcsel;		/* 0x44 function select */
+	u32 cbcr;		/* 0x48 CIU byte count */
+	u32 bbcr;		/* 0x4c BIU byte count */
+	u32 dbgc;		/* 0x50 debug enable */
+	u32 res0;		/* 0x54 reserved */
+	u32 a12a;		/* 0x58 Auto command 12 argument */
+	u32 ntsr;		/* 0x5c	New timing set register */
+	u32 res1[8];
+	u32 dmac;		/* 0x80 internal DMA control */
+	u32 dlba;		/* 0x84 internal DMA descr list base address */
+	u32 idst;		/* 0x88 internal DMA status */
+	u32 idie;		/* 0x8c internal DMA interrupt enable */
+	u32 chda;		/* 0x90 */
+	u32 cbda;		/* 0x94 */
+	u32 res2[26];
+#ifdef CONFIG_SUNXI_GEN_SUN6I
+	u32 res3[64];
+#endif
+	u32 fifo;		/* 0x100 / 0x200 FIFO access address */
+};
+
+#define SUNXI_MMC_CLK_POWERSAVE		(0x1 << 17)
+#define SUNXI_MMC_CLK_ENABLE		(0x1 << 16)
+#define SUNXI_MMC_CLK_DIVIDER_MASK	(0xff)
+
+#define SUNXI_MMC_GCTRL_SOFT_RESET	(0x1 << 0)
+#define SUNXI_MMC_GCTRL_FIFO_RESET	(0x1 << 1)
+#define SUNXI_MMC_GCTRL_DMA_RESET	(0x1 << 2)
+#define SUNXI_MMC_GCTRL_RESET		(SUNXI_MMC_GCTRL_SOFT_RESET|\
+					 SUNXI_MMC_GCTRL_FIFO_RESET|\
+					 SUNXI_MMC_GCTRL_DMA_RESET)
+#define SUNXI_MMC_GCTRL_DMA_ENABLE	(0x1 << 5)
+#define SUNXI_MMC_GCTRL_ACCESS_BY_AHB   (0x1 << 31)
+
+#define SUNXI_MMC_CMD_RESP_EXPIRE	(0x1 << 6)
+#define SUNXI_MMC_CMD_LONG_RESPONSE	(0x1 << 7)
+#define SUNXI_MMC_CMD_CHK_RESPONSE_CRC	(0x1 << 8)
+#define SUNXI_MMC_CMD_DATA_EXPIRE	(0x1 << 9)
+#define SUNXI_MMC_CMD_WRITE		(0x1 << 10)
+#define SUNXI_MMC_CMD_AUTO_STOP		(0x1 << 12)
+#define SUNXI_MMC_CMD_WAIT_PRE_OVER	(0x1 << 13)
+#define SUNXI_MMC_CMD_SEND_INIT_SEQ	(0x1 << 15)
+#define SUNXI_MMC_CMD_UPCLK_ONLY	(0x1 << 21)
+#define SUNXI_MMC_CMD_START		(0x1 << 31)
+
+#define SUNXI_MMC_RINT_RESP_ERROR		(0x1 << 1)
+#define SUNXI_MMC_RINT_COMMAND_DONE		(0x1 << 2)
+#define SUNXI_MMC_RINT_DATA_OVER		(0x1 << 3)
+#define SUNXI_MMC_RINT_TX_DATA_REQUEST		(0x1 << 4)
+#define SUNXI_MMC_RINT_RX_DATA_REQUEST		(0x1 << 5)
+#define SUNXI_MMC_RINT_RESP_CRC_ERROR		(0x1 << 6)
+#define SUNXI_MMC_RINT_DATA_CRC_ERROR		(0x1 << 7)
+#define SUNXI_MMC_RINT_RESP_TIMEOUT		(0x1 << 8)
+#define SUNXI_MMC_RINT_DATA_TIMEOUT		(0x1 << 9)
+#define SUNXI_MMC_RINT_VOLTAGE_CHANGE_DONE	(0x1 << 10)
+#define SUNXI_MMC_RINT_FIFO_RUN_ERROR		(0x1 << 11)
+#define SUNXI_MMC_RINT_HARD_WARE_LOCKED		(0x1 << 12)
+#define SUNXI_MMC_RINT_START_BIT_ERROR		(0x1 << 13)
+#define SUNXI_MMC_RINT_AUTO_COMMAND_DONE	(0x1 << 14)
+#define SUNXI_MMC_RINT_END_BIT_ERROR		(0x1 << 15)
+#define SUNXI_MMC_RINT_SDIO_INTERRUPT		(0x1 << 16)
+#define SUNXI_MMC_RINT_CARD_INSERT		(0x1 << 30)
+#define SUNXI_MMC_RINT_CARD_REMOVE		(0x1 << 31)
+#define SUNXI_MMC_RINT_INTERRUPT_ERROR_BIT      \
+	(SUNXI_MMC_RINT_RESP_ERROR |		\
+	 SUNXI_MMC_RINT_RESP_CRC_ERROR |	\
+	 SUNXI_MMC_RINT_DATA_CRC_ERROR |	\
+	 SUNXI_MMC_RINT_RESP_TIMEOUT |		\
+	 SUNXI_MMC_RINT_DATA_TIMEOUT |		\
+	 SUNXI_MMC_RINT_VOLTAGE_CHANGE_DONE |	\
+	 SUNXI_MMC_RINT_FIFO_RUN_ERROR |	\
+	 SUNXI_MMC_RINT_HARD_WARE_LOCKED |	\
+	 SUNXI_MMC_RINT_START_BIT_ERROR |	\
+	 SUNXI_MMC_RINT_END_BIT_ERROR) /* 0xbfc2 */
+#define SUNXI_MMC_RINT_INTERRUPT_DONE_BIT	\
+	(SUNXI_MMC_RINT_AUTO_COMMAND_DONE |	\
+	 SUNXI_MMC_RINT_DATA_OVER |		\
+	 SUNXI_MMC_RINT_COMMAND_DONE |		\
+	 SUNXI_MMC_RINT_VOLTAGE_CHANGE_DONE)
+
+#define SUNXI_MMC_STATUS_RXWL_FLAG		(0x1 << 0)
+#define SUNXI_MMC_STATUS_TXWL_FLAG		(0x1 << 1)
+#define SUNXI_MMC_STATUS_FIFO_EMPTY		(0x1 << 2)
+#define SUNXI_MMC_STATUS_FIFO_FULL		(0x1 << 3)
+#define SUNXI_MMC_STATUS_CARD_PRESENT		(0x1 << 8)
+#define SUNXI_MMC_STATUS_CARD_DATA_BUSY		(0x1 << 9)
+#define SUNXI_MMC_STATUS_DATA_FSM_BUSY		(0x1 << 10)
+
+#define SUNXI_MMC_NTSR_MODE_SEL_NEW		(0x1 << 31)
+
+#define SUNXI_MMC_IDMAC_RESET		(0x1 << 0)
+#define SUNXI_MMC_IDMAC_FIXBURST	(0x1 << 1)
+#define SUNXI_MMC_IDMAC_ENABLE		(0x1 << 7)
+
+#define SUNXI_MMC_IDIE_TXIRQ		(0x1 << 0)
+#define SUNXI_MMC_IDIE_RXIRQ		(0x1 << 1)
+
+#define SUNXI_MMC_COMMON_CLK_GATE		(1 << 16)
+#define SUNXI_MMC_COMMON_RESET			(1 << 18)
+
+struct mmc *sunxi_mmc_init(int sdc_no);
+#endif /* _SUNXI_MMC_H */
diff --git a/arch/arm/include/asm/arch-suniv/p2wi.h b/arch/arm/include/asm/arch-suniv/p2wi.h
new file mode 100644
index 00000000..2cf2d51c
--- /dev/null
+++ b/arch/arm/include/asm/arch-suniv/p2wi.h
@@ -0,0 +1,140 @@
+/*
+ * Sunxi platform Push-Push i2c register definition.
+ *
+ * (c) Copyright 2013 Oliver Schinagl <oliver@schinagl.nl>
+ * http://linux-sunxi.org
+ *
+ * (c)Copyright 2006-2013
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Berg Xing <bergxing@allwinnertech.com>
+ * Tom Cubie <tangliang@allwinnertech.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef _SUNXI_P2WI_H
+#define _SUNXI_P2WI_H
+
+#include <linux/types.h>
+
+#define P2WI_CTRL_RESET (0x1 << 0)
+#define P2WI_CTRL_IRQ_EN (0x1 << 1)
+#define P2WI_CTRL_TRANS_ABORT (0x1 << 6)
+#define P2WI_CTRL_TRANS_START (0x1 << 7)
+
+#define __P2WI_CC_CLK(n) (((n) & 0xff) << 0)
+#define P2WI_CC_CLK_MASK __P2WI_CC_CLK_DIV(0xff)
+#define __P2WI_CC_CLK_DIV(n) (((n) >> 1) - 1)
+#define P2WI_CC_CLK_DIV(n) \
+	__P2WI_CC_CLK(__P2WI_CC_CLK_DIV(n))
+#define P2WI_CC_SDA_OUT_DELAY(n) (((n) & 0x7) << 8)
+#define P2WI_CC_SDA_OUT_DELAY_MASK P2WI_CC_SDA_OUT_DELAY(0x7)
+
+#define P2WI_IRQ_TRANS_DONE (0x1 << 0)
+#define P2WI_IRQ_TRANS_ERR (0x1 << 1)
+#define P2WI_IRQ_LOAD_BUSY (0x1 << 2)
+
+#define P2WI_STAT_TRANS_DONE (0x1 << 0)
+#define P2WI_STAT_TRANS_ERR (0x1 << 1)
+#define P2WI_STAT_LOAD_BUSY (0x1 << 2)
+#define __P2WI_STAT_TRANS_ERR(n) (((n) & 0xff) << 8)
+#define P2WI_STAT_TRANS_ERR_MASK __P2WI_STAT_TRANS_ERR_ID(0xff)
+#define __P2WI_STAT_TRANS_ERR_BYTE_1 0x01
+#define __P2WI_STAT_TRANS_ERR_BYTE_2 0x02
+#define __P2WI_STAT_TRANS_ERR_BYTE_3 0x04
+#define __P2WI_STAT_TRANS_ERR_BYTE_4 0x08
+#define __P2WI_STAT_TRANS_ERR_BYTE_5 0x10
+#define __P2WI_STAT_TRANS_ERR_BYTE_6 0x20
+#define __P2WI_STAT_TRANS_ERR_BYTE_7 0x40
+#define __P2WI_STAT_TRANS_ERR_BYTE_8 0x80
+#define P2WI_STAT_TRANS_ERR_BYTE_1 \
+	__P2WI_STAT_TRANS_ERR(__P2WI_STAT_TRANS_ERR_BYTE_1)
+#define P2WI_STAT_TRANS_ERR_BYTE_2 \
+	__P2WI_STAT_TRANS_ERR(__P2WI_STAT_TRANS_ERR_BYTE_2)
+#define P2WI_STAT_TRANS_ERR_BYTE_3 \
+	__P2WI_STAT_TRANS_ERR(__P2WI_STAT_TRANS_ERR_BYTE_3)
+#define P2WI_STAT_TRANS_ERR_BYTE_4 \
+	__P2WI_STAT_TRANS_ERR(__P2WI_STAT_TRANS_ERR_BYTE_4)
+#define P2WI_STAT_TRANS_ERR_BYTE_5 \
+	__P2WI_STAT_TRANS_ERR(__P2WI_STAT_TRANS_ERR_BYTE_5)
+#define P2WI_STAT_TRANS_ERR_BYTE_6 \
+	__P2WI_STAT_TRANS_ERR(__P2WI_STAT_TRANS_ERR_BYTE_6)
+#define P2WI_STAT_TRANS_ERR_BYTE_7 \
+	__P2WI_STAT_TRANS_ERR(__P2WI_STAT_TRANS_ERR_BYTE_7)
+#define P2WI_STAT_TRANS_ERR_BYTE_8 \
+	__P2WI_STAT_TRANS_ERR(__P2WI_STAT_TRANS_ERR_BYTE_8)
+
+#define P2WI_DATADDR_BYTE_1(n) (((n) & 0xff) << 0)
+#define P2WI_DATADDR_BYTE_1_MASK P2WI_DATADDR_BYTE_1(0xff)
+#define P2WI_DATADDR_BYTE_2(n) (((n) & 0xff) << 8)
+#define P2WI_DATADDR_BYTE_2_MASK P2WI_DATADDR_BYTE_2(0xff)
+#define P2WI_DATADDR_BYTE_3(n) (((n) & 0xff) << 16)
+#define P2WI_DATADDR_BYTE_3_MASK P2WI_DATADDR_BYTE_3(0xff)
+#define P2WI_DATADDR_BYTE_4(n) (((n) & 0xff) << 24)
+#define P2WI_DATADDR_BYTE_4_MASK P2WI_DATADDR_BYTE_4(0xff)
+#define P2WI_DATADDR_BYTE_5(n) (((n) & 0xff) << 0)
+#define P2WI_DATADDR_BYTE_5_MASK P2WI_DATADDR_BYTE_5(0xff)
+#define P2WI_DATADDR_BYTE_6(n) (((n) & 0xff) << 8)
+#define P2WI_DATADDR_BYTE_6_MASK P2WI_DATADDR_BYTE_6(0xff)
+#define P2WI_DATADDR_BYTE_7(n) (((n) & 0xff) << 16)
+#define P2WI_DATADDR_BYTE_7_MASK P2WI_DATADDR_BYTE_7(0xff)
+#define P2WI_DATADDR_BYTE_8(n) (((n) & 0xff) << 24)
+#define P2WI_DATADDR_BYTE_8_MASK P2WI_DATADDR_BYTE_8(0xff)
+
+#define __P2WI_DATA_NUM_BYTES(n) (((n) & 0x7) << 0)
+#define P2WI_DATA_NUM_BYTES_MASK __P2WI_DATA_NUM_BYTES(0x7)
+#define P2WI_DATA_NUM_BYTES(n) __P2WI_DATA_NUM_BYTES((n) - 1)
+#define P2WI_DATA_NUM_BYTES_READ (0x1 << 4)
+
+#define P2WI_DATA_BYTE_1(n) (((n) & 0xff) << 0)
+#define P2WI_DATA_BYTE_1_MASK P2WI_DATA_BYTE_1(0xff)
+#define P2WI_DATA_BYTE_2(n) (((n) & 0xff) << 8)
+#define P2WI_DATA_BYTE_2_MASK P2WI_DATA_BYTE_2(0xff)
+#define P2WI_DATA_BYTE_3(n) (((n) & 0xff) << 16)
+#define P2WI_DATA_BYTE_3_MASK P2WI_DATA_BYTE_3(0xff)
+#define P2WI_DATA_BYTE_4(n) (((n) & 0xff) << 24)
+#define P2WI_DATA_BYTE_4_MASK P2WI_DATA_BYTE_4(0xff)
+#define P2WI_DATA_BYTE_5(n) (((n) & 0xff) << 0)
+#define P2WI_DATA_BYTE_5_MASK P2WI_DATA_BYTE_5(0xff)
+#define P2WI_DATA_BYTE_6(n) (((n) & 0xff) << 8)
+#define P2WI_DATA_BYTE_6_MASK P2WI_DATA_BYTE_6(0xff)
+#define P2WI_DATA_BYTE_7(n) (((n) & 0xff) << 16)
+#define P2WI_DATA_BYTE_7_MASK P2WI_DATA_BYTE_7(0xff)
+#define P2WI_DATA_BYTE_8(n) (((n) & 0xff) << 24)
+#define P2WI_DATA_BYTE_8_MASK P2WI_DATA_BYTE_8(0xff)
+
+#define P2WI_LINECTRL_SDA_CTRL_EN (0x1 << 0)
+#define P2WI_LINECTRL_SDA_OUT_HIGH (0x1 << 1)
+#define P2WI_LINECTRL_SCL_CTRL_EN (0x1 << 2)
+#define P2WI_LINECTRL_SCL_OUT_HIGH (0x1 << 3)
+#define P2WI_LINECTRL_SDA_STATE_HIGH (0x1 << 4)
+#define P2WI_LINECTRL_SCL_STATE_HIGH (0x1 << 5)
+
+#define P2WI_PM_DEV_ADDR(n) (((n) & 0xff) << 0)
+#define P2WI_PM_DEV_ADDR_MASK P2WI_PM_DEV_ADDR(0xff)
+#define P2WI_PM_CTRL_ADDR(n) (((n) & 0xff) << 8)
+#define P2WI_PM_CTRL_ADDR_MASK P2WI_PM_CTRL_ADDR(0xff)
+#define P2WI_PM_INIT_DATA(n) (((n) & 0xff) << 16)
+#define P2WI_PM_INIT_DATA_MASK P2WI_PM_INIT_DATA(0xff)
+#define P2WI_PM_INIT_SEND (0x1 << 31)
+
+struct sunxi_p2wi_reg {
+	u32 ctrl;	/* 0x00 control */
+	u32 cc;		/* 0x04 clock control */
+	u32 irq;	/* 0x08 interrupt */
+	u32 status;	/* 0x0c status */
+	u32 dataddr0;	/* 0x10 data address 0 */
+	u32 dataddr1;	/* 0x14 data address 1 */
+	u32 numbytes;	/* 0x18 num bytes */
+	u32 data0;	/* 0x1c data buffer 0 */
+	u32 data1;	/* 0x20 data buffer 1 */
+	u32 linectrl;	/* 0x24 line control */
+	u32 pm;		/* 0x28 power management */
+};
+
+void p2wi_init(void);
+int p2wi_change_to_p2wi_mode(u8 slave_addr, u8 ctrl_reg, u8 init_data);
+int p2wi_read(const u8 addr, u8 *data);
+int p2wi_write(const u8 addr, u8 data);
+
+#endif /* _SUNXI_P2WI_H */
diff --git a/arch/arm/include/asm/arch-suniv/pmic_bus.h b/arch/arm/include/asm/arch-suniv/pmic_bus.h
new file mode 100644
index 00000000..9c4372a8
--- /dev/null
+++ b/arch/arm/include/asm/arch-suniv/pmic_bus.h
@@ -0,0 +1,18 @@
+/*
+ * (C) Copyright 2015 Hans de Goede <hdegoede@redhat.com>
+ *
+ * Sunxi PMIC bus access helpers header
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef _SUNXI_PMIC_BUS_H
+#define _SUNXI_PMIS_BUS_H
+
+int pmic_bus_init(void);
+int pmic_bus_read(u8 reg, u8 *data);
+int pmic_bus_write(u8 reg, u8 data);
+int pmic_bus_setbits(u8 reg, u8 bits);
+int pmic_bus_clrbits(u8 reg, u8 bits);
+
+#endif
diff --git a/arch/arm/include/asm/arch-suniv/prcm.h b/arch/arm/include/asm/arch-suniv/prcm.h
new file mode 100644
index 00000000..ba4427c9
--- /dev/null
+++ b/arch/arm/include/asm/arch-suniv/prcm.h
@@ -0,0 +1,248 @@
+/*
+ * Sunxi A31 Power Management Unit register definition.
+ *
+ * (C) Copyright 2013 Oliver Schinagl <oliver@schinagl.nl>
+ * http://linux-sunxi.org
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Berg Xing <bergxing@allwinnertech.com>
+ * Tom Cubie <tangliang@allwinnertech.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef _SUNXI_PRCM_H
+#define _SUNXI_PRCM_H
+
+#define __PRCM_CPUS_CFG_PRE(n) (((n) & 0x3) << 4)
+#define PRCM_CPUS_CFG_PRE_MASK __PRCM_CPUS_CFG_PRE(0x3)
+#define __PRCM_CPUS_CFG_PRE_DIV(n) (((n) >> 1) - 1)
+#define PRCM_CPUS_CFG_PRE_DIV(n) \
+	__PRCM_CPUS_CFG_PRE(__PRCM_CPUS_CFG_CLK_PRE(n))
+#define __PRCM_CPUS_CFG_POST(n) (((n) & 0x1f) << 8)
+#define PRCM_CPUS_CFG_POST_MASK __PRCM_CPUS_CFG_POST(0x1f)
+#define __PRCM_CPUS_CFG_POST_DIV(n) ((n) - 1)
+#define PRCM_CPUS_CFG_POST_DIV(n) \
+	__PRCM_CPUS_CFG_POST_DIV(__PRCM_CPUS_CFG_POST_DIV(n))
+#define __PRCM_CPUS_CFG_CLK_SRC(n) (((n) & 0x3) << 16)
+#define PRCM_CPUS_CFG_CLK_SRC_MASK __PRCM_CPUS_CFG_CLK_SRC(0x3)
+#define __PRCM_CPUS_CFG_CLK_SRC_LOSC 0x0
+#define __PRCM_CPUS_CFG_CLK_SRC_HOSC 0x1
+#define __PRCM_CPUS_CFG_CLK_SRC_PLL6 0x2
+#define __PRCM_CPUS_CFG_CLK_SRC_PDIV 0x3
+#define PRCM_CPUS_CFG_CLK_SRC_LOSC \
+	__PRCM_CPUS_CFG_CLK_SRC(__PRCM_CPUS_CFG_CLK_SRC_LOSC)
+#define PRCM_CPUS_CFG_CLK_SRC_HOSC \
+	__PRCM_CPUS_CFG_CLK_SRC(__PRCM_CPUS_CFG_CLK_SRC_HOSC)
+#define PRCM_CPUS_CFG_CLK_SRC_PLL6 \
+	__PRCM_CPUS_CFG_CLK_SRC(__PRCM_CPUS_CFG_CLK_SRC_PLL6)
+#define PRCM_CPUS_CFG_CLK_SRC_PDIV \
+	__PRCM_CPUS_CFG_CLK_SRC(__PRCM_CPUS_CFG_CLK_SRC_PDIV)
+
+#define __PRCM_APB0_RATIO(n) (((n) & 0x3) << 0)
+#define PRCM_APB0_RATIO_DIV_MASK __PRCM_APB0_RATIO_DIV(0x3)
+#define __PRCM_APB0_RATIO_DIV(n) (((n) >> 1) - 1)
+#define PRCM_APB0_RATIO_DIV(n) \
+	__PRCM_APB0_RATIO(__PRCM_APB0_RATIO_DIV(n))
+
+#define PRCM_CPU_CFG_NEON_CLK_EN (0x1 << 0)
+#define PRCM_CPU_CFG_CPU_CLK_EN (0x1 << 1)
+
+#define PRCM_APB0_GATE_PIO (0x1 << 0)
+#define PRCM_APB0_GATE_IR (0x1 << 1)
+#define PRCM_APB0_GATE_TIMER01 (0x1 << 2)
+#define PRCM_APB0_GATE_P2WI (0x1 << 3)		/* sun6i */
+#define PRCM_APB0_GATE_RSB (0x1 << 3)		/* sun8i */
+#define PRCM_APB0_GATE_UART (0x1 << 4)
+#define PRCM_APB0_GATE_1WIRE (0x1 << 5)
+#define PRCM_APB0_GATE_I2C (0x1 << 6)
+
+#define PRCM_APB0_RESET_PIO (0x1 << 0)
+#define PRCM_APB0_RESET_IR (0x1 << 1)
+#define PRCM_APB0_RESET_TIMER01 (0x1 << 2)
+#define PRCM_APB0_RESET_P2WI (0x1 << 3)
+#define PRCM_APB0_RESET_UART (0x1 << 4)
+#define PRCM_APB0_RESET_1WIRE (0x1 << 5)
+#define PRCM_APB0_RESET_I2C (0x1 << 6)
+
+#define PRCM_PLL_CTRL_PLL_BIAS (0x1 << 0)
+#define PRCM_PLL_CTRL_HOSC_GAIN_ENH (0x1 << 1)
+#define __PRCM_PLL_CTRL_USB_CLK_SRC(n) (((n) & 0x3) << 4)
+#define PRCM_PLL_CTRL_USB_CLK_SRC_MASK \
+	__PRCM_PLL_CTRL_USB_CLK_SRC(0x3)
+#define __PRCM_PLL_CTRL_USB_CLK_0 0x0
+#define __PRCM_PLL_CTRL_USB_CLK_1 0x1
+#define __PRCM_PLL_CTRL_USB_CLK_2 0x2
+#define __PRCM_PLL_CTRL_USB_CLK_3 0x3
+#define PRCM_PLL_CTRL_USB_CLK_0 \
+	__PRCM_PLL_CTRL_USB_CLK_SRC(__PRCM_PLL_CTRL_USB_CLK_0)
+#define PRCM_PLL_CTRL_USB_CLK_1 \
+	__PRCM_PLL_CTRL_USB_CLK_SRC(__PRCM_PLL_CTRL_USB_CLK_1)
+#define PRCM_PLL_CTRL_USB_CLK_2 \
+	__PRCM_PLL_CTRL_USB_CLK_SRC(__PRCM_PLL_CTRL_USB_CLK_2)
+#define PRCM_PLL_CTRL_USB_CLK_3 \
+	__PRCM_PLL_CTRL_USB_CLK_SRC(__PRCM_PLL_CTRL_USB_CLK_3)
+#define __PRCM_PLL_CTRL_INT_PLL_IN_SEL(n) (((n) & 0x3) << 12)
+#define PRCM_PLL_CTRL_INT_PLL_IN_SEL_MASK \
+	__PRCM_PLL_CTRL_INT_PLL_IN_SEL(0x3)
+#define PRCM_PLL_CTRL_INT_PLL_IN_SEL(n) \
+	__PRCM_PLL_CTRL_INT_PLL_IN_SEL(n)
+#define __PRCM_PLL_CTRL_HOSC_CLK_SEL(n) (((n) & 0x3) << 20)
+#define PRCM_PLL_CTRL_HOSC_CLK_SEL_MASK \
+	__PRCM_PLL_CTRL_HOSC_CLK_SEL(0x3)
+#define __PRCM_PLL_CTRL_HOSC_CLK_0 0x0
+#define __PRCM_PLL_CTRL_HOSC_CLK_1 0x1
+#define __PRCM_PLL_CTRL_HOSC_CLK_2 0x2
+#define __PRCM_PLL_CTRL_HOSC_CLK_3 0x3
+#define PRCM_PLL_CTRL_HOSC_CLK_0 \
+	__PRCM_PLL_CTRL_HOSC_CLK_SEL(__PRCM_PLL_CTRL_HOSC_CLK_0)
+#define PRCM_PLL_CTRL_HOSC_CLK_1 \
+	__PRCM_PLL_CTRL_HOSC_CLK_SEL(__PRCM_PLL_CTRL_HOSC_CLK_1)
+#define PRCM_PLL_CTRL_HOSC_CLK_2 \
+	__PRCM_PLL_CTRL_HOSC_CLK_SEL(__PRCM_PLL_CTRL_HOSC_CLK_2)
+#define PRCM_PLL_CTRL_HOSC_CLK_3 \
+	__PRCM_PLL_CTRL_HOSC_CLK_SEL(__PRCM_PLL_CTRL_HOSC_CLK_3)
+#define PRCM_PLL_CTRL_PLL_TST_SRC_EXT (0x1 << 24)
+#define PRCM_PLL_CTRL_LDO_DIGITAL_EN (0x1 << 0)
+#define PRCM_PLL_CTRL_LDO_ANALOG_EN (0x1 << 1)
+#define PRCM_PLL_CTRL_EXT_OSC_EN (0x1 << 2)
+#define PRCM_PLL_CTRL_CLK_TST_EN (0x1 << 3)
+#define PRCM_PLL_CTRL_IN_PWR_HIGH (0x1 << 15) /* 3.3 for hi 2.5 for lo */
+#define __PRCM_PLL_CTRL_VDD_LDO_OUT(n) (((n) & 0x7) << 16)
+#define PRCM_PLL_CTRL_LDO_OUT_MASK \
+	__PRCM_PLL_CTRL_LDO_OUT(0x7)
+/* When using the low voltage 20 mV steps, and high voltage 30 mV steps */
+#define PRCM_PLL_CTRL_LDO_OUT_L(n) \
+	__PRCM_PLL_CTRL_VDD_LDO_OUT((((n) - 1000) / 20) & 0x7)
+#define PRCM_PLL_CTRL_LDO_OUT_H(n) \
+	__PRCM_PLL_CTRL_VDD_LDO_OUT((((n) - 1160) / 30) & 0x7)
+#define PRCM_PLL_CTRL_LDO_OUT_LV(n) \
+	__PRCM_PLL_CTRL_VDD_LDO_OUT((((n) & 0x7) * 20) + 1000)
+#define PRCM_PLL_CTRL_LDO_OUT_HV(n) \
+	__PRCM_PLL_CTRL_VDD_LDO_OUT((((n) & 0x7) * 30) + 1160)
+#define PRCM_PLL_CTRL_LDO_KEY (0xa7 << 24)
+#define PRCM_PLL_CTRL_LDO_KEY_MASK (0xff << 24)
+
+#define PRCM_CLK_1WIRE_GATE (0x1 << 31)
+
+#define __PRCM_CLK_MOD0_M(n) (((n) & 0xf) << 0)
+#define PRCM_CLK_MOD0_M_MASK __PRCM_CLK_MOD0_M(0xf)
+#define __PRCM_CLK_MOD0_M_X(n) (n - 1)
+#define PRCM_CLK_MOD0_M(n) __PRCM_CLK_MOD0_M(__PRCM_CLK_MOD0_M_X(n))
+#define PRCM_CLK_MOD0_OUT_PHASE(n) (((n) & 0x7) << 8)
+#define PRCM_CLK_MOD0_OUT_PHASE_MASK(n) PRCM_CLK_MOD0_OUT_PHASE(0x7)
+#define _PRCM_CLK_MOD0_N(n) (((n) & 0x3) << 16)
+#define PRCM_CLK_MOD0_N_MASK __PRCM_CLK_MOD_N(0x3)
+#define __PRCM_CLK_MOD0_N_X(n) (((n) >> 1) - 1)
+#define PRCM_CLK_MOD0_N(n) __PRCM_CLK_MOD0_N(__PRCM_CLK_MOD0_N_X(n))
+#define PRCM_CLK_MOD0_SMPL_PHASE(n) (((n) & 0x7) << 20)
+#define PRCM_CLK_MOD0_SMPL_PHASE_MASK PRCM_CLK_MOD0_SMPL_PHASE(0x7)
+#define PRCM_CLK_MOD0_SRC_SEL(n) (((n) & 0x7) << 24)
+#define PRCM_CLK_MOD0_SRC_SEL_MASK PRCM_CLK_MOD0_SRC_SEL(0x7)
+#define PRCM_CLK_MOD0_GATE_EN (0x1 << 31)
+
+#define PRCM_APB0_RESET_PIO (0x1 << 0)
+#define PRCM_APB0_RESET_IR (0x1 << 1)
+#define PRCM_APB0_RESET_TIMER01 (0x1 << 2)
+#define PRCM_APB0_RESET_P2WI (0x1 << 3)
+#define PRCM_APB0_RESET_UART (0x1 << 4)
+#define PRCM_APB0_RESET_1WIRE (0x1 << 5)
+#define PRCM_APB0_RESET_I2C (0x1 << 6)
+
+#define __PRCM_CLK_OUTD_M(n) (((n) & 0x7) << 8)
+#define PRCM_CLK_OUTD_M_MASK __PRCM_CLK_OUTD_M(0x7)
+#define __PRCM_CLK_OUTD_M_X() ((n) - 1)
+#define PRCM_CLK_OUTD_M(n) __PRCM_CLK_OUTD_M(__PRCM_CLK_OUTD_M_X(n))
+#define __PRCM_CLK_OUTD_N(n) (((n) & 0x7) << 20)
+#define PRCM_CLK_OUTD_N_MASK __PRCM_CLK_OUTD_N(0x7)
+#define __PRCM_CLK_OUTD_N_X(n) (((n) >> 1) - 1)
+#define PRCM_CLK_OUTD_N(n) __PRCM_CLK_OUTD_N(__PRCM_CLK_OUTD_N_X(n)
+#define __PRCM_CLK_OUTD_SRC_SEL(n) (((n) & 0x3) << 24)
+#define PRCM_CLK_OUTD_SRC_SEL_MASK __PRCM_CLK_OUTD_SRC_SEL(0x3)
+#define __PRCM_CLK_OUTD_SRC_LOSC2 0x0
+#define __PRCM_CLK_OUTD_SRC_LOSC 0x1
+#define __PRCM_CLK_OUTD_SRC_HOSC 0x2
+#define __PRCM_CLK_OUTD_SRC_ERR 0x3
+#define PRCM_CLK_OUTD_SRC_LOSC2 \
+#deifne __PRCM_CLK_OUTD_SRC_SEL(__PRCM_CLK_OUTD_SRC_LOSC2)
+#define PRCM_CLK_OUTD_SRC_LOSC \
+#deifne __PRCM_CLK_OUTD_SRC_SEL(__PRCM_CLK_OUTD_SRC_LOSC)
+#define PRCM_CLK_OUTD_SRC_HOSC \
+#deifne __PRCM_CLK_OUTD_SRC_SEL(__PRCM_CLK_OUTD_SRC_HOSC)
+#define PRCM_CLK_OUTD_SRC_ERR \
+#deifne __PRCM_CLK_OUTD_SRC_SEL(__PRCM_CLK_OUTD_SRC_ERR)
+#define PRCM_CLK_OUTD_EN (0x1 << 31)
+
+#define PRCM_CPU0_PWROFF (0x1 << 0)
+#define PRCM_CPU1_PWROFF (0x1 << 1)
+#define PRCM_CPU2_PWROFF (0x1 << 2)
+#define PRCM_CPU3_PWROFF (0x1 << 3)
+#define PRCM_CPU_ALL_PWROFF (0xf << 0)
+
+#define PRCM_VDD_SYS_DRAM_CH0_PAD_HOLD_PWROFF (0x1 << 0)
+#define PRCM_VDD_SYS_DRAM_CH1_PAD_HOLD_PWROFF (0x1 << 1)
+#define PRCM_VDD_SYS_AVCC_A_PWROFF (0x1 << 2)
+#define PRCM_VDD_SYS_CPU0_VDD_PWROFF (0x1 << 3)
+
+#define PRCM_VDD_GPU_PWROFF (0x1 << 0)
+
+#define PRCM_VDD_SYS_RESET (0x1 << 0)
+
+#define PRCM_CPU1_PWR_CLAMP(n) (((n) & 0xff) << 0)
+#define PRCM_CPU1_PWR_CLAMP_MASK PRCM_CPU1_PWR_CLAMP(0xff)
+
+#define PRCM_CPU2_PWR_CLAMP(n) (((n) & 0xff) << 0)
+#define PRCM_CPU2_PWR_CLAMP_MASK PRCM_CPU2_PWR_CLAMP(0xff)
+
+#define PRCM_CPU3_PWR_CLAMP(n) (((n) & 0xff) << 0)
+#define PRCM_CPU3_PWR_CLAMP_MASK PRCM_CPU3_PWR_CLAMP(0xff)
+
+#define PRCM_SEC_SWITCH_APB0_CLK_NONSEC (0x1 << 0)
+#define PRCM_SEC_SWITCH_PLL_CFG_NONSEC (0x1 << 1)
+#define PRCM_SEC_SWITCH_PWR_GATE_NONSEC (0x1 << 2)
+
+#ifndef __ASSEMBLY__
+#include <linux/compiler.h>
+
+struct __packed sunxi_prcm_reg {
+	u32 cpus_cfg;		/* 0x000 */
+	u8 res0[0x8];		/* 0x004 */
+	u32 apb0_ratio;		/* 0x00c */
+	u32 cpu0_cfg;		/* 0x010 */
+	u32 cpu1_cfg;		/* 0x014 */
+	u32 cpu2_cfg;		/* 0x018 */
+	u32 cpu3_cfg;		/* 0x01c */
+	u8 res1[0x8];		/* 0x020 */
+	u32 apb0_gate;		/* 0x028 */
+	u8 res2[0x14];		/* 0x02c */
+	u32 pll_ctrl0;		/* 0x040 */
+	u32 pll_ctrl1;		/* 0x044 */
+	u8 res3[0x8];		/* 0x048 */
+	u32 clk_1wire;		/* 0x050 */
+	u32 clk_ir;		/* 0x054 */
+	u8 res4[0x58];		/* 0x058 */
+	u32 apb0_reset;		/* 0x0b0 */
+	u8 res5[0x3c];		/* 0x0b4 */
+	u32 clk_outd;		/* 0x0f0 */
+	u8 res6[0xc];		/* 0x0f4 */
+	u32 cpu_pwroff;		/* 0x100 */
+	u8 res7[0xc];		/* 0x104 */
+	u32 vdd_sys_pwroff;	/* 0x110 */
+	u8 res8[0x4];		/* 0x114 */
+	u32 gpu_pwroff;		/* 0x118 */
+	u8 res9[0x4];		/* 0x11c */
+	u32 vdd_pwr_reset;	/* 0x120 */
+	u8 res10[0x1c];		/* 0x124 */
+	u32 cpu_pwr_clamp[4];	/* 0x140 but first one is actually unused */
+	u8 res11[0x30];		/* 0x150 */
+	u32 dram_pwr;		/* 0x180 */
+	u8 res12[0xc];		/* 0x184 */
+	u32 dram_tst;		/* 0x190 */
+	u8 res13[0x3c];		/* 0x194 */
+	u32 prcm_sec_switch;	/* 0x1d0 */
+};
+
+void prcm_apb0_enable(u32 flags);
+void prcm_apb0_disable(u32 flags);
+
+#endif /* __ASSEMBLY__ */
+#endif /* _PRCM_H */
diff --git a/arch/arm/include/asm/arch-suniv/pwm.h b/arch/arm/include/asm/arch-suniv/pwm.h
new file mode 100644
index 00000000..5884b5db
--- /dev/null
+++ b/arch/arm/include/asm/arch-suniv/pwm.h
@@ -0,0 +1,34 @@
+/*
+ * (C) Copyright 2016 Hans de Goede <hdegoede@redhat.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef _SUNXI_PWM_H
+#define _SUNXI_PWM_H
+
+#define SUNXI_PWM_CTRL_REG		(SUNXI_PWM_BASE + 0)
+#define SUNXI_PWM_CH0_PERIOD		(SUNXI_PWM_BASE + 4)
+
+#define SUNXI_PWM_CTRL_PRESCALE0(x)	((x) & 0xf)
+#define SUNXI_PWM_CTRL_ENABLE0		(0x5 << 4)
+#define SUNXI_PWM_CTRL_POLARITY0(x)	((x) << 5)
+
+#define SUNXI_PWM_PERIOD_80PCT		0x04af03c0
+
+#if defined CONFIG_MACH_SUN4I || defined CONFIG_MACH_SUN5I
+#define SUNXI_PWM_PIN0			SUNXI_GPB(2)
+#define SUNXI_PWM_MUX			SUN4I_GPB_PWM
+#endif
+
+#if defined CONFIG_MACH_SUN6I
+#define SUNXI_PWM_PIN0			SUNXI_GPH(13)
+#define SUNXI_PWM_MUX			SUN6I_GPH_PWM
+#endif
+
+#if defined CONFIG_MACH_SUN8I_A23 || defined CONFIG_MACH_SUN8I_A33
+#define SUNXI_PWM_PIN0			SUNXI_GPH(0)
+#define SUNXI_PWM_MUX			SUN8I_GPH_PWM
+#endif
+
+#endif
diff --git a/arch/arm/include/asm/arch-suniv/rsb.h b/arch/arm/include/asm/arch-suniv/rsb.h
new file mode 100644
index 00000000..a8934667
--- /dev/null
+++ b/arch/arm/include/asm/arch-suniv/rsb.h
@@ -0,0 +1,55 @@
+/*
+ * (C) Copyright 2014 Hans de Goede <hdegoede@redhat.com>
+ *
+ * Based on allwinner u-boot sources rsb code which is:
+ * (C) Copyright 2007-2013
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * lixiang <lixiang@allwinnertech.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __SUNXI_RSB_H
+#define __SUNXI_RSB_H
+
+#include <common.h>
+#include <asm/io.h>
+
+struct sunxi_rsb_reg {
+	u32 ctrl;	/* 0x00 */
+	u32 ccr;	/* 0x04 */
+	u32 inte;	/* 0x08 */
+	u32 stat;	/* 0x0c */
+	u32 addr;	/* 0x10 */
+	u8 res0[8];	/* 0x14 */
+	u32 data;	/* 0x1c */
+	u8 res1[4];	/* 0x20 */
+	u32 lcr;	/* 0x24 */
+	u32 dmcr;	/* 0x28 */
+	u32 cmd;	/* 0x2c */
+	u32 devaddr;	/* 0x30 */
+};
+
+#define RSB_CTRL_SOFT_RST		(1 << 0)
+#define RSB_CTRL_START_TRANS		(1 << 7)
+
+#define RSB_STAT_TOVER_INT		(1 << 0)
+#define RSB_STAT_TERR_INT		(1 << 1)
+#define RSB_STAT_LBSY_INT		(1 << 2)
+
+#define RSB_DMCR_DEVICE_MODE_DATA	0x7c3e00
+#define RSB_DMCR_DEVICE_MODE_START	(1 << 31)
+
+#define RSB_CMD_BYTE_WRITE		0x4e
+#define RSB_CMD_BYTE_READ		0x8b
+#define RSB_CMD_SET_RTSADDR		0xe8
+
+#define RSB_DEVADDR_RUNTIME_ADDR(x)	((x) << 16)
+#define RSB_DEVADDR_DEVICE_ADDR(x)	((x) << 0)
+
+int rsb_init(void);
+int rsb_set_device_address(u16 device_addr, u16 runtime_addr);
+int rsb_write(const u16 runtime_device_addr, const u8 reg_addr, u8 data);
+int rsb_read(const u16 runtime_device_addr, const u8 reg_addr, u8 *data);
+
+#endif
diff --git a/arch/arm/include/asm/arch-suniv/spi.h b/arch/arm/include/asm/arch-suniv/spi.h
new file mode 100644
index 00000000..66301b24
--- /dev/null
+++ b/arch/arm/include/asm/arch-suniv/spi.h
@@ -0,0 +1,29 @@
+/*
+ * (C) Copyright 2017 Whitebox Systems / Northend Systems B.V.
+ * S.J.R. van Schaik <stephan@whiteboxsystems.nl>
+ * M.B.W. Wajer <merlijn@whiteboxsystems.nl>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef _SUNXI_SPI_H
+#define _SUNXI_SPI_H
+
+#if defined(CONFIG_MACH_SUN6I) || defined(CONFIG_MACH_SUN8I) || \
+	defined(CONFIG_MACH_SUN9I) || defined(CONFIG_MACH_SUN50I)
+#include <asm/arch/spi_sun6i.h>
+#else
+#include <asm/arch/spi_sun4i.h>
+#endif
+
+#define SUNXI_SPI_BURST_CNT(cnt)	((cnt) & 0xffffff)
+#define SUNXI_SPI_XMIT_CNT(cnt)		((cnt) & 0xffffff)
+
+#define SUNXI_SPI_CLK_CTL_CDR2_MASK	0xff
+#define SUNXI_SPI_CLK_CTL_CDR2(div)	((div) & SUNXI_SPI_CLK_CTL_CDR2_MASK)
+#define SUNXI_SPI_CLK_CTL_CDR1_MASK	0xf
+#define SUNXI_SPI_CLK_CTL_CDR1(div)		\
+	(((div) & SUNXI_SPI_CLK_CTL_CDR1_MASK) << 8)
+#define SUNXI_SPI_CLK_CTL_DRS		BIT(12)
+
+#endif /* _SUNXI_SPI_H */
diff --git a/arch/arm/include/asm/arch-suniv/spi_sun4i.h b/arch/arm/include/asm/arch-suniv/spi_sun4i.h
new file mode 100644
index 00000000..c9451965
--- /dev/null
+++ b/arch/arm/include/asm/arch-suniv/spi_sun4i.h
@@ -0,0 +1,53 @@
+/*
+ * (C) Copyright 2017 Whitebox Systems / Northend Systems B.V.
+ * S.J.R. van Schaik <stephan@whiteboxsystems.nl>
+ * M.B.W. Wajer <merlijn@whiteboxsystems.nl>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef _SUNXI_SPI_SUN4I_H
+#define _SUNXI_SPI_SUN4I_H
+
+struct sunxi_spi_regs {
+	uint32_t rx_data;	/* 0x00 */
+	uint32_t tx_data;	/* 0x04 */
+	union {
+		uint32_t glb_ctl;
+		uint32_t xfer_ctl;
+		uint32_t fifo_ctl;
+		uint32_t burst_ctl;
+	};			/* 0x08 */
+	uint32_t int_ctl;	/* 0x0c */
+	uint32_t int_sta;	/* 0x10 */
+	uint32_t dma_ctl;	/* 0x14 */
+	uint32_t wait;		/* 0x18 */
+	uint32_t clk_ctl;	/* 0x1c */
+	uint32_t burst_cnt;	/* 0x20 */
+	uint32_t xmit_cnt;	/* 0x24 */
+	uint32_t fifo_sta;	/* 0x28 */
+};
+
+#define SUNXI_SPI_CTL_SRST		0
+
+#define SUNXI_SPI_CTL_ENABLE		BIT(0)
+#define SUNXI_SPI_CTL_MASTER		BIT(1)
+#define SUNXI_SPI_CTL_CPHA		BIT(2)
+#define SUNXI_SPI_CTL_CPOL		BIT(3)
+#define SUNXI_SPI_CTL_CS_ACTIVE_LOW	BIT(4)
+#define SUNXI_SPI_CTL_TF_RST		BIT(8)
+#define SUNXI_SPI_CTL_RF_RST		BIT(9)
+#define SUNXI_SPI_CTL_XCH		BIT(10)
+#define SUNXI_SPI_CTL_CS_MASK		0x3000
+#define SUNXI_SPI_CTL_CS(cs)		(((cs) << 12) & SUNXI_SPI_CTL_CS_MASK)
+#define SUNXI_SPI_CTL_DHB		BIT(15)
+#define SUNXI_SPI_CTL_CS_MANUAL		BIT(16)
+#define SUNXI_SPI_CTL_CS_LEVEL		BIT(17)
+#define SUNXI_SPI_CTL_TP		BIT(18)
+
+#define SUNXI_SPI_FIFO_RF_CNT_MASK	0x7f
+#define SUNXI_SPI_FIFO_RF_CNT_BITS	0
+#define SUNXI_SPI_FIFO_TF_CNT_MASK	0x7f
+#define SUNXI_SPI_FIFO_TF_CNT_BITS	16
+
+#endif /* _SUNXI_SPI_SUN4I_H */
diff --git a/arch/arm/include/asm/arch-suniv/spi_sun6i.h b/arch/arm/include/asm/arch-suniv/spi_sun6i.h
new file mode 100644
index 00000000..d9241848
--- /dev/null
+++ b/arch/arm/include/asm/arch-suniv/spi_sun6i.h
@@ -0,0 +1,56 @@
+/*
+ * (C) Copyright 2017 Whitebox Systems / Northend Systems B.V.
+ * S.J.R. van Schaik <stephan@whiteboxsystems.nl>
+ * M.B.W. Wajer <merlijn@whiteboxsystems.nl>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef _SUNXI_SPI_SUN6I_H
+#define _SUNXI_SPI_SUN6I_H
+
+struct sunxi_spi_regs {
+	uint32_t unused0[1];
+	uint32_t glb_ctl;	/* 0x04 */
+	uint32_t xfer_ctl;	/* 0x08 */
+	uint32_t unused1[1];
+	uint32_t int_ctl;	/* 0x10 */
+	uint32_t int_sta;	/* 0x14 */
+	uint32_t fifo_ctl;	/* 0x18 */
+	uint32_t fifo_sta;	/* 0x1c */
+	uint32_t wait;		/* 0x20 */
+	uint32_t clk_ctl;	/* 0x24 */
+	uint32_t unused2[2];
+	uint32_t burst_cnt;	/* 0x30 */
+	uint32_t xmit_cnt;	/* 0x34 */
+	uint32_t burst_ctl;	/* 0x38 */
+	uint32_t unused3[113];
+	uint32_t tx_data;	/* 0x200 */
+	uint32_t unused4[63];
+	uint32_t rx_data;	/* 0x300 */
+};
+
+#define SUNXI_SPI_CTL_ENABLE		BIT(0)
+#define SUNXI_SPI_CTL_MASTER		BIT(1)
+#define SUNXI_SPI_CTL_TP		BIT(7)
+#define SUNXI_SPI_CTL_SRST		BIT(31)
+
+#define SUNXI_SPI_CTL_CPHA		BIT(0)
+#define SUNXI_SPI_CTL_CPOL		BIT(1)
+#define SUNXI_SPI_CTL_CS_ACTIVE_LOW	BIT(2)
+#define SUNXI_SPI_CTL_CS_MASK		0x30
+#define SUNXI_SPI_CTL_CS(cs)		(((cs) << 4) & SUNXI_SPI_CTL_CS_MASK)
+#define SUNXI_SPI_CTL_CS_MANUAL		BIT(6)
+#define SUNXI_SPI_CTL_CS_LEVEL		BIT(7)
+#define SUNXI_SPI_CTL_DHB		BIT(8)
+#define SUNXI_SPI_CTL_XCH		BIT(31)
+
+#define SUNXI_SPI_CTL_RF_RST		BIT(15)
+#define SUNXI_SPI_CTL_TF_RST		BIT(31)
+
+#define SUNXI_SPI_FIFO_RF_CNT_MASK	0x7f
+#define SUNXI_SPI_FIFO_RF_CNT_BITS	0
+#define SUNXI_SPI_FIFO_TF_CNT_MASK	0x7f
+#define SUNXI_SPI_FIFO_TF_CNT_BITS	16
+
+#endif /* _SUNXI_SPI_SUN6I_H */
diff --git a/arch/arm/include/asm/arch-suniv/spl.h b/arch/arm/include/asm/arch-suniv/spl.h
new file mode 100644
index 00000000..a70b1797
--- /dev/null
+++ b/arch/arm/include/asm/arch-suniv/spl.h
@@ -0,0 +1,83 @@
+/*
+ * (C) Copyright 2007-2011
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Tom Cubie <tangliang@allwinnertech.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+#ifndef	_ASM_ARCH_SPL_H_
+#define	_ASM_ARCH_SPL_H_
+
+#define BOOT0_MAGIC		"eGON.BT0"
+#define SPL_SIGNATURE		"SPL" /* marks "sunxi" SPL header */
+#define SPL_HEADER_VERSION	2
+
+#ifdef CONFIG_SUNXI_HIGH_SRAM
+#define SPL_ADDR		0x10000
+#else
+#define SPL_ADDR		0x0
+#endif
+
+/* The low 8-bits of the 'boot_media' field in the SPL header */
+#define SUNXI_BOOTED_FROM_MMC0	0
+#define SUNXI_BOOTED_FROM_NAND	1
+#define SUNXI_BOOTED_FROM_MMC2	2
+#define SUNXI_BOOTED_FROM_SPI	3
+
+/* boot head definition from sun4i boot code */
+struct boot_file_head {
+	uint32_t b_instruction;	/* one intruction jumping to real code */
+	uint8_t magic[8];	/* ="eGON.BT0" or "eGON.BT1", not C-style str */
+	uint32_t check_sum;	/* generated by PC */
+	uint32_t length;	/* generated by PC */
+	/*
+	 * We use a simplified header, only filling in what is needed
+	 * by the boot ROM. To be compatible with Allwinner tools we
+	 * would need to implement the proper fields here instead of
+	 * padding.
+	 *
+	 * Actually we want the ability to recognize our "sunxi" variant
+	 * of the SPL. To do so, let's place a special signature into the
+	 * "pub_head_size" field. We can reasonably expect Allwinner's
+	 * boot0 to always have the upper 16 bits of this set to 0 (after
+	 * all the value shouldn't be larger than the limit imposed by
+	 * SRAM size).
+	 * If the signature is present (at 0x14), then we know it's safe
+	 * to use the remaining 8 bytes (at 0x18) for our own purposes.
+	 * (E.g. sunxi-tools "fel" utility can pass information there.)
+	 */
+	union {
+		uint32_t pub_head_size;
+		uint8_t spl_signature[4];
+	};
+	uint32_t fel_script_address;
+	/*
+	 * If the fel_uEnv_length member below is set to a non-zero value,
+	 * it specifies the size (byte count) of data at fel_script_address.
+	 * At the same time this indicates that the data is in uEnv.txt
+	 * compatible format, ready to be imported via "env import -t".
+	 */
+	uint32_t fel_uEnv_length;
+	/*
+	 * Offset of an ASCIIZ string (relative to the SPL header), which
+	 * contains the default device tree name (CONFIG_DEFAULT_DEVICE_TREE).
+	 * This is optional and may be set to NULL. Is intended to be used
+	 * by flash programming tools for providing nice informative messages
+	 * to the users.
+	 */
+	uint32_t dt_name_offset;
+	uint32_t reserved1;
+	uint32_t boot_media;		/* written here by the boot ROM */
+	/* A padding area (may be used for storing text strings) */
+	uint32_t string_pool[13];
+	/* The header must be a multiple of 32 bytes (for VBAR alignment) */
+};
+
+/* Compile time check to assure proper alignment of structure */
+typedef char boot_file_head_not_multiple_of_32[1 - 2*(sizeof(struct boot_file_head) % 32)];
+
+#define is_boot0_magic(addr)	(memcmp((void *)addr, BOOT0_MAGIC, 8) == 0)
+
+uint32_t sunxi_get_boot_device(void);
+
+#endif
diff --git a/arch/arm/include/asm/arch-suniv/sys_proto.h b/arch/arm/include/asm/arch-suniv/sys_proto.h
new file mode 100644
index 00000000..096510b7
--- /dev/null
+++ b/arch/arm/include/asm/arch-suniv/sys_proto.h
@@ -0,0 +1,33 @@
+/*
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Tom Cubie <tangliang@allwinnertech.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef _SYS_PROTO_H_
+#define _SYS_PROTO_H_
+
+#include <linux/types.h>
+
+void sdelay(unsigned long);
+
+/* return_to_fel() - Return to BROM from SPL
+ *
+ * This returns back into the BROM after U-Boot SPL has performed its initial
+ * init. It uses the provided lr and sp to do so.
+ *
+ * @lr:		BROM link register value (return address)
+ * @sp:		BROM stack pointer
+ */
+void return_to_fel(uint32_t lr, uint32_t sp);
+
+/* Board / SoC level designware gmac init */
+#if !defined CONFIG_SPL_BUILD && defined CONFIG_SUN7I_GMAC
+void eth_init_board(void);
+#else
+static inline void eth_init_board(void) {}
+#endif
+
+#endif
diff --git a/arch/arm/include/asm/arch-suniv/timer.h b/arch/arm/include/asm/arch-suniv/timer.h
new file mode 100644
index 00000000..ccdf9425
--- /dev/null
+++ b/arch/arm/include/asm/arch-suniv/timer.h
@@ -0,0 +1,88 @@
+/*
+ * (C) Copyright 2007-2011
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Tom Cubie <tangliang@allwinnertech.com>
+ *
+ * Configuration settings for the Allwinner A10-evb board.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef _SUNXI_TIMER_H_
+#define _SUNXI_TIMER_H_
+
+#ifndef __ASSEMBLY__
+
+#include <linux/types.h>
+#include <asm/arch/watchdog.h>
+
+/* General purpose timer */
+struct sunxi_timer {
+	u32 ctl;
+	u32 inter;
+	u32 val;
+	u8 res[4];
+};
+
+/* Audio video sync*/
+struct sunxi_avs {
+	u32 ctl;		/* 0x80 */
+	u32 cnt0;		/* 0x84 */
+	u32 cnt1;		/* 0x88 */
+	u32 div;		/* 0x8c */
+};
+
+/* 64 bit counter */
+struct sunxi_64cnt {
+	u32 ctl;		/* 0xa0 */
+	u32 lo;			/* 0xa4 */
+	u32 hi;			/* 0xa8 */
+};
+
+/* Rtc */
+struct sunxi_rtc {
+	u32 ctl;		/* 0x100 */
+	u32 yymmdd;		/* 0x104 */
+	u32 hhmmss;		/* 0x108 */
+};
+
+/* Alarm */
+struct sunxi_alarm {
+	u32 ddhhmmss;		/* 0x10c */
+	u32 hhmmss;		/* 0x110 */
+	u32 en;			/* 0x114 */
+	u32 irqen;		/* 0x118 */
+	u32 irqsta;		/* 0x11c */
+};
+
+/* Timer general purpose register */
+struct sunxi_tgp {
+	u32 tgpd;
+};
+
+struct sunxi_timer_reg {
+	u32 tirqen;		/* 0x00 */
+	u32 tirqsta;		/* 0x04 */
+	u8 res1[8];
+	struct sunxi_timer timer[6];	/* We have 6 timers */
+	u8 res2[16];
+	struct sunxi_avs avs;
+#if defined(CONFIG_SUNXI_GEN_SUN4I) || defined(CONFIG_MACH_SUN8I_R40)
+	struct sunxi_wdog wdog;	/* 0x90 */
+	/* XXX the following is not accurate for sun5i/sun7i */
+	struct sunxi_64cnt cnt64;	/* 0xa0 */
+	u8 res4[0x58];
+	struct sunxi_rtc rtc;
+	struct sunxi_alarm alarm;
+	struct sunxi_tgp tgp[4];
+	u8 res5[8];
+	u32 cpu_cfg;
+#elif defined(CONFIG_SUNXI_GEN_SUN6I)
+	u8 res3[16];
+	struct sunxi_wdog wdog[5];	/* We have 5 watchdogs */
+#endif
+};
+
+#endif /* __ASSEMBLY__ */
+
+#endif
diff --git a/arch/arm/include/asm/arch-suniv/tve.h b/arch/arm/include/asm/arch-suniv/tve.h
new file mode 100644
index 00000000..2625aebc
--- /dev/null
+++ b/arch/arm/include/asm/arch-suniv/tve.h
@@ -0,0 +1,224 @@
+/*
+ * Sunxi TV encoder register and constant defines
+ *
+ * (C) Copyright 2014 Hans de Goede <hdegoede@redhat.com>
+ * (C) Copyright 2017 Jernej Skrabec <jernej.skrabec@siol.net>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef _TVE_H
+#define _TVE_H
+
+enum tve_mode {
+	tve_mode_vga,
+	tve_mode_composite_pal,
+	tve_mode_composite_ntsc,
+	tve_mode_composite_pal_m,
+	tve_mode_composite_pal_nc,
+};
+
+/*
+ * This is based on the A10s User Manual, and the A10s only supports
+ * composite video and not vga like the A10 / A20 does, still other
+ * than the removed vga out capability the tvencoder seems to be the same.
+ * "unknown#" registers are registers which are used in the A10 kernel code,
+ * but not documented in the A10s User Manual.
+ */
+struct sunxi_tve_reg {
+	u32 gctrl;			/* 0x000 */
+	u32 cfg0;			/* 0x004 */
+	u32 dac_cfg0;			/* 0x008 */
+	u32 filter;			/* 0x00c */
+	u32 chroma_freq;		/* 0x010 */
+	u32 porch_num;			/* 0x014 */
+	u32 unknown0;			/* 0x018 */
+	u32 line_num;			/* 0x01c */
+	u32 blank_black_level;		/* 0x020 */
+	u32 unknown1;			/* 0x024, seems to be 1 byte per dac */
+	u8 res0[0x08];			/* 0x028 */
+	u32 auto_detect_en;		/* 0x030 */
+	u32 auto_detect_int_status;	/* 0x034 */
+	u32 auto_detect_status;		/* 0x038 */
+	u32 auto_detect_debounce;	/* 0x03c */
+	u32 csc_reg0;			/* 0x040 */
+	u32 csc_reg1;			/* 0x044 */
+	u32 csc_reg2;			/* 0x048 */
+	u32 csc_reg3;			/* 0x04c */
+	u8 res1[0xb0];			/* 0x050 */
+	u32 color_burst;		/* 0x100 */
+	u32 vsync_num;			/* 0x104 */
+	u32 notch_freq;			/* 0x108 */
+	u32 cbr_level;			/* 0x10c */
+	u32 burst_phase;		/* 0x110 */
+	u32 burst_width;		/* 0x114 */
+	u32 unknown2;			/* 0x118 */
+	u32 sync_vbi_level;		/* 0x11c */
+	u32 white_level;		/* 0x120 */
+	u32 active_num;			/* 0x124 */
+	u32 chroma_bw_gain;		/* 0x128 */
+	u32 notch_width;		/* 0x12c */
+	u32 resync_num;			/* 0x130 */
+	u32 slave_para;			/* 0x134 */
+	u32 cfg1;			/* 0x138 */
+	u32 cfg2;			/* 0x13c */
+};
+
+/*
+ * TVE register constants.
+ */
+#define SUNXI_TVE_GCTRL_ENABLE			(1 << 0)
+/*
+ * Select input 0 to disable dac, 1 - 4 to feed dac from tve0, 5 - 8 to feed
+ * dac from tve1. When using tve1 the mux value must be written to both tve0's
+ * and tve1's gctrl reg.
+ */
+#define SUNXI_TVE_GCTRL_DAC_INPUT_MASK(dac)	(0xf << (((dac) + 1) * 4))
+#define SUNXI_TVE_GCTRL_DAC_INPUT(dac, sel)	((sel) << (((dac) + 1) * 4))
+#define SUNXI_TVE_CFG0_VGA			0x20000000
+#define SUNXI_TVE_CFG0_PAL			0x07030001
+#define SUNXI_TVE_CFG0_NTSC			0x07030000
+#define SUNXI_TVE_DAC_CFG0_VGA			0x403e1ac7
+#ifdef CONFIG_MACH_SUN5I
+#define SUNXI_TVE_DAC_CFG0_COMPOSITE		0x433f0009
+#else
+#define SUNXI_TVE_DAC_CFG0_COMPOSITE		0x403f0008
+#endif
+#define SUNXI_TVE_FILTER_COMPOSITE		0x00000120
+#define SUNXI_TVE_CHROMA_FREQ_PAL_M		0x21e6efe3
+#define SUNXI_TVE_CHROMA_FREQ_PAL_NC		0x21f69446
+#define SUNXI_TVE_PORCH_NUM_PAL			0x008a0018
+#define SUNXI_TVE_PORCH_NUM_NTSC		0x00760020
+#define SUNXI_TVE_LINE_NUM_PAL			0x00160271
+#define SUNXI_TVE_LINE_NUM_NTSC			0x0016020d
+#define SUNXI_TVE_BLANK_BLACK_LEVEL_PAL		0x00fc00fc
+#define SUNXI_TVE_BLANK_BLACK_LEVEL_NTSC	0x00f0011a
+#define SUNXI_TVE_UNKNOWN1_VGA			0x00000000
+#define SUNXI_TVE_UNKNOWN1_COMPOSITE		0x18181818
+#define SUNXI_TVE_AUTO_DETECT_EN_DET_EN(dac)	(1 << ((dac) + 0))
+#define SUNXI_TVE_AUTO_DETECT_EN_INT_EN(dac)	(1 << ((dac) + 16))
+#define SUNXI_TVE_AUTO_DETECT_INT_STATUS(dac)	(1 << ((dac) + 0))
+#define SUNXI_TVE_AUTO_DETECT_STATUS_SHIFT(dac)	((dac) * 8)
+#define SUNXI_TVE_AUTO_DETECT_STATUS_MASK(dac)	(3 << ((dac) * 8))
+#define SUNXI_TVE_AUTO_DETECT_STATUS_NONE	0
+#define SUNXI_TVE_AUTO_DETECT_STATUS_CONNECTED	1
+#define SUNXI_TVE_AUTO_DETECT_STATUS_SHORT_GND	3
+#define SUNXI_TVE_AUTO_DETECT_DEBOUNCE_SHIFT(d)	((d) * 8)
+#define SUNXI_TVE_AUTO_DETECT_DEBOUNCE_MASK(d)	(0xf << ((d) * 8))
+#define SUNXI_TVE_CSC_REG0_ENABLE		(1 << 31)
+#define SUNXI_TVE_CSC_REG0			0x08440832
+#define SUNXI_TVE_CSC_REG1			0x3b6dace1
+#define SUNXI_TVE_CSC_REG2			0x0e1d13dc
+#define SUNXI_TVE_CSC_REG3			0x00108080
+#define SUNXI_TVE_COLOR_BURST_PAL_M		0x00000000
+#define SUNXI_TVE_CBR_LEVEL_PAL			0x00002828
+#define SUNXI_TVE_CBR_LEVEL_NTSC		0x0000004f
+#define SUNXI_TVE_BURST_PHASE_NTSC		0x00000000
+#define SUNXI_TVE_BURST_WIDTH_COMPOSITE		0x0016447e
+#define SUNXI_TVE_UNKNOWN2_PAL			0x0000e0e0
+#define SUNXI_TVE_UNKNOWN2_NTSC			0x0000a0a0
+#define SUNXI_TVE_SYNC_VBI_LEVEL_NTSC		0x001000f0
+#define SUNXI_TVE_ACTIVE_NUM_COMPOSITE		0x000005a0
+#define SUNXI_TVE_CHROMA_BW_GAIN_COMP		0x00000002
+#define SUNXI_TVE_NOTCH_WIDTH_COMPOSITE		0x00000101
+#define SUNXI_TVE_RESYNC_NUM_PAL		0x800d000c
+#define SUNXI_TVE_RESYNC_NUM_NTSC		0x000e000c
+#define SUNXI_TVE_SLAVE_PARA_COMPOSITE		0x00000000
+
+void tvencoder_mode_set(struct sunxi_tve_reg * const tve, enum tve_mode mode);
+void tvencoder_enable(struct sunxi_tve_reg * const tve);
+
+typedef enum
+{
+    TVE_MODE_NTSC,
+    TVE_MODE_PAL,
+} tve_mode_e;
+
+typedef enum
+{
+    DE_LCD,
+    DE_TV,
+} de_mode_e;
+
+typedef enum
+{
+    TVE_ENABLE          = 0x000,
+    TVE_CFG1            = 0x004,
+    TVE_DAC1            = 0x008,
+    TVE_NOTCH_DELAY     = 0x00C,
+    TVE_CHROMA_FREQ     = 0x010,
+    TVE_FB_PORCH        = 0x014,
+    TVE_HD_VS           = 0x018,
+    TVE_LINE_NUM        = 0x01C,
+    TVE_LEVEL           = 0x020,
+    TVE_DAC2            = 0x024,
+    TVE_AUTO_EN         = 0x030,
+    TVE_AUTO_ISR        = 0x034,
+    TVE_AUTO_SR         = 0x038,
+    TVE_AUTO_DEB        = 0x03C,
+    TVE_CSC1            = 0x040,
+    TVE_CSC2            = 0x044,
+    TVE_CSC3            = 0x048,
+    TVE_CSC4            = 0x04C,
+    TVE_REG_0F8         = 0x0F8,
+    TVE_REG_0FC         = 0x0FC,
+    TVE_CB_RESET        = 0x100,
+    TVE_VS_NUM          = 0x104,
+    TVE_FILTER          = 0x108,
+    TVE_CBCR_LEVEL      = 0x10C,
+    TVE_TINT_PHASE      = 0x110,
+    TVE_B_WIDTH         = 0x114,
+    TVE_CBCR_GAIN       = 0x118,
+    TVE_SYNC_LEVEL      = 0x11C,
+    TVE_WHITE_LEVEL     = 0x120,
+    TVE_ACT_LINE        = 0x124,
+    TVE_CHROMA_BW       = 0x128,
+    TVE_CFG2            = 0x12C,
+    TVE_RESYNC          = 0x130,
+    TVE_SLAVE           = 0x134,
+    TVE_CFG3            = 0x138,
+    TVE_CFG4            = 0x13C,
+} tve_reg_e;
+
+typedef enum
+{
+    DEBE_1BPP   = (1 << 8),
+    DEBE_2BPP   = (2 << 8),
+    DEBE_4BPP   = (4 << 8),
+    DEBE_8BPP   = (8 << 8),
+    DEBE_16BPP  = (16 << 8),
+    DEBE_24BPP  = (24 << 8),
+    DEBE_32BPP  = (32 << 8),
+} debe_color_mode_bpp_e;
+
+#define DEBE_PALETTE_EN 0x80
+
+typedef enum
+{
+    DEBE_MODE__1BPP_MONO        = 0 | DEBE_1BPP,
+    DEBE_MODE__2BPP_MONO        = 1 | DEBE_2BPP,
+    DEBE_MODE__4BPP_MONO        = 2 | DEBE_4BPP,
+    DEBE_MODE__8BPP_MONO        = 3 | DEBE_8BPP,
+    DEBE_MODE_16BPP_RGB_655     = 4 | DEBE_16BPP,
+    DEBE_MODE_16BPP_RGB_565     = 5 | DEBE_16BPP,
+    DEBE_MODE_16BPP_RGB_556     = 6 | DEBE_16BPP,
+    DEBE_MODE_16BPP_ARGB_1555   = 7 | DEBE_16BPP,
+    DEBE_MODE_16BPP_RGBA_5551   = 8 | DEBE_16BPP,
+    DEBE_MODE_32BPP_RGB_888     = 9 | DEBE_32BPP,
+    DEBE_MODE_32BPP_ARGB_8888   = 10 | DEBE_32BPP,
+    DEBE_MODE_24BPP_RGB_888     = 11 | DEBE_24BPP,
+    DEBE_MODE__1BPP_PALETTE     = 0 | DEBE_PALETTE_EN | DEBE_1BPP,
+    DEBE_MODE__2BPP_PALETTE     = 1 | DEBE_PALETTE_EN | DEBE_2BPP,
+    DEBE_MODE__4BPP_PALETTE     = 2 | DEBE_PALETTE_EN | DEBE_4BPP,
+    DEBE_MODE__8BPP_PALETTE     = 3 | DEBE_PALETTE_EN | DEBE_8BPP,
+    DEBE_MODE_DEFE_VIDEO        = 0x40,
+    DEBE_MODE_YUV               = 0x41,
+} debe_color_mode_e;
+
+
+typedef enum
+{
+    CLK_DE_SRC_PLL_VIDEO = 0,
+    CLK_DE_SRC_PLL_PERIPH = 2,
+} clk_source_de_e;
+#endif /* _TVE_H */
diff --git a/arch/arm/include/asm/arch-suniv/tzpc.h b/arch/arm/include/asm/arch-suniv/tzpc.h
new file mode 100644
index 00000000..95c55cd4
--- /dev/null
+++ b/arch/arm/include/asm/arch-suniv/tzpc.h
@@ -0,0 +1,34 @@
+/*
+ * (C) Copyright 2015 Chen-Yu Tsai <wens@csie.org>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef _SUNXI_TZPC_H
+#define _SUNXI_TZPC_H
+
+#ifndef __ASSEMBLY__
+struct sunxi_tzpc {
+	u32 r0size;		/* 0x00 Size of secure RAM region */
+	u32 decport0_status;	/* 0x04 Status of decode protection port 0 */
+	u32 decport0_set;	/* 0x08 Set decode protection port 0 */
+	u32 decport0_clear;	/* 0x0c Clear decode protection port 0 */
+	/* For A80 and later SoCs */
+	u32 decport1_status;	/* 0x10 Status of decode protection port 1 */
+	u32 decport1_set;	/* 0x14 Set decode protection port 1 */
+	u32 decport1_clear;	/* 0x18 Clear decode protection port 1 */
+	u32 decport2_status;	/* 0x1c Status of decode protection port 2 */
+	u32 decport2_set;	/* 0x20 Set decode protection port 2 */
+	u32 decport2_clear;	/* 0x24 Clear decode protection port 2 */
+};
+#endif
+
+#define SUN6I_TZPC_DECPORT0_RTC	(1 << 1)
+
+#define SUN8I_H3_TZPC_DECPORT0_ALL  0xbe
+#define SUN8I_H3_TZPC_DECPORT1_ALL  0xff
+#define SUN8I_H3_TZPC_DECPORT2_ALL  0x7f
+
+void tzpc_init(void);
+
+#endif /* _SUNXI_TZPC_H */
diff --git a/arch/arm/include/asm/arch-suniv/usb_phy.h b/arch/arm/include/asm/arch-suniv/usb_phy.h
new file mode 100644
index 00000000..5a9cacb6
--- /dev/null
+++ b/arch/arm/include/asm/arch-suniv/usb_phy.h
@@ -0,0 +1,21 @@
+/*
+ * Sunxi usb-phy code
+ *
+ * Copyright (C) 2015 Hans de Goede <hdegoede@redhat.com>
+ * Copyright (C) 2014 Roman Byshko <rbyshko@gmail.com>
+ *
+ * Based on code from
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+int sunxi_usb_phy_probe(void);
+int sunxi_usb_phy_remove(void);
+void sunxi_usb_phy_init(int index);
+void sunxi_usb_phy_exit(int index);
+void sunxi_usb_phy_power_on(int index);
+void sunxi_usb_phy_power_off(int index);
+int sunxi_usb_phy_vbus_detect(int index);
+int sunxi_usb_phy_id_detect(int index);
+void sunxi_usb_phy_enable_squelch_detect(int index, int enable);
diff --git a/arch/arm/include/asm/arch-suniv/watchdog.h b/arch/arm/include/asm/arch-suniv/watchdog.h
new file mode 100644
index 00000000..ce6d6648
--- /dev/null
+++ b/arch/arm/include/asm/arch-suniv/watchdog.h
@@ -0,0 +1,47 @@
+/*
+ * (C) Copyright 2014
+ * Chen-Yu Tsai <wens@csie.org>
+ *
+ * Watchdog register definitions
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef _SUNXI_WATCHDOG_H_
+#define _SUNXI_WATCHDOG_H_
+
+#define WDT_CTRL_RESTART	(0x1 << 0)
+#define WDT_CTRL_KEY		(0x0a57 << 1)
+
+#if defined(CONFIG_MACH_SUN4I) || \
+    defined(CONFIG_MACH_SUN5I) || \
+    defined(CONFIG_MACH_SUN7I) || \
+    defined(CONFIG_MACH_SUN8I_R40)
+
+#define WDT_MODE_EN		(0x1 << 0)
+#define WDT_MODE_RESET_EN	(0x1 << 1)
+
+struct sunxi_wdog {
+	u32 ctl;		/* 0x00 */
+	u32 mode;		/* 0x04 */
+	u32 res[2];
+};
+
+#else
+
+#define WDT_CFG_RESET		(0x1)
+#define WDT_MODE_EN		(0x1)
+
+struct sunxi_wdog {
+	u32 irq_en;		/* 0x00 */
+	u32 irq_sta;		/* 0x04 */
+	u32 res1[2];
+	u32 ctl;		/* 0x10 */
+	u32 cfg;		/* 0x14 */
+	u32 mode;		/* 0x18 */
+	u32 res2;
+};
+
+#endif
+
+#endif /* _SUNXI_WATCHDOG_H_ */
diff --git a/arch/arm/mach-suniv/Kconfig b/arch/arm/mach-suniv/Kconfig
new file mode 100644
index 00000000..8b8b980b
--- /dev/null
+++ b/arch/arm/mach-suniv/Kconfig
@@ -0,0 +1,21 @@
+config ARCH_SUNXI
+	bool
+	select ARCH_HAS_RESET_CONTROLLER
+	select CLKSRC_MMIO
+	select GENERIC_IRQ_CHIP
+	select GPIOLIB
+	select PINCTRL
+	select RESET_CONTROLLER
+	select SUN4I_TIMER
+
+menuconfig ARCH_SUNXI_V5
+	bool "Allwinner ARMv5 SoCs"
+	depends on ARCH_MULTI_V5
+	select ARCH_SUNXI
+
+if ARCH_SUNXI_V5
+
+config MACH_SUNIV
+	bool "Allwinner suniv Family SoCs support"
+	default ARCH_SUNXI
+endif
diff --git a/arch/arm/mach-suniv/Makefile b/arch/arm/mach-suniv/Makefile
new file mode 100644
index 00000000..bf9eca4e
--- /dev/null
+++ b/arch/arm/mach-suniv/Makefile
@@ -0,0 +1,17 @@
+#
+#This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option)any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+#
+obj-$(CONFIG_ARCH_SUNXI_V5) += sunxi_v5.o common.o
+obj-$(CONFIG_SMP) += platsmp.o
diff --git a/arch/arm/mach-suniv/common.c b/arch/arm/mach-suniv/common.c
new file mode 100644
index 00000000..5dc20109
--- /dev/null
+++ b/arch/arm/mach-suniv/common.c
@@ -0,0 +1,49 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option)any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+#include <asm/io.h>
+#include <asm/mach/arch.h>
+
+void suniv_clrbits(void __iomem *reg, u32 clr_val)
+{
+	uint32_t ret;
+
+	ret = readl(reg);
+	ret&= ~(clr_val);
+	writel(ret, reg);
+}
+EXPORT_SYMBOL(suniv_clrbits);
+
+void suniv_setbits(void __iomem *reg, u32 set_val)
+{
+	uint32_t ret;
+
+	ret = readl(reg);
+	ret|= set_val;
+	writel(ret, reg);
+}
+EXPORT_SYMBOL(suniv_setbits);
+
+void suniv_clrsetbits(void __iomem *reg, u32 clr_val, u32 set_val)
+{
+	uint32_t ret;
+
+	ret = readl(reg);
+	ret&= ~(clr_val);
+	ret|= set_val;
+	writel(ret, reg);
+}
+EXPORT_SYMBOL(suniv_clrsetbits);
+
diff --git a/arch/arm/mach-suniv/platsmp.c b/arch/arm/mach-suniv/platsmp.c
new file mode 100644
index 00000000..8fb50884
--- /dev/null
+++ b/arch/arm/mach-suniv/platsmp.c
@@ -0,0 +1,192 @@
+/*
+ * SMP support for Allwinner SoCs
+ *
+ * Copyright (C) 2013 Maxime Ripard
+ *
+ * Maxime Ripard <maxime.ripard@free-electrons.com>
+ *
+ * Based on code
+ *  Copyright (C) 2012-2013 Allwinner Ltd.
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#include <linux/delay.h>
+#include <linux/init.h>
+#include <linux/io.h>
+#include <linux/memory.h>
+#include <linux/of.h>
+#include <linux/of_address.h>
+#include <linux/smp.h>
+
+#define CPUCFG_CPU_PWR_CLAMP_STATUS_REG(cpu)	((cpu) * 0x40 + 0x64)
+#define CPUCFG_CPU_RST_CTRL_REG(cpu)		(((cpu) + 1) * 0x40)
+#define CPUCFG_CPU_CTRL_REG(cpu)		(((cpu) + 1) * 0x40 + 0x04)
+#define CPUCFG_CPU_STATUS_REG(cpu)		(((cpu) + 1) * 0x40 + 0x08)
+#define CPUCFG_GEN_CTRL_REG			0x184
+#define CPUCFG_PRIVATE0_REG			0x1a4
+#define CPUCFG_PRIVATE1_REG			0x1a8
+#define CPUCFG_DBG_CTL0_REG			0x1e0
+#define CPUCFG_DBG_CTL1_REG			0x1e4
+
+#define PRCM_CPU_PWROFF_REG			0x100
+#define PRCM_CPU_PWR_CLAMP_REG(cpu)		(((cpu) * 4) + 0x140)
+
+static void __iomem *cpucfg_membase;
+static void __iomem *prcm_membase;
+
+static DEFINE_SPINLOCK(cpu_lock);
+
+static void __init sun6i_smp_prepare_cpus(unsigned int max_cpus)
+{
+	struct device_node *node;
+
+	node = of_find_compatible_node(NULL, NULL, "allwinner,sun6i-a31-prcm");
+	if (!node) {
+		pr_err("Missing A31 PRCM node in the device tree\n");
+		return;
+	}
+
+	prcm_membase = of_iomap(node, 0);
+	if (!prcm_membase) {
+		pr_err("Couldn't map A31 PRCM registers\n");
+		return;
+	}
+
+	node = of_find_compatible_node(NULL, NULL,
+				       "allwinner,sun6i-a31-cpuconfig");
+	if (!node) {
+		pr_err("Missing A31 CPU config node in the device tree\n");
+		return;
+	}
+
+	cpucfg_membase = of_iomap(node, 0);
+	if (!cpucfg_membase)
+		pr_err("Couldn't map A31 CPU config registers\n");
+
+}
+
+static int sun6i_smp_boot_secondary(unsigned int cpu,
+				    struct task_struct *idle)
+{
+	u32 reg;
+	int i;
+
+	if (!(prcm_membase && cpucfg_membase))
+		return -EFAULT;
+
+	spin_lock(&cpu_lock);
+
+	/* Set CPU boot address */
+	writel(__pa_symbol(secondary_startup),
+	       cpucfg_membase + CPUCFG_PRIVATE0_REG);
+
+	/* Assert the CPU core in reset */
+	writel(0, cpucfg_membase + CPUCFG_CPU_RST_CTRL_REG(cpu));
+
+	/* Assert the L1 cache in reset */
+	reg = readl(cpucfg_membase + CPUCFG_GEN_CTRL_REG);
+	writel(reg & ~BIT(cpu), cpucfg_membase + CPUCFG_GEN_CTRL_REG);
+
+	/* Disable external debug access */
+	reg = readl(cpucfg_membase + CPUCFG_DBG_CTL1_REG);
+	writel(reg & ~BIT(cpu), cpucfg_membase + CPUCFG_DBG_CTL1_REG);
+
+	/* Power up the CPU */
+	for (i = 0; i <= 8; i++)
+		writel(0xff >> i, prcm_membase + PRCM_CPU_PWR_CLAMP_REG(cpu));
+	mdelay(10);
+
+	/* Clear CPU power-off gating */
+	reg = readl(prcm_membase + PRCM_CPU_PWROFF_REG);
+	writel(reg & ~BIT(cpu), prcm_membase + PRCM_CPU_PWROFF_REG);
+	mdelay(1);
+
+	/* Deassert the CPU core reset */
+	writel(3, cpucfg_membase + CPUCFG_CPU_RST_CTRL_REG(cpu));
+
+	/* Enable back the external debug accesses */
+	reg = readl(cpucfg_membase + CPUCFG_DBG_CTL1_REG);
+	writel(reg | BIT(cpu), cpucfg_membase + CPUCFG_DBG_CTL1_REG);
+
+	spin_unlock(&cpu_lock);
+
+	return 0;
+}
+
+static const struct smp_operations sun6i_smp_ops __initconst = {
+	.smp_prepare_cpus	= sun6i_smp_prepare_cpus,
+	.smp_boot_secondary	= sun6i_smp_boot_secondary,
+};
+CPU_METHOD_OF_DECLARE(sun6i_a31_smp, "allwinner,sun6i-a31", &sun6i_smp_ops);
+
+static void __init sun8i_smp_prepare_cpus(unsigned int max_cpus)
+{
+	struct device_node *node;
+
+	node = of_find_compatible_node(NULL, NULL, "allwinner,sun8i-a23-prcm");
+	if (!node) {
+		pr_err("Missing A23 PRCM node in the device tree\n");
+		return;
+	}
+
+	prcm_membase = of_iomap(node, 0);
+	if (!prcm_membase) {
+		pr_err("Couldn't map A23 PRCM registers\n");
+		return;
+	}
+
+	node = of_find_compatible_node(NULL, NULL,
+				       "allwinner,sun8i-a23-cpuconfig");
+	if (!node) {
+		pr_err("Missing A23 CPU config node in the device tree\n");
+		return;
+	}
+
+	cpucfg_membase = of_iomap(node, 0);
+	if (!cpucfg_membase)
+		pr_err("Couldn't map A23 CPU config registers\n");
+
+}
+
+static int sun8i_smp_boot_secondary(unsigned int cpu,
+				    struct task_struct *idle)
+{
+	u32 reg;
+
+	if (!(prcm_membase && cpucfg_membase))
+		return -EFAULT;
+
+	spin_lock(&cpu_lock);
+
+	/* Set CPU boot address */
+	writel(__pa_symbol(secondary_startup),
+	       cpucfg_membase + CPUCFG_PRIVATE0_REG);
+
+	/* Assert the CPU core in reset */
+	writel(0, cpucfg_membase + CPUCFG_CPU_RST_CTRL_REG(cpu));
+
+	/* Assert the L1 cache in reset */
+	reg = readl(cpucfg_membase + CPUCFG_GEN_CTRL_REG);
+	writel(reg & ~BIT(cpu), cpucfg_membase + CPUCFG_GEN_CTRL_REG);
+
+	/* Clear CPU power-off gating */
+	reg = readl(prcm_membase + PRCM_CPU_PWROFF_REG);
+	writel(reg & ~BIT(cpu), prcm_membase + PRCM_CPU_PWROFF_REG);
+	mdelay(1);
+
+	/* Deassert the CPU core reset */
+	writel(3, cpucfg_membase + CPUCFG_CPU_RST_CTRL_REG(cpu));
+
+	spin_unlock(&cpu_lock);
+
+	return 0;
+}
+
+static const struct smp_operations sun8i_smp_ops __initconst = {
+	.smp_prepare_cpus	= sun8i_smp_prepare_cpus,
+	.smp_boot_secondary	= sun8i_smp_boot_secondary,
+};
+CPU_METHOD_OF_DECLARE(sun8i_a23_smp, "allwinner,sun8i-a23", &sun8i_smp_ops);
diff --git a/arch/arm/mach-suniv/sunxi_v5.c b/arch/arm/mach-suniv/sunxi_v5.c
new file mode 100644
index 00000000..899f6689
--- /dev/null
+++ b/arch/arm/mach-suniv/sunxi_v5.c
@@ -0,0 +1,31 @@
+/*
+ * Device Tree support for Allwinner F series SoCs
+ *
+ * Copyright (C) 2017 Icenowy Zheng <icenowy@aosc.io>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option)any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+#include <asm/mach/arch.h>
+
+static const char * const suniv_board_dt_compat[] = {
+	"allwinner,suniv",
+	"allwinner,suniv-f1c100s",
+	"allwinner,suniv-f1c500s",
+	NULL,
+};
+
+DT_MACHINE_START(SUNXI_DT, "Allwinner suniv Family")
+	.dt_compat	= suniv_board_dt_compat,
+MACHINE_END
diff --git a/drivers/clk/sunxi-ng/Kconfig b/drivers/clk/sunxi-ng/Kconfig
index 6427d0eb..138fe1ce 100644
--- a/drivers/clk/sunxi-ng/Kconfig
+++ b/drivers/clk/sunxi-ng/Kconfig
@@ -6,6 +6,11 @@ config SUNXI_CCU
 
 if SUNXI_CCU
 
+config SUNIV_CCU
+	bool "Support for the Allwinner newer F-series SoC CCU"
+	default MACH_SUNIV
+	depends on MACH_SUNIV || COMPILE_TEST
+
 config SUN50I_A64_CCU
 	bool "Support for the Allwinner A64 CCU"
 	default ARM64 && ARCH_SUNXI
diff --git a/drivers/clk/sunxi-ng/Makefile b/drivers/clk/sunxi-ng/Makefile
index d1c2fa93..5280b33c 100644
--- a/drivers/clk/sunxi-ng/Makefile
+++ b/drivers/clk/sunxi-ng/Makefile
@@ -20,6 +20,7 @@ lib-$(CONFIG_SUNXI_CCU)		+= ccu_nm.o
 lib-$(CONFIG_SUNXI_CCU)		+= ccu_mp.o
 
 # SoC support
+obj-$(CONFIG_SUNIV_CCU)		+= ccu-suniv.o
 obj-$(CONFIG_SUN50I_A64_CCU)	+= ccu-sun50i-a64.o
 obj-$(CONFIG_SUN4I_A10_CCU)	+= ccu-sun4i-a10.o
 obj-$(CONFIG_SUN5I_CCU)		+= ccu-sun5i.o
diff --git a/drivers/clk/sunxi-ng/ccu-suniv.c b/drivers/clk/sunxi-ng/ccu-suniv.c
new file mode 100644
index 00000000..4849d6b7
--- /dev/null
+++ b/drivers/clk/sunxi-ng/ccu-suniv.c
@@ -0,0 +1,415 @@
+/*
+ * Copyright (c) 2016 Icenowy Zheng <icenowy@aosc.io>
+ * Copyright (c) 2019 Steward Fu <steward.fu@gmail.com>
+ *
+ * SPDX-License-Identifier: GPL-2.0
+ */
+#include <linux/clk-provider.h>
+#include <linux/of_address.h>
+#include "ccu_common.h"
+#include "ccu_reset.h"
+#include "ccu_div.h"
+#include "ccu_gate.h"
+#include "ccu_mp.h"
+#include "ccu_mult.h"
+#include "ccu_nk.h"
+#include "ccu_nkm.h"
+#include "ccu_nkmp.h"
+#include "ccu_nm.h"
+#include "ccu_phase.h"
+#include "ccu-suniv.h"
+
+static struct ccu_nkmp pll_cpu_clk = {
+  .enable = BIT(31),
+  .lock = BIT(28),
+  .n = _SUNXI_CCU_MULT(8, 5),
+  .k = _SUNXI_CCU_MULT(4, 2),
+  .m = _SUNXI_CCU_DIV(0, 2),
+  // MAX is guessed by the BSP table
+  .p  = _SUNXI_CCU_DIV_MAX(16, 2, 4),
+  .common = {
+    .reg = 0x000,
+    .hw.init = CLK_HW_INIT("pll-cpu", "osc24M", &ccu_nkmp_ops, CLK_SET_RATE_UNGATE),
+  },
+};
+
+// The Audio PLL is supposed to have 4 outputs: 3 fixed factors from
+// the base (2x, 4x and 8x), and one variable divider (the one true pll audio).
+// We don't have any need for the variable divider for now, so we just
+// hardcode it to match with the clock names
+#define SUNIV_PLL_AUDIO_REG  0x008
+
+static SUNXI_CCU_NM_WITH_GATE_LOCK(pll_audio_base_clk, "pll-audio-base", "osc24M", 0x008,
+  8, 7,        /* N */
+  0, 5,        /* M */
+  BIT(31),     /* gate */
+  BIT(28),     /* lock */
+  CLK_SET_RATE_UNGATE);
+
+static SUNXI_CCU_NM_WITH_FRAC_GATE_LOCK(pll_video_clk, "pll-video", "osc24M", 0x010,
+  8, 7,         /* N */
+  0, 4,         /* M */
+  BIT(24),      /* frac enable */
+  BIT(25),      /* frac select */
+  270000000,    /* frac rate 0 */
+  297000000,    /* frac rate 1 */
+  BIT(31),      /* gate */
+  BIT(28),      /* lock */
+  CLK_SET_RATE_UNGATE);
+
+static SUNXI_CCU_NM_WITH_FRAC_GATE_LOCK(pll_ve_clk, "pll-ve", "osc24M", 0x018,
+  8, 7,         /* N */
+  0, 4,         /* M */
+  BIT(24),      /* frac enable */
+  BIT(25),      /* frac select */
+  270000000,    /* frac rate 0 */
+  297000000,    /* frac rate 1 */
+  BIT(31),      /* gate */
+  BIT(28),      /* lock */
+  CLK_SET_RATE_UNGATE);
+
+static SUNXI_CCU_NKM_WITH_GATE_LOCK(pll_ddr0_clk, "pll-ddr", "osc24M", 0x020,
+  8, 5,         /* N */
+  4, 2,         /* K */
+  0, 2,         /* M */
+  BIT(31),      /* gate */
+  BIT(28),      /* lock */
+  CLK_IS_CRITICAL);
+
+static struct ccu_nk pll_periph_clk = {
+  .enable = BIT(31),
+  .lock = BIT(28),
+  .k = _SUNXI_CCU_MULT(4, 2),
+  .n = _SUNXI_CCU_MULT(8, 5),
+  .common = {
+    .reg = 0x028,
+    .hw.init = CLK_HW_INIT("pll-periph", "osc24M", &ccu_nk_ops, 0),
+  },
+};
+
+static const char * const cpu_parents[] = { "osc32k", "osc24M", "pll-cpu" , "pll-cpu" };
+static SUNXI_CCU_MUX(cpu_clk, "cpu", cpu_parents, 0x050, 16, 2, CLK_IS_CRITICAL | CLK_SET_RATE_PARENT);
+static const char * const ahb_parents[] = { "osc32k", "osc24M", "cpu" , "pll-periph" };
+static const struct ccu_mux_var_prediv ahb_predivs[] = {{ .index = 3, .shift = 6, .width = 2 },};
+static struct ccu_div ahb_clk = {
+  .div = _SUNXI_CCU_DIV_FLAGS(4, 2, CLK_DIVIDER_POWER_OF_TWO),
+  .mux = {
+    .shift = 12,
+    .width = 2,
+    .var_predivs = ahb_predivs,
+    .n_var_predivs = ARRAY_SIZE(ahb_predivs),
+  },
+
+  .common = {
+    .reg = 0x054,
+    .features = CCU_FEATURE_VARIABLE_PREDIV,
+    .hw.init = CLK_HW_INIT_PARENTS("ahb", ahb_parents, &ccu_div_ops, 0),
+  },
+};
+
+static struct clk_div_table apb_div_table[] = {
+  { .val = 0, .div = 2 },
+  { .val = 1, .div = 2 },
+  { .val = 2, .div = 4 },
+  { .val = 3, .div = 8 },
+  {},
+};
+static SUNXI_CCU_DIV_TABLE(apb_clk,   "apb",        "ahb", 0x054, 8, 2, apb_div_table, 0);
+static SUNXI_CCU_GATE(bus_mmc0_clk,   "bus-mmc0",   "ahb", 0x060, BIT(8),   0);
+static SUNXI_CCU_GATE(bus_mmc1_clk,   "bus-mmc1",   "ahb", 0x060, BIT(9),   0);
+static SUNXI_CCU_GATE(bus_dram_clk,   "bus-dram",   "ahb", 0x060, BIT(14),  0);
+static SUNXI_CCU_GATE(bus_spi0_clk,   "bus-spi0",   "ahb", 0x060, BIT(20),  0);
+static SUNXI_CCU_GATE(bus_spi1_clk,   "bus-spi1",   "ahb", 0x060, BIT(21),  0);
+static SUNXI_CCU_GATE(bus_otg_clk,    "bus-otg",    "ahb", 0x060, BIT(24),  0);
+static SUNXI_CCU_GATE(bus_ve_clk,     "bus-ve",     "ahb", 0x064, BIT(0),   0);
+static SUNXI_CCU_GATE(bus_lcd_clk,    "bus-lcd",    "ahb", 0x064, BIT(4),   0);
+static SUNXI_CCU_GATE(bus_di_clk,     "bus-di",     "ahb", 0x064, BIT(5),   0);
+static SUNXI_CCU_GATE(bus_csi_clk,    "bus-csi",    "ahb", 0x064, BIT(8),   0);
+static SUNXI_CCU_GATE(bus_tvd_clk,    "bus-tvd",    "ahb", 0x064, BIT(9),   0);
+static SUNXI_CCU_GATE(bus_tve_clk,    "bus-tve",    "ahb", 0x064, BIT(10),  0);
+static SUNXI_CCU_GATE(bus_de_be_clk,  "bus-de-be",  "ahb", 0x064, BIT(12),  0);
+static SUNXI_CCU_GATE(bus_de_fe_clk,  "bus-de-fe",  "ahb", 0x064, BIT(14),  0);
+static SUNXI_CCU_GATE(bus_codec_clk,  "bus-codec",  "apb", 0x068, BIT(0),   0);
+static SUNXI_CCU_GATE(bus_spdif_clk,  "bus-spdif",  "apb", 0x068, BIT(1),   0);
+static SUNXI_CCU_GATE(bus_ir_clk,     "bus-ir",     "apb", 0x068, BIT(2),   0);
+static SUNXI_CCU_GATE(bus_rsb_clk,    "bus-rsb",    "apb", 0x068, BIT(3),   0);
+static SUNXI_CCU_GATE(bus_i2s0_clk,   "bus-i2s0",   "apb", 0x068, BIT(12),  0);
+static SUNXI_CCU_GATE(bus_i2c0_clk,   "bus-i2c0",   "apb", 0x068, BIT(16),  0);
+static SUNXI_CCU_GATE(bus_i2c1_clk,   "bus-i2c1",   "apb", 0x068, BIT(17),  0);
+static SUNXI_CCU_GATE(bus_i2c2_clk,   "bus-i2c2",   "apb", 0x068, BIT(18),  0);
+static SUNXI_CCU_GATE(bus_pio_clk,    "bus-pio",    "apb", 0x068, BIT(19),  0);
+static SUNXI_CCU_GATE(bus_uart0_clk,  "bus-uart0",  "apb", 0x068, BIT(20),  0);
+static SUNXI_CCU_GATE(bus_uart1_clk,  "bus-uart1",  "apb", 0x068, BIT(21),  0);
+static SUNXI_CCU_GATE(bus_uart2_clk,  "bus-uart2",  "apb", 0x068, BIT(22),  0);
+static const char * const mod0_default_parents[] = { "osc24M", "pll-periph" };
+static SUNXI_CCU_MP_WITH_MUX_GATE(mmc0_clk, "mmc0", mod0_default_parents, 0x088,
+  0, 4,     /* M */
+  16, 2,    /* P */
+  24, 2,    /* mux */
+  BIT(31),  /* gate */
+  0);
+
+static SUNXI_CCU_PHASE(mmc0_sample_clk, "mmc0_sample", "mmc0", 0x088, 20, 3, 0);
+static SUNXI_CCU_PHASE(mmc0_output_clk, "mmc0_output", "mmc0", 0x088, 8, 3, 0);
+static SUNXI_CCU_MP_WITH_MUX_GATE(mmc1_clk, "mmc1", mod0_default_parents, 0x08c,
+  0, 4,     /* M */
+  16, 2,    /* P */
+  24, 2,    /* mux */
+  BIT(31),  /* gate */
+  0);
+
+// The BSP header file has a CIR_CFG, but no mod clock uses this definition
+static const char * const i2s_spdif_parents[] = { "pll-audio-8x", "pll-audio-4x", "pll-audio-2x", "pll-audio" };
+static const char * const de_parents[] = { "pll-video", "pll-periph" };
+static const char * const tcon_parents[] = { "pll-video", "pll-video-2x" };
+static const char * const csi_parents[] = { "pll-video", "osc24M" };
+static const char * const deinterlace_parents[] = { "pll-video", "pll-video-2x" };
+static const char * const tve_clk2_parents[] = { "pll-video", "pll-video-2x" };
+static const char * const tvd_parents[] = { "pll-video", "osc24M", "pll-video-2x" };
+static const u8 de_table[] = { 0, 2, };
+static const u8 tcon_table[] = { 0, 2, };
+static const u8 csi_table[] = { 0, 5, };
+static const u8 deinterlace_table[] = { 0, 2, };
+static const u8 tve_clk2_table[] = { 0, 2, };
+
+static SUNXI_CCU_PHASE(mmc1_sample_clk,   "mmc1_sample", "mmc1", 0x08c, 20, 3, 0);
+static SUNXI_CCU_PHASE(mmc1_output_clk,   "mmc1_output", "mmc1", 0x08c, 8, 3, 0);
+static SUNXI_CCU_MUX_WITH_GATE(i2s_clk,   "i2s", i2s_spdif_parents, 0x0b0, 16, 2, BIT(31), 0);
+static SUNXI_CCU_MUX_WITH_GATE(spdif_clk, "spdif", i2s_spdif_parents, 0x0b4, 16, 2, BIT(31), 0);
+static SUNXI_CCU_GATE(usb_phy0_clk,       "usb-phy0",  "osc24M", 0x0cc, BIT(8), 0);
+static SUNXI_CCU_GATE(dram_ve_clk,        "dram-ve",  "pll-ddr", 0x100, BIT(0), 0);
+static SUNXI_CCU_GATE(dram_csi_clk,       "dram-csi",  "pll-ddr", 0x100, BIT(1), 0);
+static SUNXI_CCU_GATE(dram_di_clk,        "dram-deinterlace", "pll-ddr", 0x100, BIT(2), 0);
+static SUNXI_CCU_GATE(dram_tvd_clk,       "dram-tvd",  "pll-ddr", 0x100, BIT(3), 0);
+static SUNXI_CCU_GATE(dram_de_fe_clk,     "dram-de-fe",  "pll-ddr", 0x100, BIT(24), 0);
+static SUNXI_CCU_GATE(dram_de_be_clk,     "dram-de-be",  "pll-ddr", 0x100, BIT(26), 0);
+static SUNXI_CCU_M_WITH_MUX_TABLE_GATE(de_be_clk, "de-be", de_parents, de_table, 0x104, 0, 4, 24, 3, BIT(31), 0);
+static SUNXI_CCU_M_WITH_MUX_TABLE_GATE(de_fe_clk, "de-fe", de_parents, de_table, 0x10c, 0, 4, 24, 3, BIT(31), 0);
+static SUNXI_CCU_MUX_TABLE_WITH_GATE(tcon_clk, "tcon", tcon_parents, tcon_table, 0x118, 24, 3, BIT(31), CLK_SET_RATE_PARENT);
+static SUNXI_CCU_M_WITH_MUX_TABLE_GATE(di_clk, "deinterlace", deinterlace_parents, deinterlace_table, 0x11c, 0, 4, 24, 3, BIT(31), 0);
+static SUNXI_CCU_M_WITH_MUX_TABLE_GATE(tve_clk2_clk, "tve-clk2", tve_clk2_parents, tve_clk2_table, 0x120, 0, 4, 24, 3, BIT(31), 0);
+static SUNXI_CCU_M_WITH_GATE(tve_clk1_clk, "tve-clk1", "tve-clk2", 0x120, 8, 1, BIT(15), 0);
+static SUNXI_CCU_M_WITH_MUX_GATE(tvd_clk, "tvd", tvd_parents, 0x124, 0, 4, 24, 3, BIT(31), 0);
+static SUNXI_CCU_M_WITH_MUX_TABLE_GATE(csi_clk, "csi", csi_parents, csi_table, 0x120, 0, 4, 8, 3, BIT(15), 0);
+
+// TODO: BSP says the parent is pll-audio, however common sense and experience 
+// told us it should be pll-ve. pll-ve is totally not used in BSP code.
+static SUNXI_CCU_GATE(ve_clk, "ve", "pll-audio", 0x13c, BIT(31), 0);
+static SUNXI_CCU_GATE(codec_clk, "codec", "pll-audio", 0x140, BIT(31), 0);
+static SUNXI_CCU_GATE(avs_clk, "avs", "osc24M", 0x144, BIT(31), 0);
+static struct ccu_common *suniv_ccu_clks[] = {
+  &pll_cpu_clk.common,
+  &pll_audio_base_clk.common,
+  &pll_video_clk.common,
+  &pll_ve_clk.common,
+  &pll_ddr0_clk.common,
+  &pll_periph_clk.common,
+  &cpu_clk.common,
+  &ahb_clk.common,
+  &apb_clk.common,
+  &bus_mmc0_clk.common,
+  &bus_mmc1_clk.common,
+  &bus_dram_clk.common,
+  &bus_spi0_clk.common,
+  &bus_spi1_clk.common,
+  &bus_otg_clk.common,
+  &bus_ve_clk.common,
+  &bus_lcd_clk.common,
+  &bus_di_clk.common,
+  &bus_csi_clk.common,
+  &bus_tve_clk.common,
+  &bus_tvd_clk.common,
+  &bus_de_be_clk.common,
+  &bus_de_fe_clk.common,
+  &bus_codec_clk.common,
+  &bus_spdif_clk.common,
+  &bus_ir_clk.common,
+  &bus_rsb_clk.common,
+  &bus_i2s0_clk.common,
+  &bus_i2c0_clk.common,
+  &bus_i2c1_clk.common,
+  &bus_i2c2_clk.common,
+  &bus_pio_clk.common,
+  &bus_uart0_clk.common,
+  &bus_uart1_clk.common,
+  &bus_uart2_clk.common,
+  &mmc0_clk.common,
+  &mmc0_sample_clk.common,
+  &mmc0_output_clk.common,
+  &mmc1_clk.common,
+  &mmc1_sample_clk.common,
+  &mmc1_output_clk.common,
+  &i2s_clk.common,
+  &spdif_clk.common,
+  &usb_phy0_clk.common,
+  &dram_ve_clk.common,
+  &dram_csi_clk.common,
+  &dram_di_clk.common,
+  &dram_tvd_clk.common,
+  &dram_de_fe_clk.common,
+  &dram_de_be_clk.common,
+  &de_be_clk.common,
+  &de_fe_clk.common,
+  &tcon_clk.common,
+  &di_clk.common,
+  &tve_clk2_clk.common,
+  &tve_clk1_clk.common,
+  &tvd_clk.common,
+  &csi_clk.common,
+  &ve_clk.common,
+  &codec_clk.common,
+  &avs_clk.common,
+};
+
+static CLK_FIXED_FACTOR(pll_audio_clk,    "pll-audio",    "pll-audio-base", 4, 1, CLK_SET_RATE_PARENT);
+static CLK_FIXED_FACTOR(pll_audio_2x_clk, "pll-audio-2x", "pll-audio-base", 2, 1, CLK_SET_RATE_PARENT);
+static CLK_FIXED_FACTOR(pll_audio_4x_clk, "pll-audio-4x", "pll-audio-base", 1, 1, CLK_SET_RATE_PARENT);
+static CLK_FIXED_FACTOR(pll_audio_8x_clk, "pll-audio-8x", "pll-audio-base", 1, 2, CLK_SET_RATE_PARENT);
+static CLK_FIXED_FACTOR(pll_video_2x_clk, "pll-video-2x", "pll-video", 1, 2, 0);
+static struct clk_hw_onecell_data suniv_hw_clks = {
+  .hws  = {
+    [CLK_PLL_CPU]         = &pll_cpu_clk.common.hw,
+    [CLK_PLL_AUDIO_BASE]  = &pll_audio_base_clk.common.hw,
+    [CLK_PLL_AUDIO]       = &pll_audio_clk.hw,
+    [CLK_PLL_AUDIO_2X]    = &pll_audio_2x_clk.hw,
+    [CLK_PLL_AUDIO_4X]    = &pll_audio_4x_clk.hw,
+    [CLK_PLL_AUDIO_8X]    = &pll_audio_8x_clk.hw,
+    [CLK_PLL_VIDEO]       = &pll_video_clk.common.hw,
+    [CLK_PLL_VIDEO_2X]    = &pll_video_2x_clk.hw,
+    [CLK_PLL_VE]          = &pll_ve_clk.common.hw,
+    [CLK_PLL_DDR0]        = &pll_ddr0_clk.common.hw,
+    [CLK_PLL_PERIPH]      = &pll_periph_clk.common.hw,
+    [CLK_CPU]             = &cpu_clk.common.hw,
+    [CLK_AHB]             = &ahb_clk.common.hw,
+    [CLK_APB]             = &apb_clk.common.hw,
+    [CLK_BUS_MMC0]        = &bus_mmc0_clk.common.hw,
+    [CLK_BUS_MMC1]        = &bus_mmc1_clk.common.hw,
+    [CLK_BUS_DRAM]        = &bus_dram_clk.common.hw,
+    [CLK_BUS_SPI0]        = &bus_spi0_clk.common.hw,
+    [CLK_BUS_SPI1]        = &bus_spi1_clk.common.hw,
+    [CLK_BUS_OTG]         = &bus_otg_clk.common.hw,
+    [CLK_BUS_VE]          = &bus_ve_clk.common.hw,
+    [CLK_BUS_LCD]         = &bus_lcd_clk.common.hw,
+    [CLK_BUS_DI]          = &bus_di_clk.common.hw,
+    [CLK_BUS_CSI]         = &bus_csi_clk.common.hw,
+    [CLK_BUS_TVD]         = &bus_tvd_clk.common.hw,
+    [CLK_BUS_TVE]         = &bus_tve_clk.common.hw,
+    [CLK_BUS_DE_BE]       = &bus_de_be_clk.common.hw,
+    [CLK_BUS_DE_FE]       = &bus_de_fe_clk.common.hw,
+    [CLK_BUS_CODEC]       = &bus_codec_clk.common.hw,
+    [CLK_BUS_SPDIF]       = &bus_spdif_clk.common.hw,
+    [CLK_BUS_IR]          = &bus_ir_clk.common.hw,
+    [CLK_BUS_RSB]         = &bus_rsb_clk.common.hw,
+    [CLK_BUS_I2S0]        = &bus_i2s0_clk.common.hw,
+    [CLK_BUS_I2C0]        = &bus_i2c0_clk.common.hw,
+    [CLK_BUS_I2C1]        = &bus_i2c1_clk.common.hw,
+    [CLK_BUS_I2C2]        = &bus_i2c2_clk.common.hw,
+    [CLK_BUS_PIO]         = &bus_pio_clk.common.hw,
+    [CLK_BUS_UART0]       = &bus_uart0_clk.common.hw,
+    [CLK_BUS_UART1]       = &bus_uart1_clk.common.hw,
+    [CLK_BUS_UART2]       = &bus_uart2_clk.common.hw,
+    [CLK_MMC0]            = &mmc0_clk.common.hw,
+    [CLK_MMC0_SAMPLE]     = &mmc0_sample_clk.common.hw,
+    [CLK_MMC0_OUTPUT]     = &mmc0_output_clk.common.hw,
+    [CLK_MMC1]            = &mmc1_clk.common.hw,
+    [CLK_MMC1_SAMPLE]     = &mmc1_sample_clk.common.hw,
+    [CLK_MMC1_OUTPUT]     = &mmc1_output_clk.common.hw,
+    [CLK_I2S]             = &i2s_clk.common.hw,
+    [CLK_SPDIF]           = &spdif_clk.common.hw,
+    [CLK_USB_PHY0]        = &usb_phy0_clk.common.hw,
+    [CLK_DRAM_VE]         = &dram_ve_clk.common.hw,
+    [CLK_DRAM_CSI]        = &dram_csi_clk.common.hw,
+    [CLK_DRAM_DI]         = &dram_di_clk.common.hw,
+    [CLK_DRAM_TVD]        = &dram_tvd_clk.common.hw,
+    [CLK_DRAM_DE_FE]      = &dram_de_fe_clk.common.hw,
+    [CLK_DRAM_DE_BE]      = &dram_de_be_clk.common.hw,
+    [CLK_DE_BE]           = &de_be_clk.common.hw,
+    [CLK_DE_FE]           = &de_fe_clk.common.hw,
+    [CLK_TCON]            = &tcon_clk.common.hw,
+    [CLK_DI]              = &di_clk.common.hw,
+    [CLK_TVE2_CLK]        = &tve_clk2_clk.common.hw,
+    [CLK_TVE1_CLK]        = &tve_clk1_clk.common.hw,
+    [CLK_TVD]             = &tvd_clk.common.hw,
+    [CLK_CSI]             = &csi_clk.common.hw,
+    [CLK_VE]              = &ve_clk.common.hw,
+    [CLK_CODEC]           = &codec_clk.common.hw,
+    [CLK_AVS]             = &avs_clk.common.hw,
+  },
+  .num  = CLK_NUMBER,
+};
+
+static struct ccu_reset_map suniv_ccu_resets[] = {
+  [RST_USB_PHY0]  =  { 0x0cc, BIT(0) },
+  [RST_BUS_MMC0]  =  { 0x2c0, BIT(8) },
+  [RST_BUS_MMC1]  =  { 0x2c0, BIT(9) },
+  [RST_BUS_DRAM]  =  { 0x2c0, BIT(14) },
+  [RST_BUS_SPI0]  =  { 0x2c0, BIT(20) },
+  [RST_BUS_SPI1]  =  { 0x2c0, BIT(21) },
+  [RST_BUS_OTG]   =  { 0x2c0, BIT(24) },
+  [RST_BUS_VE]    =  { 0x2c4, BIT(0) },
+  [RST_BUS_LCD]   =  { 0x2c4, BIT(4) },
+  [RST_BUS_DI]    =  { 0x2c4, BIT(5) },
+  [RST_BUS_CSI]   =  { 0x2c4, BIT(8) },
+  [RST_BUS_TVD]   =  { 0x2c4, BIT(9) },
+  [RST_BUS_TVE]   =  { 0x2c4, BIT(10) },
+  [RST_BUS_DE_BE] =  { 0x2c4, BIT(12) },
+  [RST_BUS_DE_FE] =  { 0x2c4, BIT(14) },
+  [RST_BUS_CODEC] =  { 0x2d0, BIT(0) },
+  [RST_BUS_SPDIF] =  { 0x2d0, BIT(1) },
+  [RST_BUS_IR]    =  { 0x2d0, BIT(2) },
+  [RST_BUS_RSB]   =  { 0x2d0, BIT(3) },
+  [RST_BUS_I2S0]  =  { 0x2d0, BIT(12) },
+  [RST_BUS_I2C0]  =  { 0x2d0, BIT(16) },
+  [RST_BUS_I2C1]  =  { 0x2d0, BIT(17) },
+  [RST_BUS_I2C2]  =  { 0x2d0, BIT(18) },
+  [RST_BUS_UART0] =  { 0x2d0, BIT(20) },
+  [RST_BUS_UART1] =  { 0x2d0, BIT(21) },
+  [RST_BUS_UART2] =  { 0x2d0, BIT(22) },
+};
+
+static const struct sunxi_ccu_desc suniv_ccu_desc = {
+  .ccu_clks = suniv_ccu_clks,
+  .num_ccu_clks = ARRAY_SIZE(suniv_ccu_clks),
+  .hw_clks = &suniv_hw_clks,
+  .resets = suniv_ccu_resets,
+  .num_resets = ARRAY_SIZE(suniv_ccu_resets),
+};
+
+static struct ccu_pll_nb suniv_pll_cpu_nb = {
+  .common  = &pll_cpu_clk.common, // copy from pll_cpu_clk
+  .enable  = BIT(31),
+  .lock  = BIT(28),
+};
+
+static struct ccu_mux_nb suniv_cpu_nb = {
+  .common = &cpu_clk.common,
+  .cm = &cpu_clk.mux,
+  .delay_us = 1,      // > 8 clock cycles at 24 MHz
+  .bypass_index = 1,  // index of 24 MHz oscillator
+};
+
+static void __init suniv_ccu_setup(struct device_node *node)
+{
+  u32 val;
+  void __iomem *reg;
+
+  reg = of_io_request_and_map(node, 0, of_node_full_name(node));
+  if (IS_ERR(reg)) {
+    pr_err("%pOF: Could not map the clock registers\n", node);
+    return;
+  }
+
+  // force the PLL-Audio-1x divider to 4
+  val = readl(reg + SUNIV_PLL_AUDIO_REG);
+  val&= ~GENMASK(19, 16);
+  writel(val | (3 << 16), reg + SUNIV_PLL_AUDIO_REG);
+  sunxi_ccu_probe(node, reg, &suniv_ccu_desc);
+
+  // gate then ungate PLL CPU after any rate changes
+  ccu_pll_notifier_register(&suniv_pll_cpu_nb);
+
+  // peparent CPU during PLL CPU rate changes
+  ccu_mux_notifier_register(pll_cpu_clk.common.hw.clk, &suniv_cpu_nb);
+}
+CLK_OF_DECLARE(suniv_ccu, "allwinner,suniv-f1c100s-ccu", suniv_ccu_setup);
+
diff --git a/drivers/clk/sunxi-ng/ccu-suniv.h b/drivers/clk/sunxi-ng/ccu-suniv.h
new file mode 100644
index 00000000..9b9cd19e
--- /dev/null
+++ b/drivers/clk/sunxi-ng/ccu-suniv.h
@@ -0,0 +1,34 @@
+/*
+ * Copyright 2017 Icenowy Zheng <icenowy@aosc.io>
+ *
+ * SPDX-License-Identifier: GPL-2.0+
+ */
+
+#ifndef _CCU_SUNIV_H_
+#define _CCU_SUNIV_H_
+
+#include <dt-bindings/clock/suniv-ccu.h>
+#include <dt-bindings/reset/suniv-ccu.h>
+
+#define CLK_PLL_CPU		0
+#define CLK_PLL_AUDIO_BASE	1
+#define CLK_PLL_AUDIO		2
+#define CLK_PLL_AUDIO_2X	3
+#define CLK_PLL_AUDIO_4X	4
+#define CLK_PLL_AUDIO_8X	5
+#define CLK_PLL_VIDEO		6
+#define CLK_PLL_VIDEO_2X	7
+#define CLK_PLL_VE		8
+#define CLK_PLL_DDR0		9
+#define CLK_PLL_PERIPH		10
+
+/* CPU clock is exported */
+
+#define CLK_AHB			12
+#define CLK_APB			13
+
+/* All bus gates, DRAM gates and mod clocks are exported */
+
+#define CLK_NUMBER		(CLK_AVS + 1)
+
+#endif /* _CCU_SUNIV_H_ */
diff --git a/drivers/clocksource/sun4i_timer.c b/drivers/clocksource/sun4i_timer.c
index 6e0180aa..3da46b2d 100644
--- a/drivers/clocksource/sun4i_timer.c
+++ b/drivers/clocksource/sun4i_timer.c
@@ -186,7 +186,8 @@ static int __init sun4i_timer_init(struct device_node *node)
 	 */
 	if (of_machine_is_compatible("allwinner,sun4i-a10") ||
 	    of_machine_is_compatible("allwinner,sun5i-a13") ||
-	    of_machine_is_compatible("allwinner,sun5i-a10s"))
+	    of_machine_is_compatible("allwinner,sun5i-a10s") ||
+	    of_machine_is_compatible("allwinner,suniv"))
 		sched_clock_register(sun4i_timer_sched_read, 32,
 				     timer_of_rate(&to));
 
@@ -218,3 +219,5 @@ static int __init sun4i_timer_init(struct device_node *node)
 }
 TIMER_OF_DECLARE(sun4i, "allwinner,sun4i-a10-timer",
 		       sun4i_timer_init);
+TIMER_OF_DECLARE(suniv, "allwinner,suniv-f1c100s-timer",
+		       sun4i_timer_init);
diff --git a/drivers/gpu/drm/sun4i/sun4i_backend.c b/drivers/gpu/drm/sun4i/sun4i_backend.c
index ec594362..6e42b7bf 100644
--- a/drivers/gpu/drm/sun4i/sun4i_backend.c
+++ b/drivers/gpu/drm/sun4i/sun4i_backend.c
@@ -484,6 +484,7 @@ static int sun4i_backend_remove(struct platform_device *pdev)
 }
 
 static const struct of_device_id sun4i_backend_of_table[] = {
+	{ .compatible = "allwinner,suniv-f1c100s-display-backend" },
 	{ .compatible = "allwinner,sun5i-a13-display-backend" },
 	{ .compatible = "allwinner,sun6i-a31-display-backend" },
 	{ .compatible = "allwinner,sun8i-a33-display-backend" },
diff --git a/drivers/gpu/drm/sun4i/sun4i_drv.c b/drivers/gpu/drm/sun4i/sun4i_drv.c
index e09161cf..1ca9b2fd 100644
--- a/drivers/gpu/drm/sun4i/sun4i_drv.c
+++ b/drivers/gpu/drm/sun4i/sun4i_drv.c
@@ -179,14 +179,16 @@ static bool sun4i_drv_node_is_connector(struct device_node *node)
 
 static bool sun4i_drv_node_is_frontend(struct device_node *node)
 {
-	return of_device_is_compatible(node, "allwinner,sun5i-a13-display-frontend") ||
+	return of_device_is_compatible(node, "allwinner,suniv-f1c100s-display-frontend") ||
+		of_device_is_compatible(node, "allwinner,sun5i-a13-display-frontend") ||
 		of_device_is_compatible(node, "allwinner,sun6i-a31-display-frontend") ||
 		of_device_is_compatible(node, "allwinner,sun8i-a33-display-frontend");
 }
 
 static bool sun4i_drv_node_is_tcon(struct device_node *node)
 {
-	return of_device_is_compatible(node, "allwinner,sun5i-a13-tcon") ||
+	return of_device_is_compatible(node, "allwinner,suniv-f1c100s-tcon") ||
+		of_device_is_compatible(node, "allwinner,sun5i-a13-tcon") ||
 		of_device_is_compatible(node, "allwinner,sun6i-a31-tcon") ||
 		of_device_is_compatible(node, "allwinner,sun6i-a31s-tcon") ||
 		of_device_is_compatible(node, "allwinner,sun8i-a33-tcon") ||
@@ -311,6 +313,7 @@ static int sun4i_drv_remove(struct platform_device *pdev)
 }
 
 static const struct of_device_id sun4i_drv_of_table[] = {
+	{ .compatible = "allwinner,suniv-f1c100s-display-engine" },
 	{ .compatible = "allwinner,sun5i-a10s-display-engine" },
 	{ .compatible = "allwinner,sun5i-a13-display-engine" },
 	{ .compatible = "allwinner,sun6i-a31-display-engine" },
diff --git a/drivers/gpu/drm/sun4i/sun4i_rgb.c b/drivers/gpu/drm/sun4i/sun4i_rgb.c
index 7cd7090a..26c31420 100644
--- a/drivers/gpu/drm/sun4i/sun4i_rgb.c
+++ b/drivers/gpu/drm/sun4i/sun4i_rgb.c
@@ -92,14 +92,16 @@ static int sun4i_rgb_mode_valid(struct drm_connector *connector,
 
 	DRM_DEBUG_DRIVER("Vertical parameters OK\n");
 
-	rounded_rate = clk_round_rate(tcon->dclk, rate);
-	if (rounded_rate < rate)
-		return MODE_CLOCK_LOW;
+	if (connector->connector_type != DRM_MODE_CONNECTOR_Unknown) {
+		rounded_rate = clk_round_rate(tcon->dclk, rate);
+		if (rounded_rate < rate)
+			return MODE_CLOCK_LOW;
 
-	if (rounded_rate > rate)
-		return MODE_CLOCK_HIGH;
+		if (rounded_rate > rate)
+			return MODE_CLOCK_HIGH;
 
-	DRM_DEBUG_DRIVER("Clock rate OK\n");
+		DRM_DEBUG_DRIVER("Clock rate OK\n");
+	}
 
 	return MODE_OK;
 }
diff --git a/drivers/gpu/drm/sun4i/sun4i_tcon.c b/drivers/gpu/drm/sun4i/sun4i_tcon.c
index 095bd6b4..59fc8018 100644
--- a/drivers/gpu/drm/sun4i/sun4i_tcon.c
+++ b/drivers/gpu/drm/sun4i/sun4i_tcon.c
@@ -625,6 +625,14 @@ static int sun4i_tcon_remove(struct platform_device *pdev)
 	return 0;
 }
 
+static const struct sun4i_tcon_quirks suniv_f1c100s_quirks = {
+	/*
+	 * The F1C100s SoC has a second channel in TCON, but the clock input of
+	 * it is not documented.
+	 */
+	/* .has_channel_1	= true, */
+};
+
 static const struct sun4i_tcon_quirks sun5i_a13_quirks = {
 	.has_unknown_mux = true,
 	.has_channel_1	= true,
@@ -647,6 +655,7 @@ static const struct sun4i_tcon_quirks sun8i_v3s_quirks = {
 };
 
 static const struct of_device_id sun4i_tcon_of_table[] = {
+	{ .compatible = "allwinner,suniv-f1c100s-tcon", .data = &suniv_f1c100s_quirks },
 	{ .compatible = "allwinner,sun5i-a13-tcon", .data = &sun5i_a13_quirks },
 	{ .compatible = "allwinner,sun6i-a31-tcon", .data = &sun6i_a31_quirks },
 	{ .compatible = "allwinner,sun6i-a31s-tcon", .data = &sun6i_a31s_quirks },
diff --git a/drivers/input/keyboard/Kconfig b/drivers/input/keyboard/Kconfig
index 4c4ab1ce..9416fc4c 100644
--- a/drivers/input/keyboard/Kconfig
+++ b/drivers/input/keyboard/Kconfig
@@ -756,4 +756,13 @@ config KEYBOARD_BCM
 	  To compile this driver as a module, choose M here: the
 	  module will be called bcm-keypad.
 
+config KEYBOARD_MIYOO
+	tristate "Keypad driver for Miyoo handheld"
+	help
+	  Say Y here if you want to use keypad for Miyoo handheld.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called bcm-keypad.
+
 endif
+
diff --git a/drivers/input/keyboard/Makefile b/drivers/input/keyboard/Makefile
index 526e6829..d041d485 100644
--- a/drivers/input/keyboard/Makefile
+++ b/drivers/input/keyboard/Makefile
@@ -67,3 +67,4 @@ obj-$(CONFIG_KEYBOARD_TM2_TOUCHKEY)	+= tm2-touchkey.o
 obj-$(CONFIG_KEYBOARD_TWL4030)		+= twl4030_keypad.o
 obj-$(CONFIG_KEYBOARD_XTKBD)		+= xtkbd.o
 obj-$(CONFIG_KEYBOARD_W90P910)		+= w90p910_keypad.o
+obj-$(CONFIG_KEYBOARD_MIYOO)		+= miyoo_kbd.o
diff --git a/drivers/input/keyboard/miyoo_kbd.c b/drivers/input/keyboard/miyoo_kbd.c
new file mode 100644
index 00000000..8e5cc098
--- /dev/null
+++ b/drivers/input/keyboard/miyoo_kbd.c
@@ -0,0 +1,1130 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option)any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+#include <linux/fs.h>
+#include <linux/kobject.h>
+#include <linux/cdev.h>
+#include <linux/init.h>
+#include <linux/device.h>
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <linux/timer.h>
+#include <linux/gpio.h>
+#include <linux/input.h>
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/backlight.h>
+#include <asm/irq.h>
+#include <asm/io.h>
+#include <asm/io.h>
+#include <asm/arch-suniv/cpu.h>
+#include <asm/arch-suniv/gpio.h>
+#include <linux/uaccess.h>
+#include <linux/unistd.h>
+
+//Hotkeys
+#define KILL_HK "/bin/sh", "-c", "/bin/kill -9 $(/bin/ps -al | /bin/grep \"/mnt/\")"
+#define KILL_SOFT_HK "/bin/sh", "-c", "/bin/kill -2 $(/bin/ps -al | /bin/grep \"/mnt/\")"
+#define SHUTDOWN_HK "/bin/sh", "-c", "/bin/kill -9 $(/bin/ps -al | /bin/grep \"/mnt/\" | /bin/grep -v \"/kernel/\" | /usr/bin/tr -s [:blank:] | /usr/bin/cut -d \" \" -f 2) ; /bin/sleep 0.1 ; /bin/sync ; /bin/swapoff -a ; /sbin/poweroff"
+#define SCREENSHOT_HK "/bin/sh", "-c", "mkdir - p /mnt/screenshots ; name=/mnt/screenshots/system ; if test -e $name.png ; then i=1 ; while test -e $name-$i.png ; do i=$((i+1)) ; done; name=\"$name-$i\" ; fi ; /usr/bin/fbgrab \"$name\".png"
+
+//#define DEBUG
+#define MIYOO_KBD_SET_HOTKEY  _IOWR(0x106, 0, unsigned long)
+#define MIYOO_KBD_GET_HOTKEY  _IOWR(0x100, 0, unsigned long)
+#define MIYOO_KBD_SET_VER     _IOWR(0x101, 0, unsigned long)
+#define MIYOO_KBD_LOCK_KEY    _IOWR(0x102, 0, unsigned long)
+#define MIYOO_LAY_SET_VER     _IOWR(0x103, 0, unsigned long)
+#define MIYOO_KBD_GET_VER     _IOWR(0x104, 0, unsigned long)
+#define MIYOO_LAY_GET_VER     _IOWR(0x105, 0, unsigned long)
+
+//Keypad type
+// CONFIG_KEYBOARD_MIYOO_TYPE:
+//   1 -> "BittBoy" meaning ABXY flipped southwest <-> northeast
+//   2 -> "POCKETGOV1" meaning ABXY flipped southeast <-> northwest
+//   3 -> "SUP M3" meaning AB flipped - matrix multiplexation for inputs.
+//   4 -> "XYC Q8" meaning AB flipped & with echo and debounce code - mapping through GPIO reads except from HOME/START/VOLUME 
+//   5 -> V90 meaning additional L2/R2 physical buttons
+//   6 -> Q20 meaning Lfunction/Rfunction button (similarly to Q90)
+//   7 -> HYBRID meaning BittBoy shell with PocketGo components.
+
+/* 
+ * Hardware map (as observed from the working code)
+ *
+ * | pad | define  | v1 v2      | v3 v4  | init_pullup? | init_as_in? |
+ * |-----+---------+------------+--------+--------------+-------------|
+ * | PA1 | IN_PA1  |            | R2     |              |             |
+ * | PA3 | IN_B    | B (noUART) |        |              | Y (noUART)  |
+ * | PC0 | IN_TB   | Y (noUART) |        | Y            | Y?          |
+ * | PC1 | IN_L1   | L1         | L1     | Y            | Y           |
+ * | PC2 | IN_R1   | R1         | R1     | Y            | Y           |
+ * | PC3 | IN_R2   | Y          | L2     | Y            | Y           |
+ * | PD0 | IN_A    | A          | SELECT |              |             |
+ * | PD9 | IN_TA   | X          | Y      |              |             |
+ * | PE0 | IN_L2   | B          | START  | Y            | Y           |
+ * | PE1 | IN_MENU |            | R      | Y            |             |
+ * | PE2 | IN_1    | matx       | up     | Y            |             |
+ * | PE3 | IN_2    | matx       | down   | Y            |             |
+ * | PE4 | IN_3    | matx       | left   | Y            |             |
+ * | PE5 | IN_4    | matx       | right  | Y            |             |
+ * | PE7 | OUT_1   | matx       | A      | Y            |             |
+ * | PE8 | OUT_2   | matx       | B      | Y            |             |
+ * | PE9 | OUT_3   | matx       | X      | Y            |             |
+ * 
+ * Notes:
+ *  - init_pullup? shows if an internal pull-up resistor has been
+ *    enabled in kbd_init
+ *  - init_as_in? shows in the pin has been designated by input
+ *    by direct writing to GPIO registers in kbd_init
+ *  - (noUART) only happens when USE_UART is undefined (so by default NOT)
+ *  - v1 and v2 are identical (exists just to match the graphics driver)
+ *  - TA=X, TB=Y
+ *  - "matx" is a matrix with these keys: dpad,R,start,select
+ *  - v1&v2 code swaps 'R' and 'left' after scanning the matrix
+ */
+
+//Bittboy inputs
+#define MY_UP     0x0008
+#define MY_DOWN   0x0800
+#define MY_LEFT   0x0080
+#define MY_RIGHT  0x0040
+#define MY_A      0x0100
+#define MY_B      0x0020
+#define MY_TA     0x0010
+#define MY_TB     0x0002
+#define MY_SELECT 0x0400
+#define MY_START  0x0200
+#define MY_R      0x0004
+#define MY_L1     0x1000
+#define MY_R1     0x2000
+#define MY_L2     0x4000
+#define MY_R2     0x8000
+#define MY_L3     0x10000
+#define MY_R3     0x20000
+
+#define IN_L1   ((32 * 2) + 1)
+#define IN_R1   ((32 * 2) + 2)
+#define IN_L2   ((32 * 4) + 0)
+#define IN_R2   ((32 * 2) + 3)
+#define IN_R2_M3 ((32 * 0) + 2)
+#define OUT_1   ((32 * 4) + 7)
+#define OUT_2   ((32 * 4) + 8)
+#define OUT_3   ((32 * 4) + 9)
+#define OUT_4   ((32 * 4) + 10)
+#define IN_L1_Q8 ((32 * 4) + 12)
+#define IN_1    ((32 * 4) + 2)
+#define IN_2    ((32 * 4) + 3)
+#define IN_3    ((32 * 4) + 4)
+#define IN_4    ((32 * 4) + 5)
+#define IN_A    ((32 * 3) + 0)
+#define IN_A_M3 ((32 * 0) + 0)
+#define IN_TA   ((32 * 3) + 9)
+#define IN_B    ((32 * 0) + 3)
+#define IN_TB   ((32 * 2) + 0)
+#define IN_MENU ((32 * 4) + 1)
+#define IN_PC3  ((32 * 2) + 3)
+#define IN_PA1  ((32 * 0) + 1)
+
+#define USE_UART	1
+
+#define NO_RAW	1
+#define TP_INT_FIFOC		0x10
+#define FIFO_FLUSH(x)		((x) << 4)
+
+static int major = -1;
+static struct cdev mycdev;
+static struct class *myclass = NULL;
+static struct input_dev *mydev;
+static struct timer_list mytimer;
+static int myperiod=30;
+
+static struct backlight_device *bd;
+static uint32_t miyoo_ver=1;
+static uint32_t miyoo_layout=1;
+static unsigned long hotkey=0;
+static unsigned long lockkey=0;
+static uint8_t *gpio;
+static uint8_t *touch = NULL;
+bool hotkey_mod_last=false;
+bool hotkey_actioned=false;
+bool hotkey_down=false;
+bool hotkey_custom=false;
+bool non_hotkey_first=false;
+bool non_hotkey_menu=false;
+module_param(miyoo_ver,uint,0660);
+module_param(miyoo_layout,uint,0660);
+
+static int do_input_request(uint32_t pin, const char*name)
+{
+  if(gpio_request(pin, name) < 0){
+    printk("failed to request gpio: %s\n", name);
+    return -1;
+  }
+  gpio_direction_input(pin);
+  return 0;
+}
+
+static int do_output_request(uint32_t pin, const char* name)
+{
+  if(gpio_request(pin, name) < 0){
+    printk("failed to request gpio: %s\n", name);
+    return -1;
+  }
+  gpio_direction_output(pin, 1);
+  return 0;
+}
+
+#if defined(DEBUG)
+static void print_key(uint32_t val, uint8_t is_pressed)
+{
+  uint32_t i;
+  uint32_t map_val[] = {MY_UP, MY_DOWN, MY_LEFT, MY_RIGHT, MY_A, MY_B, MY_TA, MY_TB, MY_SELECT, MY_START, MY_R, MY_L1, MY_R1, MY_L2, MY_R2, MY_L3, MY_R3, -1};
+  char* map_key[] = {"UP", "DOWN", "LEFT", "RIGHT", "A", "B", "X", "Y", "SELECT", "START", "MENU", "L1", "R1", "L2", "R2", "L3", "R3"};
+
+  for(i=0; map_val[i]!=-1; i++){
+    if(map_val[i] == val){
+      if(is_pressed){
+        printk("%s\n", map_key[i]);
+      } 
+      break;
+    }
+  }
+}
+#endif
+
+static void report_key(uint32_t btn, uint32_t mask, uint8_t key)
+{
+  static uint32_t btn_pressed=0;
+  static uint32_t btn_released=0xffff;
+
+  if(btn & mask){
+    btn_released&= ~mask;
+    if((btn_pressed & mask) == 0){
+      btn_pressed|= mask;
+      input_report_key(mydev, key, 1);
+      #if defined(DEBUG)
+        print_key(btn & mask, 1);
+      #endif
+    }
+  }
+  else{
+    btn_pressed&= ~mask;
+    if((btn_released & mask) == 0){
+      btn_released|= mask;
+      input_report_key(mydev, key, 0);
+      #if defined(DEBUG)
+        print_key(btn & mask, 0);
+      #endif
+    }
+  }
+}
+
+static void scan_handler(unsigned long unused)
+{
+  static uint32_t pre=0;
+  uint32_t scan=0, val=0, debounce=0;
+  static uint32_t touchRead=0, touchReadPrev=0;
+  extern void MIYOO_INCREASE_VOLUME(void);
+  extern void MIYOO_DECREASE_VOLUME(void);
+  static char * kill_argv[] = {KILL_HK, NULL};
+  static char * kill_soft_argv[] = {KILL_SOFT_HK, NULL};
+  static char * shutdown_argv[] = {SHUTDOWN_HK, NULL};
+  static char * screenshot_argv[] = {SCREENSHOT_HK, NULL};
+
+  switch(miyoo_ver){
+      case 1:
+      for(scan=0; scan<3; scan++){
+          gpio_set_value(OUT_1, 1);
+          gpio_set_value(OUT_2, 1);
+          gpio_set_value(OUT_3, 1);
+          gpio_direction_input(OUT_1);
+          gpio_direction_input(OUT_2);
+          gpio_direction_input(OUT_3);
+          switch(scan){
+          case 0:
+            gpio_direction_output(OUT_1, 0);
+            break;
+          case 1:
+            gpio_direction_output(OUT_2, 0);
+            break;
+	  case 2: case 5: case 6: case 7:
+            gpio_direction_output(OUT_3, 0);
+            break;
+          }
+          if (gpio_get_value(IN_1) == 0){
+            val|= ((1 << 0) << (scan << 2));
+          }
+          if (gpio_get_value(IN_2) == 0){
+            val|= ((1 << 1) << (scan << 2));
+          }
+          if (gpio_get_value(IN_3) == 0){
+            val|= ((1 << 2) << (scan << 2));
+          }
+          if (gpio_get_value(IN_4) == 0){
+            val|= ((1 << 3) << (scan << 2));
+          }
+        }
+        if (gpio_get_value(IN_L1) == 0){
+          val|= MY_L1;
+        }
+        if (gpio_get_value(IN_R1) == 0){
+          val|= MY_R1;
+        }
+        if (gpio_get_value(IN_L2) == 0){
+          //val|= MY_L2;
+          val|= MY_B;
+        }
+        if (gpio_get_value(IN_R2) == 0){
+          //val|= MY_R2;
+          val|= MY_TB;
+        }
+        if (gpio_get_value(IN_A) == 0){
+          val|= MY_A;
+        }
+        if (gpio_get_value(IN_TA) == 0){
+          val|= MY_TA;
+        }
+      #if !defined(USE_UART)
+        if (gpio_get_value(IN_B) == 0){
+          val|= MY_B;
+        }
+        if (gpio_get_value(IN_TB) == 0){
+          val|= MY_TB;
+        }
+      #endif
+        #if !defined(RAW)
+        if ((miyoo_ver <= 2 || miyoo_ver == 5 || miyoo_ver == 6)  && val & MY_R) {
+          if (! (val & MY_LEFT) ) {
+            val&= ~MY_R;
+            val|= MY_LEFT;
+          }
+        } else if ((miyoo_ver <= 2 || miyoo_ver == 5 || miyoo_ver == 6) && val & MY_LEFT) {
+          if (! (val & MY_R) ) {
+            val&= ~MY_LEFT;
+            val|= MY_R;
+          }
+        }
+        #endif
+    break;
+      case 2: case 5: case 7:
+          gpio_direction_input(IN_1);
+          gpio_direction_input(IN_2);
+          gpio_direction_input(IN_3);
+          gpio_direction_input(IN_4);
+          gpio_direction_input(OUT_1);
+          gpio_direction_input(OUT_2);
+          gpio_direction_input(OUT_3);
+          gpio_direction_input(IN_A);
+          gpio_direction_input(IN_TA);
+          gpio_direction_input(IN_PC3);
+          gpio_direction_input(IN_PA1);
+          gpio_direction_input(IN_L1);
+          gpio_direction_input(IN_R1);
+          gpio_direction_input(IN_MENU);
+
+          if(gpio_get_value(IN_1) == 0){
+              val|= MY_UP;
+          }
+          if(gpio_get_value(IN_2) == 0){
+              val|= MY_DOWN;
+          }
+          if(gpio_get_value(IN_3) == 0){
+              val|= MY_LEFT;
+          }
+          if(gpio_get_value(IN_4) == 0){
+              val|= MY_RIGHT;
+          }
+          if(gpio_get_value(OUT_1) == 0){
+              val|= MY_A;
+          }
+          if(gpio_get_value(OUT_2) == 0){
+              val|= MY_B;
+          }
+          if(gpio_get_value(OUT_3) == 0){
+              val|= MY_TA;
+          }
+          if(gpio_get_value(IN_TA) == 0){
+              val|= MY_TB;
+          }
+          if(gpio_get_value(IN_A) == 0){
+              val|= MY_SELECT;
+          }
+          if(gpio_get_value(IN_L2) == 0){
+              val|= MY_START;
+          }
+          if(gpio_get_value(IN_L1) == 0){
+              val|= MY_L1;
+          }
+          if(gpio_get_value(IN_R1) == 0){
+              val|= MY_R1;
+          }
+          if(gpio_get_value(IN_PC3) == 0){
+              val|= MY_L2;
+          }
+          if(gpio_get_value(IN_PA1) == 0){
+              val|= MY_R2;
+          }
+          if(gpio_get_value(IN_MENU) == 0){
+              val|= MY_R;
+          }
+          break;
+      case 3:
+          gpio_direction_input(IN_4);
+          gpio_direction_input(IN_A_M3);
+          gpio_direction_input(IN_PA1);
+          gpio_direction_output(IN_3,1);
+          if(gpio_get_value(IN_1) == 1){
+              val|= MY_UP;
+          }
+          if(gpio_get_value(IN_2) == 1){
+              val|= MY_LEFT;
+          }
+          if(gpio_get_value(IN_A_M3) == 1){
+              val|= MY_TB;
+          }
+          if(gpio_get_value(IN_PA1) == 1){
+              val|= MY_B;
+          }
+
+          gpio_direction_input(IN_3);
+          gpio_direction_output(IN_4,1);
+          if(gpio_get_value(IN_1) == 1){
+              val|= MY_DOWN;
+          }
+          if(gpio_get_value(IN_2) == 1){
+              val|= MY_RIGHT;
+          }
+          if(gpio_get_value(IN_A_M3) == 1){
+              val|= MY_A;
+          }
+          if(gpio_get_value(IN_PA1) == 1){
+              val|= MY_TA;
+          }
+
+          gpio_direction_input(IN_4);
+          gpio_direction_output(OUT_2,1);
+          gpio_direction_output(OUT_3,1);
+          if(gpio_get_value(IN_PA1) == 1){
+              val|= MY_R;
+          }
+          if(gpio_get_value(IN_A_M3) == 1){
+              val|= MY_SELECT;
+          }
+          if(gpio_get_value(IN_2) == 1){
+              val|= MY_L1;
+          }
+          if(gpio_get_value(IN_1) == 1 && gpio_get_value(IN_2) == 0){
+              val|= MY_START;
+          }
+
+
+          gpio_direction_output(OUT_2, 0);
+          gpio_direction_output(OUT_3, 0);
+          gpio_direction_output(IN_4,1);
+          gpio_direction_output(IN_A_M3,1);
+          gpio_direction_input(IN_R2_M3);
+          if(gpio_get_value(IN_R2_M3) == 1){
+              val|= MY_R1;
+          }
+          break;
+      case 4:
+          gpio_direction_input(OUT_1);
+          gpio_direction_input(OUT_2);
+          gpio_direction_input(OUT_3);
+          gpio_direction_input(OUT_4);
+          gpio_direction_input(IN_1);
+          gpio_direction_input(IN_2);
+          gpio_direction_input(IN_A);
+          gpio_direction_input(IN_A_M3);
+          gpio_direction_input(IN_TA);
+          gpio_direction_input(IN_L1_Q8);
+
+          if(gpio_get_value(IN_1) == 0){
+              val|= MY_A;
+          }
+          if(gpio_get_value(IN_A_M3) == 0){
+              val|= MY_TA;
+          }
+          if(gpio_get_value(IN_2) == 0){
+              val|= MY_TB;
+          }
+          if(gpio_get_value(IN_A) == 0){
+              val|= MY_B;
+          }
+          if(gpio_get_value(OUT_1) == 0){
+              val|= MY_RIGHT;
+          }
+          if(gpio_get_value(OUT_2) == 0){
+              val|= MY_LEFT;
+          }
+          if(gpio_get_value(OUT_3) == 0){
+              val|= MY_DOWN;
+          }
+          if(gpio_get_value(OUT_4) == 0){
+              val|= MY_UP;
+          }
+          if(gpio_get_value(IN_TA) == 0){
+              val|= MY_R1;
+          }
+          if(gpio_get_value(IN_L1_Q8) == 0){
+              val|= MY_L1;
+          }
+          touchRead = (readl(touch + 0x24) >> 4) & 0xff;
+          debounce = abs(touchRead - touchReadPrev);
+          writel( FIFO_FLUSH(1), touch + TP_INT_FIFOC);
+          if(debounce <= 3){
+            if((touchRead < 0x30) && (touchRead >= 0x00)){
+              val|= MY_START;
+            }
+            else if((touchRead < 0x60) && (touchRead >= 0x30)){
+              val|= MY_SELECT;
+            }
+            else if((touchRead < 0xEF) && (touchRead >= 0x60)){
+              val|= MY_R;
+            }
+          }
+          touchReadPrev = touchRead;
+          break;
+      case 6:
+          gpio_direction_input(IN_1);
+          gpio_direction_input(IN_2);
+          gpio_direction_input(IN_3);
+          gpio_direction_input(IN_4);
+          gpio_direction_input(OUT_1);
+          gpio_direction_input(OUT_2);
+          gpio_direction_input(OUT_3);
+          gpio_direction_input(IN_A);
+          gpio_direction_input(IN_TA);
+          gpio_direction_input(IN_PC3);
+          gpio_direction_input(IN_PA1);
+          gpio_direction_input(IN_L1);
+          gpio_direction_input(IN_R1);
+          gpio_direction_input(IN_MENU);
+
+          if(gpio_get_value(IN_1) == 0){
+              val|= MY_UP;
+          }
+          if(gpio_get_value(IN_2) == 0){
+              val|= MY_DOWN;
+          }
+          if(gpio_get_value(IN_3) == 0){
+              val|= MY_LEFT;
+          }
+          if(gpio_get_value(IN_4) == 0){
+              val|= MY_RIGHT;
+          }
+          if(gpio_get_value(OUT_1) == 0){
+              val|= MY_A;
+          }
+          if(gpio_get_value(OUT_2) == 0){
+              val|= MY_B;
+          }
+          if(gpio_get_value(OUT_3) == 0){
+              val|= MY_TA;
+          }
+          if(gpio_get_value(IN_TA) == 0){
+              val|= MY_TB;
+          }
+          if(gpio_get_value(IN_A) == 0){
+              val|= MY_SELECT;
+          }
+          if(gpio_get_value(IN_L2) == 0){
+              val|= MY_START;
+          }
+          if(gpio_get_value(IN_L1) == 0){
+              val|= MY_L1;
+          }
+          if(gpio_get_value(IN_R1) == 0){
+              val|= MY_R1;
+          }
+          if(gpio_get_value(IN_PC3) == 0){
+              val|= MY_R2;
+          }
+          if(gpio_get_value(IN_MENU) == 0){
+              val|= MY_L3;
+          }
+          if(gpio_get_value(IN_PA1) == 0){
+              val|= MY_R;
+          }
+          break; 
+  }
+
+  if(lockkey){
+    val = val & MY_R ? MY_R : 0;
+  }
+
+#if !defined(RAW)
+  if(miyoo_ver == 2)  {
+    if((val & MY_R) && (val & MY_B)) {
+      val&= ~MY_R;
+      val&= ~MY_B;
+      val|= MY_L3;
+      hotkey_actioned = true;
+    }
+    if((val & MY_R) && (val & MY_TB)) {
+      val&= ~MY_R;
+      val&= ~MY_TB;
+      val|= MY_R3;
+      hotkey_actioned = true;
+    }
+    if((val & MY_R) && (val & MY_L1)) {
+      val&= ~MY_R;
+      val&= ~MY_L1;
+      val|= MY_L2;
+      hotkey_actioned = true;
+    }
+    if((val & MY_R) && (val & MY_R1)) {
+      val&= ~MY_R;
+      val&= ~MY_R1;
+      val|= MY_R2;
+      hotkey_actioned = true;
+    }
+  } else if(miyoo_ver == 3) {
+    if((val & MY_R) && (val & MY_L1)) {
+      val&= ~MY_R;
+      val&= ~MY_L1;
+      val|= MY_L2;
+      hotkey_actioned = true;
+    }
+    if((val & MY_R) && (val & MY_R1)) {
+      val&= ~MY_R;
+      val&= ~MY_R1;
+      val|= MY_R2;
+      hotkey_actioned = true;
+    }
+    if((val & MY_R) && (val & MY_TB)) {
+      val&= ~MY_R;
+      val&= ~MY_TB;
+      val|= MY_R3;
+      hotkey_actioned = true;
+    }
+    if((val & MY_R) && (val & MY_B)) {
+      val&= ~MY_R;
+      val&= ~MY_B;
+      val|= MY_L3;
+      hotkey_actioned = true;
+    }
+  } else if(miyoo_ver == 4) {
+    if((val & MY_R) && (val & MY_A)) {
+      if(!hotkey_down && !hotkey_custom) {
+        call_usermodehelper(kill_argv[0], kill_argv, NULL, UMH_NO_WAIT);
+        hotkey_down = true;
+      }
+      hotkey_actioned = true;
+      if (hotkey_custom)
+        hotkey = hotkey == 0 ? 4 : hotkey;
+    }
+    if((val & MY_R) && (val & MY_TA)) {
+      if(!hotkey_down && !hotkey_custom) {
+        call_usermodehelper(screenshot_argv[0], screenshot_argv, NULL, UMH_NO_WAIT);
+        hotkey_down = true;
+      }
+      hotkey_actioned = true;
+      if (hotkey_custom)
+        hotkey = hotkey == 0 ? 2 : hotkey;   
+    }
+    if((val & MY_R) && (val & MY_B)) {
+      val&= ~MY_R;
+      val&= ~MY_B;
+      val|= MY_L3;
+      hotkey_actioned = true;
+    }
+    if((val & MY_R) && (val & MY_TB)) {
+      val&= ~MY_R;
+      val&= ~MY_TB;
+      val|= MY_R3;
+      hotkey_actioned = true;
+    }
+    if((val & MY_R) && (val & MY_L1)) {
+      val&= ~MY_R;
+      val&= ~MY_L1;
+      val|= MY_L2;
+      hotkey_actioned = true;
+    }
+    if((val & MY_R) && (val & MY_R1)) {
+      val&= ~MY_R;
+      val&= ~MY_R1;
+      val|= MY_R2;
+      hotkey_actioned = true;
+    }
+  } else if(miyoo_ver == 5) {
+    if((val & MY_R) && (val & MY_L2)) {
+		  if(!hotkey_down && !hotkey_custom) {
+			  call_usermodehelper(kill_soft_argv[0], kill_soft_argv, NULL, UMH_NO_WAIT);
+			  hotkey_down = true;
+      }
+			hotkey_actioned = true;
+     if (hotkey_custom)
+          hotkey = hotkey == 0 ? 11 : hotkey;
+    }
+    if((val & MY_R) && (val & MY_R2)) {
+       	if(!hotkey_down && !hotkey_custom) {
+			  call_usermodehelper(shutdown_argv[0], shutdown_argv, NULL, UMH_NO_WAIT);
+			  hotkey_down = true;
+      }
+			hotkey_actioned = true;
+      if (hotkey_custom)
+          hotkey = hotkey == 0 ? 12 : hotkey;
+    }
+	if((val & MY_R) && (val & MY_L1)) {
+      val&= ~MY_R;
+      val&= ~MY_L1;
+      val|= MY_L3;
+      hotkey_actioned = true; 
+	}
+    if((val & MY_R) && (val & MY_R1)) {
+      val&= ~MY_R;
+      val&= ~MY_R1;
+      val|= MY_R3;
+      hotkey_actioned = true;
+	}
+  } else if(miyoo_ver == 6) {
+    if((val & MY_R) && (val & MY_L1)) {
+      val&= ~MY_R;
+      val&= ~MY_L1;
+      val|= MY_L2;
+      hotkey_actioned = true; 
+	}
+    if((val & MY_R) && (val & MY_R1)) {
+      val&= ~MY_R;
+      val&= ~MY_R1;
+      val|= MY_R2;
+      hotkey_actioned = true;
+	}
+    if((val & MY_R) && (val & MY_L3)) {
+      val&= ~MY_R;
+      val&= ~MY_L3;
+      val|= MY_R3;
+      hotkey_actioned = true;
+	}
+  } else {
+    if((val & MY_R) && (val & MY_B)) {
+      val&= ~MY_R;
+      val&= ~MY_B;
+      val|= MY_L1;
+      hotkey_actioned = true;
+    }
+    if((val & MY_R) && (val & MY_A)) {
+      val&= ~MY_R;
+      val&= ~MY_A;
+      val|= MY_R1;
+      hotkey_actioned = true;
+    }
+    if((val & MY_R) && (val & MY_TB)) {
+      val&= ~MY_R;
+      val&= ~MY_TB;
+      val|= MY_L2;
+      hotkey_actioned = true;
+    }
+    if((val & MY_R) && (val & MY_TA)) {
+      val&= ~MY_R;
+      val&= ~MY_TA;
+      val|= MY_R2;
+      hotkey_actioned = true;
+    }
+  }
+
+  if(val > 0 && !(val & MY_R)) {
+	  non_hotkey_first = true;
+  }
+
+  if((val & MY_R) && non_hotkey_first) {
+    non_hotkey_menu = true;
+  }
+
+  if(non_hotkey_menu) {
+    if(val & MY_R) {
+	    val&= ~MY_R;
+    } else if(!hotkey_actioned) {
+      val|= MY_R;
+      non_hotkey_menu = false;
+    } else {
+      hotkey_actioned = false;
+      non_hotkey_menu = false;
+    }
+  }
+
+  if(val & MY_R && !non_hotkey_first) {
+	  if((val & MY_R) && (val & MY_B)){
+      if(miyoo_ver == 5 || miyoo_ver == 6)  {
+			  hotkey_actioned = true;
+      //  if (hotkey_custom)
+	  	    hotkey = hotkey == 0 ? 3 : hotkey;
+      }
+	 	}
+	 	else if((val & MY_R) && (val & MY_A)){
+      if(miyoo_ver == 2 || miyoo_ver == 3 || miyoo_ver == 5 || miyoo_ver == 6)  {
+	  	  hotkey_actioned = true;
+      //  if (hotkey_custom)
+	  	    hotkey = hotkey == 0 ? 4 : hotkey;
+      }
+	 	}
+		else if((val & MY_R) && (val & MY_TB)){
+      if(miyoo_ver == 5 || miyoo_ver == 6)  {
+        hotkey_actioned = true;
+      //  if (hotkey_custom)
+          hotkey = hotkey == 0 ? 1 : hotkey;
+      }
+		}
+		else if((val & MY_R) && (val & MY_TA)){
+      if(miyoo_ver == 2 || miyoo_ver == 3 || miyoo_ver == 5 || miyoo_ver == 6)  {
+        hotkey_actioned = true;
+      //  if (hotkey_custom)
+          hotkey = hotkey == 0 ? 2 : hotkey;
+      }
+		}
+		else if((val & MY_R) && (val & MY_UP)){
+      if(!hotkey_down && !hotkey_custom) {
+        MIYOO_INCREASE_VOLUME();
+        hotkey_down = true;
+      }
+			hotkey_actioned = true;
+			if (hotkey_custom)
+        hotkey = hotkey == 0 ? 5 : hotkey;
+		}
+		else if((val & MY_R) && (val & MY_DOWN)){
+      if(!hotkey_down && !hotkey_custom) {
+        MIYOO_DECREASE_VOLUME();
+        hotkey_down = true;
+      }
+			hotkey_actioned = true;
+      if (hotkey_custom)
+			  hotkey = hotkey == 0 ? 6 : hotkey;
+		}
+		else if((val & MY_R) && (val & MY_LEFT)){
+      if(!hotkey_down && !hotkey_custom) {
+        bd = backlight_device_get_by_type(BACKLIGHT_RAW);
+        if(bd->props.brightness > 1) {
+          backlight_device_set_brightness(bd, bd->props.brightness - 1);
+        }
+        hotkey_down = true;
+      }
+			hotkey_actioned = true;
+			if (hotkey_custom)
+        hotkey = hotkey == 0 ? 7 : hotkey;
+		}
+	 else if((val & MY_R) && (val & MY_RIGHT)){
+      if(!hotkey_down && !hotkey_custom) {
+        bd = backlight_device_get_by_type(BACKLIGHT_RAW);
+        if(bd->props.brightness < 2) {
+          backlight_device_set_brightness(bd, 3);
+        } else if (bd->props.brightness < 11) {
+          backlight_device_set_brightness(bd, bd->props.brightness + 1);
+        }
+        hotkey_down = true;
+      }
+			hotkey_actioned = true;
+			if (hotkey_custom)
+        hotkey = hotkey == 0 ? 8 : hotkey;
+		}
+		else if((val & MY_R) && (val & MY_SELECT)){
+      if(!hotkey_down && !hotkey_custom) {
+	      call_usermodehelper(kill_argv[0], kill_argv, NULL, UMH_NO_WAIT);
+        hotkey_down = true;
+      }
+			hotkey_actioned = true;
+			if (hotkey_custom)
+        hotkey = hotkey == 0 ? 9 : hotkey;
+		}
+		else if((val & MY_R) && (val & MY_START)){
+      if(!hotkey_down && !hotkey_custom) {
+        call_usermodehelper(screenshot_argv[0], screenshot_argv, NULL, UMH_NO_WAIT);
+        hotkey_down = true;
+      }
+			hotkey_actioned = true;
+      if (hotkey_custom)
+        hotkey = hotkey == 0 ? 10 : hotkey;
+		}
+    hotkey_mod_last = true;
+
+  } else if(pre != val || hotkey_mod_last){
+    if (hotkey_mod_last) {
+      if (!hotkey_actioned) {
+        val |= MY_R;
+      } else {
+        val &= ~(MY_R);
+        hotkey_actioned = false;
+      }
+    }
+#endif
+#if defined(RAW)
+  if(pre != val) {
+#endif
+    pre = val;
+
+    report_key(pre, MY_UP, KEY_UP);
+    report_key(pre, MY_DOWN, KEY_DOWN);
+    report_key(pre, MY_LEFT, KEY_LEFT);
+    report_key(pre, MY_RIGHT, KEY_RIGHT);
+    report_key(pre, MY_R, KEY_RIGHTCTRL); // "HOME/RESET" button
+    switch (miyoo_layout) {
+        case 1:
+            //MiyooCFW 2.0 default layout (as seen on PocketGO)
+            report_key(pre, MY_A, KEY_LEFTCTRL); // "B" - bottom face button
+            report_key(pre, MY_B, KEY_SPACE); // "Y" - left face button
+            report_key(pre, MY_TA, KEY_LEFTALT); // "A" - right face button
+            report_key(pre, MY_TB, KEY_LEFTSHIFT); // "X" - upper face button
+            break;
+        case 2:
+            //CFW 1.3.3 legacy layout (swapped A-B & Y-X)
+            report_key(pre, MY_A, KEY_LEFTALT);
+            report_key(pre, MY_B, KEY_LEFTSHIFT);
+            report_key(pre, MY_TA, KEY_LEFTCTRL);
+            report_key(pre, MY_TB, KEY_SPACE);
+            break;
+        case 3:
+            //Bittboy layout (moved A->B B->Y & Y->X)
+            report_key(pre, MY_A, KEY_LEFTALT);
+            report_key(pre, MY_B, KEY_LEFTCTRL);
+            report_key(pre, MY_TA, KEY_LEFTSHIFT);
+            report_key(pre, MY_TB, KEY_SPACE);
+            break;
+        case 4:
+            //SUP M3 & XYC Q8 layout (swapped A-B )
+            report_key(pre, MY_A, KEY_LEFTALT);
+            report_key(pre, MY_B, KEY_SPACE);
+            report_key(pre, MY_TA, KEY_LEFTCTRL);
+            report_key(pre, MY_TB, KEY_LEFTSHIFT); 
+            break;
+        case 5:
+            //Custom I (swapped Y-X)
+            report_key(pre, MY_A, KEY_LEFTCTRL);
+            report_key(pre, MY_B, KEY_LEFTSHIFT);
+            report_key(pre, MY_TA, KEY_LEFTALT);
+            report_key(pre, MY_TB, KEY_SPACE);
+            break;
+        case 6:
+            //Custom II (moved A->X & Y->A & X->Y)
+            report_key(pre, MY_A, KEY_LEFTCTRL);
+            report_key(pre, MY_B, KEY_LEFTSHIFT);
+            report_key(pre, MY_TA, KEY_SPACE);
+            report_key(pre, MY_TB, KEY_LEFTALT);
+            break;
+    }
+
+    report_key(pre, MY_SELECT, KEY_ESC);
+    report_key(pre, MY_START, KEY_ENTER);
+
+    report_key(pre, MY_L1, KEY_TAB);
+    report_key(pre, MY_R1, KEY_BACKSPACE);
+    report_key(pre, MY_L2, KEY_PAGEUP);
+    report_key(pre, MY_R2, KEY_PAGEDOWN);
+    report_key(pre, MY_L3, KEY_RIGHTALT);
+    report_key(pre, MY_R3, KEY_RIGHTSHIFT);
+	
+    input_sync(mydev);
+    hotkey_mod_last = false;
+  }
+
+  mod_timer(&mytimer, jiffies + msecs_to_jiffies(myperiod));
+
+#if !defined(RAW)
+  if(!(val & MY_R)) {
+    hotkey_mod_last = false;
+    hotkey_down = false;
+  }
+
+  if((val & MY_R) && ! ( (val & MY_DOWN) || (val & MY_UP) || (val & MY_LEFT) || (val & MY_RIGHT) || (val & MY_SELECT) ) ) {
+    hotkey_down = false;
+  }
+
+  if(val == 0 && non_hotkey_first) {
+	  non_hotkey_first = false;
+  }
+#endif
+}
+
+static int myopen(struct inode *inode, struct file *file)
+{
+  return 0;
+}
+
+static int myclose(struct inode *inode, struct file *file)
+{
+  return 0;
+}
+
+static long myioctl(struct file *filp, unsigned int cmd, unsigned long arg)
+{
+  int ret;
+
+  switch(cmd){
+  case MIYOO_KBD_GET_HOTKEY:
+    ret = copy_to_user((void*)arg, &hotkey, sizeof(unsigned long));
+    hotkey = 0;
+    break;
+  case MIYOO_KBD_SET_HOTKEY:
+    hotkey_custom = arg;
+    printk("miyoo hotkey custom is =%d\n", (bool)hotkey_custom);
+    break;
+  case MIYOO_KBD_SET_VER:
+    miyoo_ver = arg;
+#if defined(DEBUG)
+    printk("miyoo keypad version config as v%d\n", (int)miyoo_ver);
+#endif
+    break;
+  case MIYOO_KBD_GET_VER:
+    ret = copy_to_user((void*)arg, &miyoo_ver, sizeof(unsigned long));
+    break;
+  case MIYOO_LAY_SET_VER:
+    miyoo_layout = arg;
+#if defined(DEBUG)  
+    printk("miyoo keypad layout config as v%d\n", (int)miyoo_layout);
+#endif
+    break;
+  case MIYOO_LAY_GET_VER:
+    ret = copy_to_user((void*)arg, &miyoo_layout, sizeof(unsigned long));
+    break;
+  case MIYOO_KBD_LOCK_KEY:
+    lockkey = arg;
+    break;
+  }
+  return 0;
+}
+
+static const struct file_operations myfops = {
+  .owner = THIS_MODULE,
+  .open = myopen,
+  .release = myclose,
+  .unlocked_ioctl = myioctl,
+};
+
+static int __init kbd_init(void)
+{
+  uint32_t ret;
+
+  // initialise some of the GPIO pins directly by writing to F1C100S registers
+  // datasheet: https://linux-sunxi.org/images/8/85/Allwinner_F1C600_User_Manual_V1.0.pdf
+  // pages 116 onwards
+  gpio = ioremap(0x01c20800, 4096);      // PIO block
+  ret = readl(gpio + (2 * 0x24 + 0x00)); // PC_CFG0
+  ret&= 0xffff0000;                      // set (PC0?) PC1 PC2 PC3 as inputs
+  writel(ret, gpio + (2 * 0x24 + 0x00)); // (somewhat dirty, writes into some reserved)
+
+  ret = readl(gpio + (2 * 0x24 + 0x1c)); // PC_PULL0
+  //ret&= 0xffffff00;
+  //ret|= 0x00000055;
+  ret = 0x55555555;                      // enable pull-ups on PC0 - PC3
+  writel(ret, gpio + (2 * 0x24 + 0x1c)); // (dirty again)
+
+  ret = readl(gpio + (4 * 0x24 + 0x00)); // PE_CFG0
+  if (miyoo_ver == 3) {
+      ret&= 0x0f00000f;
+  } else {
+      ret&= 0xfffffff0;                      // set PE0 as input
+  }
+  writel(ret, gpio + (4 * 0x24 + 0x00));
+
+  ret = readl(gpio + (4 * 0x24 + 0x1c)); // PE_PULL0
+  //ret&= 0xffffffff0;
+  //ret|= 0x000000001;
+  ret = 0x55555555;                      // pull-ups on PE0 - PE12
+  writel(ret, gpio + (4 * 0x24 + 0x1c));
+    if (miyoo_ver == 3) {
+        ret = 0x55555555;                      // pull-ups on PA0 - PA12
+        writel(ret, gpio + (0 * 0x24 + 0x1c));
+    }
+    if (miyoo_ver == 4) {
+        touch = (uint8_t *) ioremap(0x01c24800, 4096);
+        ret = readl(gpio + (32 * 0) + 0);
+        ret &= 0xffffff0f;
+        ret |= 0x00000020;
+        writel(ret, gpio + (32 * 0) + 0);
+
+        writel((3 << 20) | (1 << 22) | (1 << 0), touch + 0x00);
+        writel((1 << 5) | (1 << 4) | (1 << 1), touch + 0x04);
+    }
+
+#if !defined(USE_UART)
+  ret = readl(gpio + (0 * 0x24 + 0x00)); // PA_CFG0
+  ret&= 0xffff0fff;                      // set PA3 as input
+  writel(ret, gpio + (0 * 0x24 + 0x00));
+#endif
+
+  do_input_request(IN_L1, 	"gpio_l1");
+  do_input_request(IN_R1, 	"gpio_r1");
+  do_input_request(IN_L2, 	"gpio_l2");
+  do_input_request(IN_1, 		"gpio_pe2");
+  do_input_request(IN_2, 		"gpio_pe3");
+  do_input_request(IN_3, 		"gpio_pe4");
+  do_input_request(IN_4, 		"gpio_pe5");
+    if (miyoo_ver != 3) {
+        do_input_request(IN_A, "gpio_a");
+        do_input_request(IN_R2, "gpio_r2");
+        do_output_request(OUT_1, "gpio_pe7");
+        } else {
+        do_input_request(IN_A_M3, 	"gpio_a");
+        do_input_request(IN_R2_M3, 	"gpio_r2");
+    }
+
+  do_input_request(IN_TA, 	"gpio_ta");
+#if !defined(USE_UART)
+  do_input_request(IN_B, 		"gpio_b");
+  do_input_request(IN_TB, 	"gpio_tb");
+#endif
+  do_output_request(OUT_2, "gpio_pe8");
+  do_output_request(OUT_3, "gpio_pe9");
+  mydev = input_allocate_device();
+  set_bit(EV_KEY,mydev-> evbit);
+  set_bit(KEY_UP, mydev->keybit);
+  set_bit(KEY_DOWN, mydev->keybit);
+  set_bit(KEY_LEFT, mydev->keybit);
+  set_bit(KEY_RIGHT, mydev->keybit);
+  set_bit(KEY_ENTER, mydev->keybit);
+  set_bit(KEY_ESC, mydev->keybit);
+  set_bit(KEY_LEFTCTRL, mydev->keybit);
+  set_bit(KEY_LEFTALT, mydev->keybit);
+  set_bit(KEY_SPACE, mydev->keybit);
+  set_bit(KEY_LEFTSHIFT, mydev->keybit);
+  set_bit(KEY_TAB, mydev->keybit);
+  set_bit(KEY_BACKSPACE, mydev->keybit);
+  set_bit(KEY_RIGHTCTRL, mydev->keybit);
+  set_bit(KEY_RIGHTALT, mydev->keybit);
+  set_bit(KEY_RIGHTSHIFT, mydev->keybit);  
+  set_bit(KEY_PAGEUP, mydev->keybit);
+  set_bit(KEY_PAGEDOWN, mydev->keybit);
+  mydev->name = "miyoo_keypad";
+  mydev->id.bustype = BUS_HOST;
+  ret = input_register_device(mydev);
+ 
+  alloc_chrdev_region(&major, 0, 1, "miyoo_kbd");
+  myclass = class_create(THIS_MODULE, "miyoo_kbd");
+  device_create(myclass, NULL, major, NULL, "miyoo_kbd");
+  cdev_init(&mycdev, &myfops);
+  cdev_add(&mycdev, major, 1);
+  
+	setup_timer(&mytimer, scan_handler, 0);
+  mod_timer(&mytimer, jiffies + msecs_to_jiffies(myperiod));
+  return 0;
+}
+  
+static void __exit kbd_exit(void)
+{
+  input_unregister_device(mydev);
+  del_timer(&mytimer);
+
+  device_destroy(myclass, major);
+  cdev_del(&mycdev);
+  class_destroy(myclass);
+  unregister_chrdev_region(major, 1);
+  iounmap(gpio);
+}
+  
+module_init(kbd_init);
+module_exit(kbd_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Steward Fu <steward.fu@gmail.com>");
+MODULE_DESCRIPTION("Keyboard Driver for Miyoo handheld");
+ 
diff --git a/drivers/irqchip/irq-sun4i.c b/drivers/irqchip/irq-sun4i.c
index e3e5b913..1eeead38 100644
--- a/drivers/irqchip/irq-sun4i.c
+++ b/drivers/irqchip/irq-sun4i.c
@@ -23,13 +23,26 @@
 
 #include <asm/exception.h>
 
+enum sun4i_irq_type {
+	sun4i_ic,
+	suniv_ic
+};
+
+static enum sun4i_irq_type sun4i_irq_type;
+static int sun4i_irq_enable_reg_offset;
+static int sun4i_irq_mask_reg_offset;
+
 #define SUN4I_IRQ_VECTOR_REG		0x00
 #define SUN4I_IRQ_PROTECTION_REG	0x08
 #define SUN4I_IRQ_NMI_CTRL_REG		0x0c
 #define SUN4I_IRQ_PENDING_REG(x)	(0x10 + 0x4 * x)
 #define SUN4I_IRQ_FIQ_PENDING_REG(x)	(0x20 + 0x4 * x)
-#define SUN4I_IRQ_ENABLE_REG(x)		(0x40 + 0x4 * x)
-#define SUN4I_IRQ_MASK_REG(x)		(0x50 + 0x4 * x)
+#define SUN4I_IRQ_ENABLE_REG_OFFSET	0x40
+#define SUN4I_IRQ_MASK_REG_OFFSET	0x50
+#define SUNIV_IRQ_ENABLE_REG_OFFSET	0x20
+#define SUNIV_IRQ_MASK_REG_OFFSET	0x30
+#define SUN4I_IRQ_ENABLE_REG(x)		(sun4i_irq_enable_reg_offset + 0x4 * x)
+#define SUN4I_IRQ_MASK_REG(x)		(sun4i_irq_mask_reg_offset + 0x4 * x)
 
 static void __iomem *sun4i_irq_base;
 static struct irq_domain *sun4i_irq_domain;
@@ -115,8 +128,9 @@ static int __init sun4i_of_init(struct device_node *node,
 	writel(0xffffffff, sun4i_irq_base + SUN4I_IRQ_PENDING_REG(1));
 	writel(0xffffffff, sun4i_irq_base + SUN4I_IRQ_PENDING_REG(2));
 
-	/* Enable protection mode */
-	writel(0x01, sun4i_irq_base + SUN4I_IRQ_PROTECTION_REG);
+	/* Enable protection mode (not available in suniv) */
+	if (sun4i_irq_type == sun4i_ic)
+		writel(0x01, sun4i_irq_base + SUN4I_IRQ_PROTECTION_REG);
 
 	/* Configure the external interrupt source type */
 	writel(0x00, sun4i_irq_base + SUN4I_IRQ_NMI_CTRL_REG);
@@ -130,7 +144,26 @@ static int __init sun4i_of_init(struct device_node *node,
 
 	return 0;
 }
-IRQCHIP_DECLARE(allwinner_sun4i_ic, "allwinner,sun4i-a10-ic", sun4i_of_init);
+
+static int __init sun4i_ic_of_init(struct device_node *node,
+				   struct device_node *parent)
+{
+	sun4i_irq_type = sun4i_ic;
+	sun4i_irq_enable_reg_offset = SUN4I_IRQ_ENABLE_REG_OFFSET;
+	sun4i_irq_mask_reg_offset = SUN4I_IRQ_MASK_REG_OFFSET;
+	sun4i_of_init(node, parent);
+}
+IRQCHIP_DECLARE(allwinner_sun4i_ic, "allwinner,sun4i-a10-ic", sun4i_ic_of_init);
+
+static int __init suniv_ic_of_init(struct device_node *node,
+				   struct device_node *parent)
+{
+	sun4i_irq_type = suniv_ic;
+	sun4i_irq_enable_reg_offset = SUNIV_IRQ_ENABLE_REG_OFFSET;
+	sun4i_irq_mask_reg_offset = SUNIV_IRQ_MASK_REG_OFFSET;
+	sun4i_of_init(node, parent);
+}
+IRQCHIP_DECLARE(allwinner_suniv_ic, "allwinner,suniv-f1c100s-ic", suniv_ic_of_init);
 
 static void __exception_irq_entry sun4i_handle_irq(struct pt_regs *regs)
 {
diff --git a/drivers/phy/allwinner/phy-sun4i-usb.c b/drivers/phy/allwinner/phy-sun4i-usb.c
index d6e47dee..cf9dd12b 100644
--- a/drivers/phy/allwinner/phy-sun4i-usb.c
+++ b/drivers/phy/allwinner/phy-sun4i-usb.c
@@ -107,6 +107,7 @@
 #define POLL_TIME			msecs_to_jiffies(250)
 
 enum sun4i_usb_phy_type {
+	suniv_f1c100s_phy,
 	sun4i_a10_phy,
 	sun6i_a31_phy,
 	sun8i_a33_phy,
@@ -818,11 +819,11 @@ static int sun4i_usb_phy_probe(struct platform_device *pdev)
 
 	data->id_det_irq = gpiod_to_irq(data->id_det_gpio);
 	if (data->id_det_irq > 0) {
-		ret = devm_request_irq(dev, data->id_det_irq,
+		ret = devm_request_any_context_irq(dev, data->id_det_irq,
 				sun4i_usb_phy0_id_vbus_det_irq,
 				IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING,
 				"usb0-id-det", data);
-		if (ret) {
+		if (ret < 0) {
 			dev_err(dev, "Err requesting id-det-irq: %d\n", ret);
 			return ret;
 		}
@@ -830,11 +831,11 @@ static int sun4i_usb_phy_probe(struct platform_device *pdev)
 
 	data->vbus_det_irq = gpiod_to_irq(data->vbus_det_gpio);
 	if (data->vbus_det_irq > 0) {
-		ret = devm_request_irq(dev, data->vbus_det_irq,
+		ret = devm_request_any_context_irq(dev, data->vbus_det_irq,
 				sun4i_usb_phy0_id_vbus_det_irq,
 				IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING,
 				"usb0-vbus-det", data);
-		if (ret) {
+		if (ret < 0) {
 			dev_err(dev, "Err requesting vbus-det-irq: %d\n", ret);
 			data->vbus_det_irq = -1;
 			sun4i_usb_phy_remove(pdev); /* Stop detect work */
@@ -864,6 +865,14 @@ static int sun4i_usb_phy_probe(struct platform_device *pdev)
 	return 0;
 }
 
+static const struct sun4i_usb_phy_cfg suniv_f1c100s_cfg = {
+	.num_phys = 1,
+	.type = suniv_f1c100s_phy,
+	.disc_thresh = 3,
+	.phyctl_offset = REG_PHYCTL_A10,
+	.dedicated_clocks = true,
+};
+
 static const struct sun4i_usb_phy_cfg sun4i_a10_cfg = {
 	.num_phys = 3,
 	.type = sun4i_a10_phy,
@@ -956,6 +965,10 @@ static const struct sun4i_usb_phy_cfg sun50i_a64_cfg = {
 };
 
 static const struct of_device_id sun4i_usb_phy_of_match[] = {
+	{
+		.compatible = "allwinner,suniv-f1c100s-usb-phy",
+		.data = &suniv_f1c100s_cfg
+	},
 	{ .compatible = "allwinner,sun4i-a10-usb-phy", .data = &sun4i_a10_cfg },
 	{ .compatible = "allwinner,sun5i-a13-usb-phy", .data = &sun5i_a13_cfg },
 	{ .compatible = "allwinner,sun6i-a31-usb-phy", .data = &sun6i_a31_cfg },
diff --git a/drivers/pinctrl/sunxi/Kconfig b/drivers/pinctrl/sunxi/Kconfig
index bfce99d8..206770d1 100644
--- a/drivers/pinctrl/sunxi/Kconfig
+++ b/drivers/pinctrl/sunxi/Kconfig
@@ -6,6 +6,10 @@ config PINCTRL_SUNXI
 	select GENERIC_PINCONF
 	select GPIOLIB
 
+config PINCTRL_SUNIV
+	def_bool MACH_SUNIV
+	select PINCTRL_SUNXI
+
 config PINCTRL_SUN4I_A10
 	def_bool MACH_SUN4I || MACH_SUN7I || MACH_SUN8I
 	select PINCTRL_SUNXI
diff --git a/drivers/pinctrl/sunxi/Makefile b/drivers/pinctrl/sunxi/Makefile
index 12a752e8..3c31c5a4 100644
--- a/drivers/pinctrl/sunxi/Makefile
+++ b/drivers/pinctrl/sunxi/Makefile
@@ -3,6 +3,7 @@
 obj-y					+= pinctrl-sunxi.o
 
 # SoC Drivers
+obj-$(CONFIG_PINCTRL_SUNIV)		+= pinctrl-suniv.o
 obj-$(CONFIG_PINCTRL_SUN4I_A10)		+= pinctrl-sun4i-a10.o
 obj-$(CONFIG_PINCTRL_SUN5I)		+= pinctrl-sun5i.o
 obj-$(CONFIG_PINCTRL_SUN6I_A31)		+= pinctrl-sun6i-a31.o
diff --git a/drivers/pinctrl/sunxi/pinctrl-suniv.c b/drivers/pinctrl/sunxi/pinctrl-suniv.c
new file mode 100644
index 00000000..486261c4
--- /dev/null
+++ b/drivers/pinctrl/sunxi/pinctrl-suniv.c
@@ -0,0 +1,416 @@
+/*
+ * Allwinner new F-series SoC (suniv) pinctrl driver.
+ *
+ * Copyright (C) 2018 Icenowy Zheng
+ *
+ * Icenowy Zheng <icenowy@aosc.io>
+ *
+ * Copyright (C) 2014 Jackie Hwang
+ *
+ * Jackie Hwang <huangshr@allwinnertech.com>
+ *
+ * Copyright (C) 2014 Chen-Yu Tsai
+ *
+ * Chen-Yu Tsai <wens@csie.org>
+ *
+ * Copyright (C) 2014 Maxime Ripard
+ *
+ * Maxime Ripard <maxime.ripard@free-electrons.com>
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/pinctrl/pinctrl.h>
+
+#include "pinctrl-sunxi.h"
+static const struct sunxi_desc_pin suniv_pins[] = {
+	SUNXI_PIN(SUNXI_PINCTRL_PIN(A, 0),
+		  SUNXI_FUNCTION(0x0, "gpio_in"),
+		  SUNXI_FUNCTION(0x1, "gpio_out"),
+		  SUNXI_FUNCTION(0x2, "rtp"),		/* X1 */
+		  SUNXI_FUNCTION(0x4, "i2s"),		/* BCLK */
+		  SUNXI_FUNCTION(0x5, "uart1"),		/* RTS */
+		  SUNXI_FUNCTION(0x6, "spi1")),		/* CS */
+	SUNXI_PIN(SUNXI_PINCTRL_PIN(A, 1),
+		  SUNXI_FUNCTION(0x0, "gpio_in"),
+		  SUNXI_FUNCTION(0x1, "gpio_out"),
+		  SUNXI_FUNCTION(0x2, "rtp"),		/* X2 */
+		  SUNXI_FUNCTION(0x4, "i2s"),		/* LRCK */
+		  SUNXI_FUNCTION(0x5, "uart1"),		/* CTS */
+		  SUNXI_FUNCTION(0x6, "spi1")),		/* MOSI */
+	SUNXI_PIN(SUNXI_PINCTRL_PIN(A, 2),
+		  SUNXI_FUNCTION(0x0, "gpio_in"),
+		  SUNXI_FUNCTION(0x1, "gpio_out"),
+		  SUNXI_FUNCTION(0x2, "rtp"),		/* Y1 */
+		  SUNXI_FUNCTION(0x3, "pwm0"),		/* PWM0 */
+		  SUNXI_FUNCTION(0x4, "i2s"),		/* IN */
+		  SUNXI_FUNCTION(0x5, "uart1"),		/* RX */
+		  SUNXI_FUNCTION(0x6, "spi1")),		/* MOSI */
+	SUNXI_PIN(SUNXI_PINCTRL_PIN(A, 3),
+		  SUNXI_FUNCTION(0x0, "gpio_in"),
+		  SUNXI_FUNCTION(0x1, "gpio_out"),
+		  SUNXI_FUNCTION(0x2, "rtp"),		/* Y2 */
+		  SUNXI_FUNCTION(0x3, "ir0"),		/* RX */
+		  SUNXI_FUNCTION(0x4, "i2s"),		/* OUT */
+		  SUNXI_FUNCTION(0x5, "uart1"),		/* TX */
+		  SUNXI_FUNCTION(0x6, "spi1")),		/* MISO */
+	/* Hole */
+	SUNXI_PIN(SUNXI_PINCTRL_PIN(B, 0),
+		  SUNXI_FUNCTION(0x0, "gpio_in"),
+		  SUNXI_FUNCTION(0x1, "gpio_out"),
+		  SUNXI_FUNCTION(0x2, "dram"),		/* DQS0 */
+		  SUNXI_FUNCTION(0x3, "i2c1"),		/* SCK */
+		  SUNXI_FUNCTION(0x4, "i2s"),		/* BCLK */
+		  SUNXI_FUNCTION(0x5, "uart1"),		/* RTS */
+		  SUNXI_FUNCTION(0x6, "spi1")),		/* CS */
+	SUNXI_PIN(SUNXI_PINCTRL_PIN(B, 1),
+		  SUNXI_FUNCTION(0x0, "gpio_in"),
+		  SUNXI_FUNCTION(0x1, "gpio_out"),
+		  SUNXI_FUNCTION(0x2, "dram"),		/* DQS1 */
+		  SUNXI_FUNCTION(0x3, "i2c1"),		/* SDA */
+		  SUNXI_FUNCTION(0x4, "i2s"),		/* LRCK */
+		  SUNXI_FUNCTION(0x5, "uart1"),		/* CTS */
+		  SUNXI_FUNCTION(0x6, "spi1")),		/* MOSI */
+	SUNXI_PIN(SUNXI_PINCTRL_PIN(B, 2),
+		  SUNXI_FUNCTION(0x0, "gpio_in"),
+		  SUNXI_FUNCTION(0x1, "gpio_out"),
+		  SUNXI_FUNCTION(0x2, "dram"),		/* CKE */
+		  SUNXI_FUNCTION(0x3, "pwm0"),		/* PWM0 */
+		  SUNXI_FUNCTION(0x4, "i2s"),		/* IN */
+		  SUNXI_FUNCTION(0x5, "uart1"),		/* RX */
+		  SUNXI_FUNCTION(0x6, "spi1")),		/* CLK */
+	SUNXI_PIN(SUNXI_PINCTRL_PIN(B, 3),
+		  SUNXI_FUNCTION(0x0, "gpio_in"),
+		  SUNXI_FUNCTION(0x1, "gpio_out"),
+		  SUNXI_FUNCTION(0x2, "dram"),		/* DDR_REF_D */
+		  SUNXI_FUNCTION(0x3, "ir0"),		/* RX */
+		  SUNXI_FUNCTION(0x4, "i2s"),		/* OUT */
+		  SUNXI_FUNCTION(0x5, "uart1"),		/* TX */
+		  SUNXI_FUNCTION(0x6, "spi1")),		/* MISO */
+	/* Hole */
+	SUNXI_PIN(SUNXI_PINCTRL_PIN(C, 0),
+		  SUNXI_FUNCTION(0x1, "gpio_out"),
+		  SUNXI_FUNCTION(0x2, "spi0"),		/* CLK */
+		  SUNXI_FUNCTION(0x3, "mmc1")),		/* CLK */
+	SUNXI_PIN(SUNXI_PINCTRL_PIN(C, 1),
+		  SUNXI_FUNCTION(0x0, "gpio_in"),
+		  SUNXI_FUNCTION(0x1, "gpio_out"),
+		  SUNXI_FUNCTION(0x2, "spi0"),		/* CS */
+		  SUNXI_FUNCTION(0x3, "mmc1")),		/* CMD */
+	SUNXI_PIN(SUNXI_PINCTRL_PIN(C, 2),
+		  SUNXI_FUNCTION(0x0, "gpio_in"),
+		  SUNXI_FUNCTION(0x1, "gpio_out"),
+		  SUNXI_FUNCTION(0x2, "spi0"),		/* MISO */
+		  SUNXI_FUNCTION(0x3, "mmc1")),		/* D0 */
+	SUNXI_PIN(SUNXI_PINCTRL_PIN(C, 3),
+		  SUNXI_FUNCTION(0x0, "gpio_in"),
+		  SUNXI_FUNCTION(0x1, "gpio_out"),
+		  SUNXI_FUNCTION(0x2, "spi0"),		/* MOSI */
+		  SUNXI_FUNCTION(0x3, "uart0")),	/* TX */
+	/* Hole */
+	SUNXI_PIN(SUNXI_PINCTRL_PIN(D, 0),
+		  SUNXI_FUNCTION(0x0, "gpio_in"),
+		  SUNXI_FUNCTION(0x1, "gpio_out"),
+		  SUNXI_FUNCTION(0x2, "lcd"),		/* D2 */
+		  SUNXI_FUNCTION(0x3, "i2c0"),		/* SDA */
+		  SUNXI_FUNCTION(0x4, "rsb"),		/* SDA */
+		  SUNXI_FUNCTION_IRQ_BANK(0x6, 0, 0)),
+	SUNXI_PIN(SUNXI_PINCTRL_PIN(D, 1),
+		  SUNXI_FUNCTION(0x0, "gpio_in"),
+		  SUNXI_FUNCTION(0x1, "gpio_out"),
+		  SUNXI_FUNCTION(0x2, "lcd"),		/* D3 */
+		  SUNXI_FUNCTION(0x3, "uart1"),		/* RTS */
+		  SUNXI_FUNCTION_IRQ_BANK(0x6, 0, 1)),
+	SUNXI_PIN(SUNXI_PINCTRL_PIN(D, 2),
+		  SUNXI_FUNCTION(0x0, "gpio_in"),
+		  SUNXI_FUNCTION(0x1, "gpio_out"),
+		  SUNXI_FUNCTION(0x2, "lcd"),		/* D4*/
+		  SUNXI_FUNCTION(0x3, "uart1"),		/* CTS */
+		  SUNXI_FUNCTION_IRQ_BANK(0x6, 0, 2)),
+	SUNXI_PIN(SUNXI_PINCTRL_PIN(D, 3),
+		  SUNXI_FUNCTION(0x0, "gpio_in"),
+		  SUNXI_FUNCTION(0x1, "gpio_out"),
+		  SUNXI_FUNCTION(0x2, "lcd"),		/* D5 */
+		  SUNXI_FUNCTION(0x3, "uart1"),		/* RX */
+		  SUNXI_FUNCTION_IRQ_BANK(0x6, 0, 3)),
+	SUNXI_PIN(SUNXI_PINCTRL_PIN(D, 4),
+		  SUNXI_FUNCTION(0x0, "gpio_in"),
+		  SUNXI_FUNCTION(0x1, "gpio_out"),
+		  SUNXI_FUNCTION(0x2, "lcd"),		/* D6 */
+		  SUNXI_FUNCTION(0x3, "uart1"),		/* TX */
+		  SUNXI_FUNCTION_IRQ_BANK(0x6, 0, 4)),
+	SUNXI_PIN(SUNXI_PINCTRL_PIN(D, 5),
+		  SUNXI_FUNCTION(0x0, "gpio_in"),
+		  SUNXI_FUNCTION(0x1, "gpio_out"),
+		  SUNXI_FUNCTION(0x2, "lcd"),		/* D7 */
+		  SUNXI_FUNCTION(0x3, "i2c1"),		/* SCK */
+		  SUNXI_FUNCTION_IRQ_BANK(0x6, 0, 5)),
+	SUNXI_PIN(SUNXI_PINCTRL_PIN(D, 6),
+		  SUNXI_FUNCTION(0x0, "gpio_in"),
+		  SUNXI_FUNCTION(0x1, "gpio_out"),
+		  SUNXI_FUNCTION(0x2, "lcd"),		/* D10 */
+		  SUNXI_FUNCTION(0x3, "i2c1"),		/* SDA */
+		  SUNXI_FUNCTION_IRQ_BANK(0x6, 0, 6)),
+	SUNXI_PIN(SUNXI_PINCTRL_PIN(D, 7),
+		  SUNXI_FUNCTION(0x0, "gpio_in"),
+		  SUNXI_FUNCTION(0x1, "gpio_out"),
+		  SUNXI_FUNCTION(0x2, "lcd"),		/* D11 */
+		  SUNXI_FUNCTION(0x3, "i2s"),		/* MCLK */
+		  SUNXI_FUNCTION_IRQ_BANK(0x6, 0, 7)),
+	SUNXI_PIN(SUNXI_PINCTRL_PIN(D, 8),
+		  SUNXI_FUNCTION(0x0, "gpio_in"),
+		  SUNXI_FUNCTION(0x1, "gpio_out"),
+		  SUNXI_FUNCTION(0x2, "lcd"),		/* D12 */
+		  SUNXI_FUNCTION(0x3, "i2s"),		/* BCLK */
+		  SUNXI_FUNCTION_IRQ_BANK(0x6, 0, 8)),
+	SUNXI_PIN(SUNXI_PINCTRL_PIN(D, 9),
+		  SUNXI_FUNCTION(0x0, "gpio_in"),
+		  SUNXI_FUNCTION(0x1, "gpio_out"),
+		  SUNXI_FUNCTION(0x2, "lcd"),		/* D13 */
+		  SUNXI_FUNCTION(0x3, "i2s"),		/* LRCK */
+		  SUNXI_FUNCTION_IRQ_BANK(0x6, 0, 9)),
+	SUNXI_PIN(SUNXI_PINCTRL_PIN(D, 10),
+		  SUNXI_FUNCTION(0x0, "gpio_in"),
+		  SUNXI_FUNCTION(0x1, "gpio_out"),
+		  SUNXI_FUNCTION(0x2, "lcd"),		/* D14 */
+		  SUNXI_FUNCTION(0x3, "i2s"),		/* IN */
+		  SUNXI_FUNCTION_IRQ_BANK(0x6, 0, 10)),
+	SUNXI_PIN(SUNXI_PINCTRL_PIN(D, 11),
+		  SUNXI_FUNCTION(0x0, "gpio_in"),
+		  SUNXI_FUNCTION(0x1, "gpio_out"),
+		  SUNXI_FUNCTION(0x2, "lcd"),		/* D15 */
+		  SUNXI_FUNCTION(0x3, "i2s"),		/* OUT */
+		  SUNXI_FUNCTION_IRQ_BANK(0x6, 0, 11)),
+	SUNXI_PIN(SUNXI_PINCTRL_PIN(D, 12),
+		  SUNXI_FUNCTION(0x0, "gpio_in"),
+		  SUNXI_FUNCTION(0x1, "gpio_out"),
+		  SUNXI_FUNCTION(0x2, "lcd"),		/* D18 */
+		  SUNXI_FUNCTION(0x3, "i2c0"),		/* SCK */
+		  SUNXI_FUNCTION(0x4, "rsb"),		/* SCK */
+		  SUNXI_FUNCTION_IRQ_BANK(0x6, 0, 12)),
+	SUNXI_PIN(SUNXI_PINCTRL_PIN(D, 13),
+		  SUNXI_FUNCTION(0x0, "gpio_in"),
+		  SUNXI_FUNCTION(0x1, "gpio_out"),
+		  SUNXI_FUNCTION(0x2, "lcd"),		/* D19 */
+		  SUNXI_FUNCTION(0x3, "uart2"),		/* TX */
+		  SUNXI_FUNCTION_IRQ_BANK(0x6, 0, 13)),
+	SUNXI_PIN(SUNXI_PINCTRL_PIN(D, 14),
+		  SUNXI_FUNCTION(0x0, "gpio_in"),
+		  SUNXI_FUNCTION(0x1, "gpio_out"),
+		  SUNXI_FUNCTION(0x2, "lcd"),		/* D20 */
+		  SUNXI_FUNCTION(0x3, "lvds1"),		/* RX */
+		  SUNXI_FUNCTION_IRQ_BANK(0x6, 0, 14)),
+	SUNXI_PIN(SUNXI_PINCTRL_PIN(D, 15),
+		  SUNXI_FUNCTION(0x0, "gpio_in"),
+		  SUNXI_FUNCTION(0x1, "gpio_out"),
+		  SUNXI_FUNCTION(0x2, "lcd"),		/* D21 */
+		  SUNXI_FUNCTION(0x3, "uart2"),		/* RTS */
+		  SUNXI_FUNCTION(0x4, "i2c2"),		/* SCK */
+		  SUNXI_FUNCTION_IRQ_BANK(0x6, 0, 15)),
+	SUNXI_PIN(SUNXI_PINCTRL_PIN(D, 16),
+		  SUNXI_FUNCTION(0x0, "gpio_in"),
+		  SUNXI_FUNCTION(0x1, "gpio_out"),
+		  SUNXI_FUNCTION(0x2, "lcd"),		/* D22 */
+		  SUNXI_FUNCTION(0x3, "uart2"),		/* CTS */
+		  SUNXI_FUNCTION(0x4, "i2c2"),		/* SDA */
+		  SUNXI_FUNCTION_IRQ_BANK(0x6, 0, 16)),
+	SUNXI_PIN(SUNXI_PINCTRL_PIN(D, 17),
+		  SUNXI_FUNCTION(0x0, "gpio_in"),
+		  SUNXI_FUNCTION(0x1, "gpio_out"),
+		  SUNXI_FUNCTION(0x2, "lcd"),		/* D23 */
+		  SUNXI_FUNCTION(0x3, "spdif"),		/* OUT */
+		  SUNXI_FUNCTION_IRQ_BANK(0x6, 0, 17)),
+	SUNXI_PIN(SUNXI_PINCTRL_PIN(D, 18),
+		  SUNXI_FUNCTION(0x0, "gpio_in"),
+		  SUNXI_FUNCTION(0x1, "gpio_out"),
+		  SUNXI_FUNCTION(0x2, "lcd"),		/* CLK */
+		  SUNXI_FUNCTION(0x3, "spi0"),		/* CS */
+		  SUNXI_FUNCTION_IRQ_BANK(0x6, 0, 18)),
+	SUNXI_PIN(SUNXI_PINCTRL_PIN(D, 19),
+		  SUNXI_FUNCTION(0x0, "gpio_in"),
+		  SUNXI_FUNCTION(0x1, "gpio_out"),
+		  SUNXI_FUNCTION(0x2, "lcd"),		/* DE */
+		  SUNXI_FUNCTION(0x3, "spi0"),		/* MOSI */
+		  SUNXI_FUNCTION_IRQ_BANK(0x6, 0, 19)),
+	SUNXI_PIN(SUNXI_PINCTRL_PIN(D, 20),
+		  SUNXI_FUNCTION(0x0, "gpio_in"),
+		  SUNXI_FUNCTION(0x1, "gpio_out"),
+		  SUNXI_FUNCTION(0x2, "lcd"),		/* HYSNC */
+		  SUNXI_FUNCTION(0x3, "spi0"),		/* CLK */
+		  SUNXI_FUNCTION_IRQ_BANK(0x6, 0, 20)),
+	SUNXI_PIN(SUNXI_PINCTRL_PIN(D, 21),
+		  SUNXI_FUNCTION(0x0, "gpio_in"),
+		  SUNXI_FUNCTION(0x1, "gpio_out"),
+		  SUNXI_FUNCTION(0x2, "lcd"),		/* VSYNC */
+		  SUNXI_FUNCTION(0x3, "spi0"),		/* MISO */
+		  SUNXI_FUNCTION_IRQ_BANK(0x6, 0, 21)),
+	/* Hole */
+	SUNXI_PIN(SUNXI_PINCTRL_PIN(E, 0),
+		  SUNXI_FUNCTION(0x0, "gpio_in"),
+		  SUNXI_FUNCTION(0x1, "gpio_out"),
+		  SUNXI_FUNCTION(0x2, "csi"),		/* HSYNC */
+		  SUNXI_FUNCTION(0x3, "lcd"),		/* D0 */
+		  SUNXI_FUNCTION(0x4, "i2c2"),		/* SCK */
+		  SUNXI_FUNCTION(0x5, "uart0"),		/* RX */
+		  SUNXI_FUNCTION_IRQ_BANK(0x6, 1, 0)),
+	SUNXI_PIN(SUNXI_PINCTRL_PIN(E, 1),
+		  SUNXI_FUNCTION(0x0, "gpio_in"),
+		  SUNXI_FUNCTION(0x1, "gpio_out"),
+		  SUNXI_FUNCTION(0x2, "csi"),		/* VSYNC */
+		  SUNXI_FUNCTION(0x3, "lcd"),		/* D1 */
+		  SUNXI_FUNCTION(0x4, "i2c2"),		/* SDA */
+		  SUNXI_FUNCTION(0x5, "uart0"),		/* TX */
+		  SUNXI_FUNCTION_IRQ_BANK(0x6, 1, 1)),
+	SUNXI_PIN(SUNXI_PINCTRL_PIN(E, 2),
+		  SUNXI_FUNCTION(0x0, "gpio_in"),
+		  SUNXI_FUNCTION(0x1, "gpio_out"),
+		  SUNXI_FUNCTION(0x2, "csi"),		/* PCLK */
+		  SUNXI_FUNCTION(0x3, "lcd"),		/* D8 */
+		  SUNXI_FUNCTION(0x4, "clk"),		/* OUT */
+		  SUNXI_FUNCTION_IRQ_BANK(0x6, 1, 2)),
+	SUNXI_PIN(SUNXI_PINCTRL_PIN(E, 3),
+		  SUNXI_FUNCTION(0x0, "gpio_in"),
+		  SUNXI_FUNCTION(0x1, "gpio_out"),
+		  SUNXI_FUNCTION(0x2, "csi"),		/* D0 */
+		  SUNXI_FUNCTION(0x3, "lcd"),		/* D9 */
+		  SUNXI_FUNCTION(0x4, "i2s"),		/* BCLK */
+		  SUNXI_FUNCTION(0x5, "rsb"),		/* SCK */
+		  SUNXI_FUNCTION_IRQ_BANK(0x6, 1, 3)),
+	SUNXI_PIN(SUNXI_PINCTRL_PIN(E, 4),
+		  SUNXI_FUNCTION(0x0, "gpio_in"),
+		  SUNXI_FUNCTION(0x1, "gpio_out"),
+		  SUNXI_FUNCTION(0x2, "csi"),		/* D1 */
+		  SUNXI_FUNCTION(0x3, "lcd"),		/* D16 */
+		  SUNXI_FUNCTION(0x4, "i2s"),		/* LRCK */
+		  SUNXI_FUNCTION(0x5, "rsb"),		/* SDA */
+		  SUNXI_FUNCTION_IRQ_BANK(0x6, 1, 4)),
+	SUNXI_PIN(SUNXI_PINCTRL_PIN(E, 5),
+		  SUNXI_FUNCTION(0x0, "gpio_in"),
+		  SUNXI_FUNCTION(0x1, "gpio_out"),
+		  SUNXI_FUNCTION(0x2, "csi"),		/* D2 */
+		  SUNXI_FUNCTION(0x3, "lcd"),		/* D17 */
+		  SUNXI_FUNCTION(0x4, "i2s"),		/* IN */
+		  SUNXI_FUNCTION_IRQ_BANK(0x6, 1, 5)),
+	SUNXI_PIN(SUNXI_PINCTRL_PIN(E, 6),
+		  SUNXI_FUNCTION(0x0, "gpio_in"),
+		  SUNXI_FUNCTION(0x1, "gpio_out"),
+		  SUNXI_FUNCTION(0x2, "csi"),		/* D3 */
+		  SUNXI_FUNCTION(0x3, "pwm1"),		/* PWM1 */
+		  SUNXI_FUNCTION(0x4, "i2s"),		/* OUT */
+		  SUNXI_FUNCTION(0x5, "spdif"),		/* OUT */
+		  SUNXI_FUNCTION_IRQ_BANK(0x6, 1, 6)),
+	SUNXI_PIN(SUNXI_PINCTRL_PIN(E, 7),
+		  SUNXI_FUNCTION(0x0, "gpio_in"),
+		  SUNXI_FUNCTION(0x1, "gpio_out"),
+		  SUNXI_FUNCTION(0x2, "csi"),		/* D4 */
+		  SUNXI_FUNCTION(0x3, "uart2"),		/* TX */
+		  SUNXI_FUNCTION(0x4, "spi1"),		/* CS */
+		  SUNXI_FUNCTION_IRQ_BANK(0x6, 1, 7)),
+	SUNXI_PIN(SUNXI_PINCTRL_PIN(E, 8),
+		  SUNXI_FUNCTION(0x0, "gpio_in"),
+		  SUNXI_FUNCTION(0x1, "gpio_out"),
+		  SUNXI_FUNCTION(0x2, "csi"),		/* D5 */
+		  SUNXI_FUNCTION(0x3, "uart2"),		/* RX */
+		  SUNXI_FUNCTION(0x4, "spi1"),		/* MOSI */
+		  SUNXI_FUNCTION_IRQ_BANK(0x6, 1, 8)),
+	SUNXI_PIN(SUNXI_PINCTRL_PIN(E, 9),
+		  SUNXI_FUNCTION(0x0, "gpio_in"),
+		  SUNXI_FUNCTION(0x1, "gpio_out"),
+		  SUNXI_FUNCTION(0x2, "csi"),		/* D6 */
+		  SUNXI_FUNCTION(0x3, "uart2"),		/* RTS */
+		  SUNXI_FUNCTION(0x4, "spi1"),		/* CLK */
+		  SUNXI_FUNCTION_IRQ_BANK(0x6, 1, 9)),
+	SUNXI_PIN(SUNXI_PINCTRL_PIN(E, 10),
+		  SUNXI_FUNCTION(0x0, "gpio_in"),
+		  SUNXI_FUNCTION(0x1, "gpio_out"),
+		  SUNXI_FUNCTION(0x2, "csi"),		/* D7 */
+		  SUNXI_FUNCTION(0x3, "uart2"),		/* CTS */
+		  SUNXI_FUNCTION(0x4, "spi1"),		/* MISO */
+		  SUNXI_FUNCTION_IRQ_BANK(0x6, 1, 10)),
+	SUNXI_PIN(SUNXI_PINCTRL_PIN(E, 11),
+		  SUNXI_FUNCTION(0x0, "gpio_in"),
+		  SUNXI_FUNCTION(0x1, "gpio_out"),
+		  SUNXI_FUNCTION(0x2, "clk0"),		/* OUT */
+		  SUNXI_FUNCTION(0x3, "i2c0"),		/* SCK */
+		  SUNXI_FUNCTION(0x4, "ir"),		/* RX */
+		  SUNXI_FUNCTION_IRQ_BANK(0x6, 1, 11)),
+	SUNXI_PIN(SUNXI_PINCTRL_PIN(E, 12),
+		  SUNXI_FUNCTION(0x0, "gpio_in"),
+		  SUNXI_FUNCTION(0x1, "gpio_out"),
+		  SUNXI_FUNCTION(0x2, "i2s"),		/* MCLK */
+		  SUNXI_FUNCTION(0x3, "i2c0"),		/* SDA */
+		  SUNXI_FUNCTION(0x4, "pwm0"),		/* PWM0 */
+		  SUNXI_FUNCTION_IRQ_BANK(0x6, 1, 12)),
+
+	/* Hole */
+	SUNXI_PIN(SUNXI_PINCTRL_PIN(F, 0),
+		  SUNXI_FUNCTION(0x0, "gpio_in"),
+		  SUNXI_FUNCTION(0x1, "gpio_out"),
+		  SUNXI_FUNCTION(0x2, "mmc0"),		/* D1 */
+		  SUNXI_FUNCTION(0x3, "jtag"),		/* MS */
+		  SUNXI_FUNCTION(0x4, "ir0"),		/* MS */
+		  SUNXI_FUNCTION_IRQ_BANK(0x6, 2, 0)),
+	SUNXI_PIN(SUNXI_PINCTRL_PIN(F, 1),
+		  SUNXI_FUNCTION(0x0, "gpio_in"),
+		  SUNXI_FUNCTION(0x1, "gpio_out"),
+		  SUNXI_FUNCTION(0x2, "mmc0"),		/* D0 */
+		  SUNXI_FUNCTION(0x3, "dgb0"),		/* DI */
+		  SUNXI_FUNCTION_IRQ_BANK(0x6, 2, 1)),
+	SUNXI_PIN(SUNXI_PINCTRL_PIN(F, 2),
+		  SUNXI_FUNCTION(0x0, "gpio_in"),
+		  SUNXI_FUNCTION(0x1, "gpio_out"),
+		  SUNXI_FUNCTION(0x2, "mmc0"),		/* CLK */
+		  SUNXI_FUNCTION(0x3, "uart0"),		/* TX */
+		  SUNXI_FUNCTION_IRQ_BANK(0x6, 2, 2)),
+	SUNXI_PIN(SUNXI_PINCTRL_PIN(F, 3),
+		  SUNXI_FUNCTION(0x0, "gpio_in"),
+		  SUNXI_FUNCTION(0x1, "gpio_out"),
+		  SUNXI_FUNCTION(0x2, "mmc0"),		/* CMD */
+		  SUNXI_FUNCTION(0x3, "jtag"),		/* DO */
+		  SUNXI_FUNCTION_IRQ_BANK(0x6, 2, 3)),
+	SUNXI_PIN(SUNXI_PINCTRL_PIN(F, 4),
+		  SUNXI_FUNCTION(0x0, "gpio_in"),
+		  SUNXI_FUNCTION(0x1, "gpio_out"),
+		  SUNXI_FUNCTION(0x2, "mmc0"),		/* D3 */
+		  SUNXI_FUNCTION(0x3, "uart0"),		/* TX */
+		  SUNXI_FUNCTION_IRQ_BANK(0x6, 2, 4)),
+	SUNXI_PIN(SUNXI_PINCTRL_PIN(F, 5),
+		  SUNXI_FUNCTION(0x0, "gpio_in"),
+		  SUNXI_FUNCTION(0x1, "gpio_out"),
+		  SUNXI_FUNCTION(0x2, "mmc0"),		/* D2 */
+		  SUNXI_FUNCTION(0x3, "jtag"),		/* CK */
+		  SUNXI_FUNCTION(0x4, "pwm1"),		/* PWM1 */
+		  SUNXI_FUNCTION_IRQ_BANK(0x6, 2, 5)),
+};
+
+static const struct sunxi_pinctrl_desc suniv_pinctrl_data = {
+	.pins = suniv_pins,
+	.npins = ARRAY_SIZE(suniv_pins),
+	.irq_banks = 3,
+};
+
+static int suniv_pinctrl_probe(struct platform_device *pdev)
+{
+	return sunxi_pinctrl_init(pdev,
+				  &suniv_pinctrl_data);
+}
+
+static const struct of_device_id suniv_pinctrl_match[] = {
+	{ .compatible = "allwinner,suniv-f1c100s-pinctrl", },
+	{}
+};
+
+static struct platform_driver suniv_pinctrl_driver = {
+	.probe	= suniv_pinctrl_probe,
+	.driver	= {
+		.name		= "suniv-pinctrl",
+		.of_match_table	= suniv_pinctrl_match,
+	},
+};
+builtin_platform_driver(suniv_pinctrl_driver);
diff --git a/drivers/pinctrl/sunxi/pinctrl-sunxi.c b/drivers/pinctrl/sunxi/pinctrl-sunxi.c
index cc8b86a1..9ad6ff78 100644
--- a/drivers/pinctrl/sunxi/pinctrl-sunxi.c
+++ b/drivers/pinctrl/sunxi/pinctrl-sunxi.c
@@ -90,7 +90,6 @@ sunxi_pinctrl_desc_find_function_by_name(struct sunxi_pinctrl *pctl,
 			}
 		}
 	}
-
 	return NULL;
 }
 
diff --git a/drivers/power/supply/Kconfig b/drivers/power/supply/Kconfig
index 645908cc..8b4da5f1 100644
--- a/drivers/power/supply/Kconfig
+++ b/drivers/power/supply/Kconfig
@@ -611,4 +611,10 @@ config CHARGER_RT9455
 	help
 	  Say Y to enable support for Richtek RT9455 battery charger.
 
+config BATTERY_MIYOO
+	tristate "Miyoo battery driver"
+	depends on MACH_SUNIV
+	help
+	  Say Y to enable support for the battery on Miyoo handheld.
+
 endif # POWER_SUPPLY
diff --git a/drivers/power/supply/Makefile b/drivers/power/supply/Makefile
index aae4e4a8..89c74a79 100644
--- a/drivers/power/supply/Makefile
+++ b/drivers/power/supply/Makefile
@@ -55,6 +55,7 @@ obj-$(CONFIG_BATTERY_TWL4030_MADC)	+= twl4030_madc_battery.o
 obj-$(CONFIG_CHARGER_88PM860X)	+= 88pm860x_charger.o
 obj-$(CONFIG_CHARGER_PCF50633)	+= pcf50633-charger.o
 obj-$(CONFIG_BATTERY_JZ4740)	+= jz4740-battery.o
+obj-$(CONFIG_BATTERY_MIYOO)	+= miyoo-battery.o
 obj-$(CONFIG_BATTERY_RX51)	+= rx51_battery.o
 obj-$(CONFIG_AB8500_BM)		+= ab8500_bmdata.o ab8500_charger.o ab8500_fg.o ab8500_btemp.o abx500_chargalg.o pm2301_charger.o
 obj-$(CONFIG_CHARGER_CPCAP)	+= cpcap-charger.o
diff --git a/drivers/power/supply/miyoo-battery.c b/drivers/power/supply/miyoo-battery.c
new file mode 100644
index 00000000..d084f56c
--- /dev/null
+++ b/drivers/power/supply/miyoo-battery.c
@@ -0,0 +1,199 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option)any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+#include <linux/module.h>
+#include <linux/param.h>
+#include <linux/platform_device.h>
+#include <linux/power_supply.h>
+#include <linux/slab.h>
+#include <linux/of.h>
+
+#include <asm/io.h>
+#include <asm/gpio.h>
+#include <asm/arch-suniv/cpu.h>
+#include <asm/arch-suniv/dma.h>
+#include <asm/arch-suniv/gpio.h>
+#include <asm/arch-suniv/intc.h>
+#include <asm/arch-suniv/lcdc.h>
+#include <asm/arch-suniv/debe.h>
+#include <asm/arch-suniv/clock.h>
+#include <asm/arch-suniv/common.h>
+
+#include <linux/timer.h>
+#include <linux/backlight.h>
+#include <linux/gpio.h>
+
+static int g_time_interval = 300000;
+static int g_rumble_interval = 2000;
+static int g_flash_interval = 500;
+struct timer_list g_timer;
+struct timer_list g_rumble_timer;
+struct timer_list g_flash_timer;
+
+static unsigned int battery_low=3550;
+module_param(battery_low,int,0660);
+
+static bool use_flash=false;
+module_param(use_flash,bool,0660);
+
+static bool use_rumble=false;
+module_param(use_rumble,bool,0660);
+
+static bool use_charge_status=false;
+module_param(use_charge_status,bool,0660);
+
+int flash_count=0;
+
+struct suniv_device_info {
+	struct device *dev;
+	struct power_supply *bat;
+	struct power_supply_desc bat_desc;
+};
+uint8_t *lradc;
+
+static int suniv_battery_get_property(struct power_supply *psy, enum power_supply_property psp, union power_supply_propval *val)
+{
+	switch (psp) {
+	case POWER_SUPPLY_PROP_VOLTAGE_NOW:
+		val->intval = (readl(lradc + 0x0c) * 3 * 3 * 10);
+		break;
+    case POWER_SUPPLY_PROP_STATUS:
+        if(use_charge_status) {
+            if (gpio_get_value(((32 * 4) + 7))) // sup m3
+                val->intval = POWER_SUPPLY_STATUS_CHARGING;
+            else
+                val->intval = POWER_SUPPLY_STATUS_DISCHARGING;
+        } else {
+            val->intval = POWER_SUPPLY_STATUS_UNKNOWN;
+        }
+        break;
+	default:
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static enum power_supply_property suniv_battery_props[] = {
+	POWER_SUPPLY_PROP_VOLTAGE_NOW,
+    POWER_SUPPLY_PROP_STATUS
+};
+
+static int suniv_battery_probe(struct platform_device *pdev)
+{
+	struct suniv_device_info *di=NULL;
+	struct power_supply_config psy_cfg={0};
+
+	di = devm_kzalloc(&pdev->dev, sizeof(*di), GFP_KERNEL);
+	if (!di) {
+		return -ENOMEM;
+  }
+	platform_set_drvdata(pdev, di);
+  
+  lradc = (uint8_t*)ioremap(SUNIV_LRADC_BASE, 4096);
+  suniv_setbits(lradc, 1);
+
+	di->dev = &pdev->dev;
+	di->bat_desc.name = "miyoo-battery";
+	di->bat_desc.type = POWER_SUPPLY_TYPE_BATTERY;
+	di->bat_desc.properties = suniv_battery_props;
+	di->bat_desc.num_properties = ARRAY_SIZE(suniv_battery_props);
+	di->bat_desc.get_property = suniv_battery_get_property;
+	psy_cfg.drv_data = di;
+	di->bat = power_supply_register(di->dev, &di->bat_desc, &psy_cfg);
+	return 0;
+}
+
+static int suniv_battery_remove(struct platform_device *pdev)
+{
+	struct suniv_device_info *di = platform_get_drvdata(pdev);
+
+	power_supply_unregister(di->bat);
+  iounmap(lradc);
+	return 0;
+}
+
+void _RumbleTimer(unsigned long data) {
+  extern void MIYOO_RUMBLE(bool);
+  MIYOO_RUMBLE(false);
+}
+
+void _FlashTimer(unsigned long data) {
+  static struct backlight_device *bd;
+  bd = backlight_device_get_by_type(BACKLIGHT_RAW);
+  if (data < 10) {
+    if(data % 2 == 0) {
+      backlight_device_set_brightness(bd, 9);
+    } else {
+      backlight_device_set_brightness(bd, 5);
+    }
+    setup_timer(&g_flash_timer, _FlashTimer, data + 1);
+    mod_timer(&g_flash_timer, jiffies + msecs_to_jiffies(g_flash_interval));
+  } else {
+    backlight_device_set_brightness(bd, 9);
+  }
+}
+
+void _TimerHandler(unsigned long data) {
+
+  if((readl(lradc + 0x0c) * 3 * 3 * 10) < battery_low) {
+    if(use_flash) {
+      setup_timer(&g_flash_timer, _FlashTimer, 0);
+      mod_timer(&g_flash_timer, jiffies + msecs_to_jiffies(g_flash_interval));
+    }
+    if(use_rumble) {
+      extern void MIYOO_RUMBLE(bool);
+      MIYOO_RUMBLE(true);
+      setup_timer(&g_rumble_timer, _RumbleTimer, 1);
+      mod_timer(&g_rumble_timer, jiffies + msecs_to_jiffies(g_rumble_interval));
+    }
+  }
+  mod_timer( &g_timer, jiffies + msecs_to_jiffies(g_time_interval));
+}
+
+static int __init battery_init(void) {
+  setup_timer(&g_timer, _TimerHandler, 0);
+  mod_timer( &g_timer, jiffies + msecs_to_jiffies(10000));
+  return 0;
+}
+
+static void __exit battery_exit(void)
+{
+    del_timer(&g_timer);
+    del_timer(&g_rumble_timer);
+    del_timer(&g_flash_timer);
+}
+
+module_init(battery_init);
+module_exit(battery_exit);
+
+static const struct of_device_id miyoo_battery_of_match[] = {
+	{.compatible = "allwinner,suniv-f1c500s-battery", },{},
+};
+MODULE_DEVICE_TABLE(of, miyoo_battery_of_match);
+
+static struct platform_driver suniv_battery_driver = {
+	.probe = suniv_battery_probe,
+	.remove = suniv_battery_remove,
+	.driver = {
+		.name = "miyoo-battery",
+		.of_match_table = of_match_ptr(miyoo_battery_of_match),
+	},
+};
+module_platform_driver(suniv_battery_driver);
+
+MODULE_AUTHOR("Steward Fu <steward.fu@gmail.com>");
+MODULE_DESCRIPTION("Miyoo battery driver");
+MODULE_LICENSE("GPL");
+
diff --git a/drivers/pwm/Kconfig b/drivers/pwm/Kconfig
index 763ee50e..da446ab4 100644
--- a/drivers/pwm/Kconfig
+++ b/drivers/pwm/Kconfig
@@ -434,7 +434,7 @@ config PWM_STMPE
 	  This enables support for the PWMs found in the STMPE I/O
 	  expanders.
 
-config PWM_SUN4I
+config PWM_SUNIV
 	tristate "Allwinner PWM support"
 	depends on ARCH_SUNXI || COMPILE_TEST
 	depends on HAS_IOMEM && COMMON_CLK
diff --git a/drivers/pwm/Makefile b/drivers/pwm/Makefile
index 0258a745..072fbcb8 100644
--- a/drivers/pwm/Makefile
+++ b/drivers/pwm/Makefile
@@ -43,7 +43,7 @@ obj-$(CONFIG_PWM_STI)		+= pwm-sti.o
 obj-$(CONFIG_PWM_STM32)		+= pwm-stm32.o
 obj-$(CONFIG_PWM_STM32_LP)	+= pwm-stm32-lp.o
 obj-$(CONFIG_PWM_STMPE)		+= pwm-stmpe.o
-obj-$(CONFIG_PWM_SUN4I)		+= pwm-sun4i.o
+obj-$(CONFIG_PWM_SUNIV)		+= pwm-suniv.o
 obj-$(CONFIG_PWM_TEGRA)		+= pwm-tegra.o
 obj-$(CONFIG_PWM_TIECAP)	+= pwm-tiecap.o
 obj-$(CONFIG_PWM_TIEHRPWM)	+= pwm-tiehrpwm.o
diff --git a/drivers/pwm/pwm-sun4i.c b/drivers/pwm/pwm-sun4i.c
index 6d23f1d1..54cde8d3 100644
--- a/drivers/pwm/pwm-sun4i.c
+++ b/drivers/pwm/pwm-sun4i.c
@@ -342,6 +342,10 @@ static const struct sun4i_pwm_data sun4i_pwm_data_h3 = {
 };
 
 static const struct of_device_id sun4i_pwm_dt_ids[] = {
+	{
+		.compatible = "allwinner,suniv-pwm",
+		.data = &sun4i_pwm_data_a10,
+	}, {
 	{
 		.compatible = "allwinner,sun4i-a10-pwm",
 		.data = &sun4i_pwm_data_a10,
diff --git a/drivers/pwm/pwm-suniv.c b/drivers/pwm/pwm-suniv.c
new file mode 100644
index 00000000..a5e052ed
--- /dev/null
+++ b/drivers/pwm/pwm-suniv.c
@@ -0,0 +1,510 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option)any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+#include <linux/cdev.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/bitops.h>
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/err.h>
+#include <linux/io.h>
+#include <linux/jiffies.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/platform_device.h>
+#include <linux/pwm.h>
+#include <linux/slab.h>
+#include <linux/spinlock.h>
+#include <linux/time.h>
+
+#include <asm/io.h>
+#include <asm/gpio.h>
+#include <asm/arch-suniv/dma.h>
+#include <asm/arch-suniv/cpu.h>
+#include <asm/arch-suniv/gpio.h>
+#include <asm/arch-suniv/clock.h>
+#include <asm/arch-suniv/codec.h>
+#include <asm/arch-suniv/common.h>
+
+#define MIYOO_VIR_SET_MODE  _IOWR(0x100, 0, unsigned long)
+#define MIYOO_VIR_SET_VER   _IOWR(0x101, 0, unsigned long)
+
+#define PWM_CTRL_REG        0x0
+#define PWM_CH_PRD_BASE     0x4
+#define PWM_CH_PRD_OFFSET   0x4
+#define PWM_CH_PRD(ch)      (PWM_CH_PRD_BASE + PWM_CH_PRD_OFFSET * (ch))
+
+#define PWMCH_OFFSET        15
+#define PWM_PRESCAL_MASK    GENMASK(3, 0)
+#define PWM_PRESCAL_OFF     0
+#define PWM_EN              BIT(4)
+#define PWM_ACT_STATE       BIT(5)
+#define PWM_CLK_GATING      BIT(6)
+#define PWM_MODE            BIT(7)
+#define PWM_PULSE           BIT(8)
+#define PWM_BYPASS          BIT(9)
+
+#define PWM_RDY_BASE        28
+#define PWM_RDY_OFFSET      1
+#define PWM_RDY(ch)         BIT(PWM_RDY_BASE + PWM_RDY_OFFSET * (ch))
+
+#define PWM_PRD(prd)        (((prd) - 1) << 16)
+#define PWM_PRD_MASK        GENMASK(15, 0)
+#define PWM_DTY_MASK        GENMASK(15, 0)
+
+#define PWM_REG_PRD(reg)            ((((reg) >> 16) & PWM_PRD_MASK) + 1)
+#define PWM_REG_DTY(reg)            ((reg) & PWM_DTY_MASK)
+#define PWM_REG_PRESCAL(reg, chan)  (((reg) >> ((chan) * PWMCH_OFFSET)) & PWM_PRESCAL_MASK)
+#define BIT_CH(bit, chan)           ((bit) << ((chan) * PWMCH_OFFSET))
+
+static const u32 prescaler_table[] = {
+  120,
+  180,
+  240,
+  360,
+  480,
+  0,
+  0,
+  0,
+  12000,
+  24000,
+  36000,
+  48000,
+  72000,
+  0,
+  0,
+  0, /* Actually 1 but tested separately */
+};
+
+struct suniv_pwm_data {
+  bool has_prescaler_bypass;
+  bool has_rdy;
+  unsigned int npwm;
+};
+
+struct suniv_pwm_chip {
+  struct pwm_chip chip;
+  struct clk *clk;
+  void __iomem *base;
+  spinlock_t ctrl_lock;
+  const struct suniv_pwm_data *data;
+  unsigned long next_period[2];
+  bool needs_delay[2];
+};
+
+static int major = -1;
+static int motor_ver = 3;
+module_param(motor_ver,int,0660);
+static struct cdev mycdev;
+static struct class *myclass = NULL;
+
+static inline struct suniv_pwm_chip *to_suniv_pwm_chip(struct pwm_chip *chip)
+{
+  return container_of(chip, struct suniv_pwm_chip, chip);
+}
+
+static inline u32 suniv_pwm_readl(struct suniv_pwm_chip *chip, unsigned long offset)
+{
+  return readl(chip->base + offset);
+}
+
+static inline void suniv_pwm_writel(struct suniv_pwm_chip *chip, u32 val, unsigned long offset)
+{
+  writel(val, chip->base + offset);
+}
+
+static void suniv_pwm_get_state(struct pwm_chip *chip, struct pwm_device *pwm, struct pwm_state *state)
+{
+  struct suniv_pwm_chip *suniv_pwm = to_suniv_pwm_chip(chip);
+  u64 clk_rate, tmp;
+  u32 val;
+  unsigned int prescaler;
+
+  clk_rate = clk_get_rate(suniv_pwm->clk);
+  val = suniv_pwm_readl(suniv_pwm, PWM_CTRL_REG);
+  if ((val == PWM_PRESCAL_MASK) && suniv_pwm->data->has_prescaler_bypass) {
+    prescaler = 1;
+  }
+  else {
+    prescaler = prescaler_table[PWM_REG_PRESCAL(val, pwm->hwpwm)];
+  }
+
+  if (prescaler == 0) {
+    return;
+  }
+
+  if (val & BIT_CH(PWM_ACT_STATE, pwm->hwpwm)) {
+    state->polarity = PWM_POLARITY_NORMAL;
+  }
+  else {
+    state->polarity = PWM_POLARITY_INVERSED;
+  }
+
+  if (val & BIT_CH(PWM_CLK_GATING | PWM_EN, pwm->hwpwm)) {
+    state->enabled = true;
+  }
+  else {
+    state->enabled = false;
+  }
+
+  val = suniv_pwm_readl(suniv_pwm, PWM_CH_PRD(pwm->hwpwm));
+  tmp = prescaler * NSEC_PER_SEC * PWM_REG_DTY(val);
+  state->duty_cycle = DIV_ROUND_CLOSEST_ULL(tmp, clk_rate);
+  tmp = prescaler * NSEC_PER_SEC * PWM_REG_PRD(val);
+  state->period = DIV_ROUND_CLOSEST_ULL(tmp, clk_rate);
+}
+
+static int suniv_pwm_calculate(struct suniv_pwm_chip *suniv_pwm, struct pwm_state *state, u32 *dty, u32 *prd, unsigned int *prsclr)
+{
+  u64 clk_rate, div = 0;
+  unsigned int pval, prescaler = 0;
+
+  clk_rate = clk_get_rate(suniv_pwm->clk);
+  if (suniv_pwm->data->has_prescaler_bypass) {
+    // first, test without any prescaler when available
+    prescaler = PWM_PRESCAL_MASK;
+    pval = 1;
+    /*
+     * When not using any prescaler, the clock period in nanoseconds
+     * is not an integer so round it half up instead of
+     * truncating to get less surprising values.
+     */
+    div = clk_rate * state->period + NSEC_PER_SEC / 2;
+    do_div(div, NSEC_PER_SEC);
+    if (div - 1 > PWM_PRD_MASK) {
+      prescaler = 0;
+    }
+  }
+
+  if (prescaler == 0) {
+    /* Go up from the first divider */
+    for (prescaler = 0; prescaler < PWM_PRESCAL_MASK; prescaler++) {
+      if (!prescaler_table[prescaler]) {
+        continue;
+      }
+      pval = prescaler_table[prescaler];
+      div = clk_rate;
+      do_div(div, pval);
+      div = div * state->period;
+      do_div(div, NSEC_PER_SEC);
+      if (div - 1 <= PWM_PRD_MASK) {
+        break;
+      }
+    }
+
+    if (div - 1 > PWM_PRD_MASK) {
+      return -EINVAL;
+    }
+  }
+
+  *prd = div;
+  div *= state->duty_cycle;
+  do_div(div, state->period);
+  *dty = div;
+  *prsclr = prescaler;
+
+  div = (u64)pval * NSEC_PER_SEC * *prd;
+  state->period = DIV_ROUND_CLOSEST_ULL(div, clk_rate);
+  div = (u64)pval * NSEC_PER_SEC * *dty;
+  state->duty_cycle = DIV_ROUND_CLOSEST_ULL(div, clk_rate);
+  return 0;
+}
+
+static int suniv_pwm_apply(struct pwm_chip *chip, struct pwm_device *pwm, struct pwm_state *state)
+{
+  int ret;
+  u32 ctrl;
+  unsigned long now;
+  unsigned int delay_us;
+  struct pwm_state cstate;
+  struct suniv_pwm_chip *suniv_pwm = to_suniv_pwm_chip(chip);
+
+  pwm_get_state(pwm, &cstate);
+  if (!cstate.enabled) {
+    ret = clk_prepare_enable(suniv_pwm->clk);
+    if (ret) {
+      dev_err(chip->dev, "failed to enable PWM clock\n");
+      return ret;
+    }
+  }
+
+  spin_lock(&suniv_pwm->ctrl_lock);
+  ctrl = suniv_pwm_readl(suniv_pwm, PWM_CTRL_REG);
+
+  if ((cstate.period != state->period) || (cstate.duty_cycle != state->duty_cycle)) {
+    u32 period, duty, val;
+    unsigned int prescaler;
+
+    ret = suniv_pwm_calculate(suniv_pwm, state, &duty, &period, &prescaler);
+    if (ret) {
+      dev_err(chip->dev, "period exceeds the maximum value\n");
+      spin_unlock(&suniv_pwm->ctrl_lock);
+      if (!cstate.enabled) {
+        clk_disable_unprepare(suniv_pwm->clk);
+      }
+      return ret;
+    }
+
+    if (PWM_REG_PRESCAL(ctrl, pwm->hwpwm) != prescaler) {
+      // prescaler changed, the clock has to be gated
+      ctrl &= ~BIT_CH(PWM_CLK_GATING, pwm->hwpwm);
+      suniv_pwm_writel(suniv_pwm, ctrl, PWM_CTRL_REG);
+      ctrl &= ~BIT_CH(PWM_PRESCAL_MASK, pwm->hwpwm);
+      ctrl |= BIT_CH(prescaler, pwm->hwpwm);
+    }
+
+    val = (duty & PWM_DTY_MASK) | PWM_PRD(period);
+    suniv_pwm_writel(suniv_pwm, val, PWM_CH_PRD(pwm->hwpwm));
+    suniv_pwm->next_period[pwm->hwpwm] = jiffies + usecs_to_jiffies(cstate.period / 1000 + 1);
+    suniv_pwm->needs_delay[pwm->hwpwm] = true;
+  }
+
+  if (state->polarity != PWM_POLARITY_NORMAL) {
+    ctrl &= ~BIT_CH(PWM_ACT_STATE, pwm->hwpwm);
+  }
+  else {
+    ctrl |= BIT_CH(PWM_ACT_STATE, pwm->hwpwm);
+  }
+
+  ctrl |= BIT_CH(PWM_CLK_GATING, pwm->hwpwm);
+  if (state->enabled) {
+    ctrl |= BIT_CH(PWM_EN, pwm->hwpwm);
+  } 
+  else if (!suniv_pwm->needs_delay[pwm->hwpwm]) {
+    ctrl &= ~BIT_CH(PWM_EN, pwm->hwpwm);
+    ctrl &= ~BIT_CH(PWM_CLK_GATING, pwm->hwpwm);
+  }
+  suniv_pwm_writel(suniv_pwm, ctrl, PWM_CTRL_REG);
+  spin_unlock(&suniv_pwm->ctrl_lock);
+
+  if (state->enabled) {
+    return 0;
+  }
+
+  if (!suniv_pwm->needs_delay[pwm->hwpwm]) {
+    clk_disable_unprepare(suniv_pwm->clk);
+    return 0;
+  }
+
+  // We need a full period to elapse before disabling the channel.
+  now = jiffies;
+  if (suniv_pwm->needs_delay[pwm->hwpwm] && time_before(now, suniv_pwm->next_period[pwm->hwpwm])) {
+    delay_us = jiffies_to_usecs(suniv_pwm->next_period[pwm->hwpwm] - now);
+    if ((delay_us / 500) > MAX_UDELAY_MS) {
+      msleep(delay_us / 1000 + 1);
+    }
+    else {
+      usleep_range(delay_us, delay_us * 2);
+    }
+  }
+  suniv_pwm->needs_delay[pwm->hwpwm] = false;
+
+  spin_lock(&suniv_pwm->ctrl_lock);
+  ctrl = suniv_pwm_readl(suniv_pwm, PWM_CTRL_REG);
+  ctrl &= ~BIT_CH(PWM_CLK_GATING, pwm->hwpwm);
+  ctrl &= ~BIT_CH(PWM_EN, pwm->hwpwm);
+  suniv_pwm_writel(suniv_pwm, ctrl, PWM_CTRL_REG);
+  spin_unlock(&suniv_pwm->ctrl_lock);
+  clk_disable_unprepare(suniv_pwm->clk);
+  return 0;
+}
+
+static const struct pwm_ops suniv_pwm_ops = {
+  .apply = suniv_pwm_apply,
+  .get_state = suniv_pwm_get_state,
+  .owner = THIS_MODULE,
+};
+
+static const struct suniv_pwm_data suniv_pwm_data_a10 = {
+  .has_prescaler_bypass = false,
+  .has_rdy = false,
+  .npwm = 2,
+};
+
+static const struct of_device_id suniv_pwm_dt_ids[] = {
+  {
+    .compatible = "allwinner,suniv-pwm",
+    .data = &suniv_pwm_data_a10,
+  }, {
+  },
+};
+MODULE_DEVICE_TABLE(of, suniv_pwm_dt_ids);
+
+static int get_motor_pin(int ver)
+{
+  switch(ver){
+  case 1:
+    return ((32 * 4) + 1);
+  case 2: case 3: case 4:
+    return ((32 * 4) + 12);
+  }
+  return -1;
+}
+
+static int do_gpio_request(int ver)
+{
+  const char *name = "miyoo_motor";
+  int pin = get_motor_pin(ver);
+
+  if(pin < 0){
+    printk("failed to config miyoo motor for this miyoo device\n");
+    return -1;
+  }
+  if(gpio_request(pin, name) < 0){
+    printk("failed to request gpio, ver:%d, pin:%d, name:%s\n", ver, pin, name);
+    return -1;
+  }
+  gpio_direction_output(pin, 1);
+  printk("miyoo motor config as v%d\n", ver);
+  return 0;
+}
+
+static void do_gpio_free(int ver)
+{
+  int pin = get_motor_pin(ver);
+  
+  if(pin > 0){
+    gpio_free(pin);
+  }
+}
+
+extern void MIYOO_RUMBLE(unsigned int rumble){
+  int pin = get_motor_pin(motor_ver);
+  if(pin > 0){
+    if(rumble) {
+      gpio_set_value(pin, 0);
+    } else {
+      gpio_set_value(pin, 1);
+    }
+  }
+}
+
+EXPORT_SYMBOL_GPL(MIYOO_RUMBLE);
+
+
+static int myopen(struct inode *inode, struct file *file)
+{
+  return 0;
+}
+
+static int myclose(struct inode *inode, struct file *file)
+{
+  return 0;
+}
+
+static long myioctl(struct file *filp, unsigned int cmd, unsigned long arg)
+{
+  int pin = get_motor_pin(motor_ver);
+
+  switch(cmd){
+  case MIYOO_VIR_SET_MODE:
+    if(pin > 0){
+      gpio_set_value(pin, arg ? 1 : 0);
+    }
+    break;
+  case MIYOO_VIR_SET_VER:
+    if((arg == motor_ver) || (pin < 0)){
+      break;
+    }
+
+    do_gpio_free(motor_ver);
+    motor_ver = arg;
+    do_gpio_request(motor_ver);
+    break;
+  }
+  return 0;
+}
+
+static const struct file_operations myfops = {
+  .owner = THIS_MODULE,
+  .open = myopen,
+  .release = myclose,
+  .unlocked_ioctl = myioctl,
+};
+
+static int suniv_pwm_probe(struct platform_device *pdev)
+{
+  int ret;
+  struct resource *res;
+  struct suniv_pwm_chip *pwm;
+  const struct of_device_id *match;
+
+  match = of_match_device(suniv_pwm_dt_ids, &pdev->dev);
+  pwm = devm_kzalloc(&pdev->dev, sizeof(*pwm), GFP_KERNEL);
+  if (!pwm) {
+    return -ENOMEM;
+  }
+
+  res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+  pwm->base = devm_ioremap_resource(&pdev->dev, res);
+  if (IS_ERR(pwm->base)) {
+    return PTR_ERR(pwm->base);
+  }
+
+  pwm->clk = devm_clk_get(&pdev->dev, NULL);
+  if (IS_ERR(pwm->clk)) {
+    return PTR_ERR(pwm->clk);
+  }
+
+  pwm->data = match->data;
+  pwm->chip.dev = &pdev->dev;
+  pwm->chip.ops = &suniv_pwm_ops;
+  pwm->chip.base = -1;
+  pwm->chip.npwm = pwm->data->npwm;
+  pwm->chip.of_xlate = of_pwm_xlate_with_flags;
+  pwm->chip.of_pwm_n_cells = 3;
+  spin_lock_init(&pwm->ctrl_lock);
+
+  ret = pwmchip_add(&pwm->chip);
+  if (ret < 0) {
+    dev_err(&pdev->dev, "failed to add PWM chip: %d\n", ret);
+    return ret;
+  }
+  platform_set_drvdata(pdev, pwm);
+
+  alloc_chrdev_region(&major, 0, 1, "miyoo_vir");
+  myclass = class_create(THIS_MODULE, "miyoo_vir");
+  device_create(myclass, NULL, major, NULL, "miyoo_vir");
+  cdev_init(&mycdev, &myfops);
+  cdev_add(&mycdev, major, 1); 
+
+// motor_ver = 1;
+  do_gpio_request(motor_ver);
+  return 0;
+}
+
+static int suniv_pwm_remove(struct platform_device *pdev)
+{
+  struct suniv_pwm_chip *pwm = platform_get_drvdata(pdev);
+
+  return pwmchip_remove(&pwm->chip);
+}
+
+static struct platform_driver suniv_pwm_driver = {
+  .driver = {
+    .name = "suniv-pwm",
+    .of_match_table = suniv_pwm_dt_ids,
+  },
+  .probe = suniv_pwm_probe,
+  .remove = suniv_pwm_remove,
+};
+module_platform_driver(suniv_pwm_driver);
+
+MODULE_AUTHOR("Steward Fu <steward.fu@gmail.com>");
+MODULE_DESCRIPTION("Allwinner f1c500s PWM driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/usb/musb/sunxi.c b/drivers/usb/musb/sunxi.c
index dc353e24..3d763e9b 100644
--- a/drivers/usb/musb/sunxi.c
+++ b/drivers/usb/musb/sunxi.c
@@ -655,6 +655,18 @@ static struct musb_fifo_cfg sunxi_musb_mode_cfg_h3[] = {
 	MUSB_EP_FIFO_SINGLE(4, FIFO_RX, 512),
 };
 
+/* SUNIV OTG supports only 3 endpoints */
+#define SUNXI_MUSB_MAX_EP_NUM_SUNIV	4
+
+static struct musb_fifo_cfg sunxi_musb_mode_cfg_suniv[] = {
+        	MUSB_EP_FIFO_SINGLE(1, FIFO_TX, 512),
+        	MUSB_EP_FIFO_SINGLE(1, FIFO_RX, 512),
+        	MUSB_EP_FIFO_SINGLE(2, FIFO_TX, 512),
+        	MUSB_EP_FIFO_SINGLE(2, FIFO_RX, 512),
+        	MUSB_EP_FIFO_SINGLE(3, FIFO_TX, 512),
+        	MUSB_EP_FIFO_SINGLE(3, FIFO_RX, 512),
+};
+
 static const struct musb_hdrc_config sunxi_musb_hdrc_config = {
 	.fifo_cfg       = sunxi_musb_mode_cfg,
 	.fifo_cfg_size  = ARRAY_SIZE(sunxi_musb_mode_cfg),
@@ -677,6 +689,15 @@ static struct musb_hdrc_config sunxi_musb_hdrc_config_h3 = {
 	.dma		= 0,
 };
 
+static struct musb_hdrc_config sunxi_musb_hdrc_config_suniv = {
+        	.fifo_cfg       = sunxi_musb_mode_cfg_suniv,
+        	.fifo_cfg_size  = ARRAY_SIZE(sunxi_musb_mode_cfg_suniv),
+        	.multipoint	= true,
+        	.dyn_fifo	= true,
+        	.num_eps	= SUNXI_MUSB_MAX_EP_NUM_SUNIV,
+        	.ram_bits	= SUNXI_MUSB_RAM_BITS,
+};
+
 
 static int sunxi_musb_probe(struct platform_device *pdev)
 {
@@ -720,23 +741,27 @@ static int sunxi_musb_probe(struct platform_device *pdev)
 		return -EINVAL;
 	}
 	pdata.platform_ops	= &sunxi_musb_ops;
-	if (!of_device_is_compatible(np, "allwinner,sun8i-h3-musb"))
-		pdata.config = &sunxi_musb_hdrc_config;
-	else
-		pdata.config = &sunxi_musb_hdrc_config_h3;
+    pdata.config = &sunxi_musb_hdrc_config;
+    if (of_device_is_compatible(np, "allwinner,sun8i-h3-musb"))
+        pdata.config = &sunxi_musb_hdrc_config_h3;
+    if (of_device_is_compatible(np, "allwinner,suniv-f1c100s-musb"))
+        		pdata.config = &sunxi_musb_hdrc_config_suniv;
 
 	glue->dev = &pdev->dev;
 	INIT_WORK(&glue->work, sunxi_musb_work);
 	glue->host_nb.notifier_call = sunxi_musb_host_notifier;
 
-	if (of_device_is_compatible(np, "allwinner,sun4i-a10-musb"))
+	if (of_device_is_compatible(np, "allwinner,sun4i-a10-musb") ||
+	    of_device_is_compatible(np, "allwinner,suniv-f1c100s-musb")) {
 		set_bit(SUNXI_MUSB_FL_HAS_SRAM, &glue->flags);
+	}
 
 	if (of_device_is_compatible(np, "allwinner,sun6i-a31-musb"))
 		set_bit(SUNXI_MUSB_FL_HAS_RESET, &glue->flags);
 
 	if (of_device_is_compatible(np, "allwinner,sun8i-a33-musb") ||
-	    of_device_is_compatible(np, "allwinner,sun8i-h3-musb")) {
+	    of_device_is_compatible(np, "allwinner,sun8i-h3-musb") ||
+	    of_device_is_compatible(np, "allwinner,suniv-f1c100s-musb")) {
 		set_bit(SUNXI_MUSB_FL_HAS_RESET, &glue->flags);
 		set_bit(SUNXI_MUSB_FL_NO_CONFIGDATA, &glue->flags);
 	}
@@ -827,6 +852,7 @@ static int sunxi_musb_remove(struct platform_device *pdev)
 }
 
 static const struct of_device_id sunxi_musb_match[] = {
+	{ .compatible = "allwinner,suniv-f1c100s-musb", },
 	{ .compatible = "allwinner,sun4i-a10-musb", },
 	{ .compatible = "allwinner,sun6i-a31-musb", },
 	{ .compatible = "allwinner,sun8i-a33-musb", },
diff --git a/drivers/video/fbdev/Kconfig b/drivers/video/fbdev/Kconfig
index 30654608..d89df226 100644
--- a/drivers/video/fbdev/Kconfig
+++ b/drivers/video/fbdev/Kconfig
@@ -2495,3 +2495,66 @@ config FB_SM712
 	  This driver is also available as a module. The module will be
 	  called sm712fb. If you want to compile it as a module, say M
 	  here and read <file:Documentation/kbuild/modules.txt>.
+
+config FB_R61520
+	tristate "Renesas R61520 SLCD framebuffer support"
+	depends on FB
+	select FB_SYS_FILLRECT
+	select FB_SYS_COPYAREA
+	select FB_SYS_IMAGEBLIT
+	help
+	  Framebuffer driver for Renesas R61520 SLCD panel.
+
+config FB_GC9306
+	tristate "GC9306 SLCD framebuffer support"
+	depends on FB
+	select FB_SYS_FILLRECT
+	select FB_SYS_COPYAREA
+	select FB_SYS_IMAGEBLIT
+	help
+	  Framebuffer driver for GC9306 SLCD panel.
+
+config FB_ST7789S
+	tristate "ST7789S SLCD framebuffer support"
+	depends on FB
+	select FB_SYS_FILLRECT
+	select FB_SYS_COPYAREA
+	select FB_SYS_IMAGEBLIT
+	help
+	  Framebuffer driver for ST7789S SLCD panel.
+
+config FB_ST7789S_TE
+	tristate "ST7789S SLCD framebuffer support with TE pin"
+	depends on FB
+	select FB_SYS_FILLRECT
+	select FB_SYS_COPYAREA
+	select FB_SYS_IMAGEBLIT
+	help
+	  Framebuffer driver for ST7789S SLCD panel.
+
+config FB_RM68090
+	tristate "RM68090 SLCD framebuffer support"
+	depends on FB
+	select FB_SYS_FILLRECT
+	select FB_SYS_COPYAREA
+	select FB_SYS_IMAGEBLIT
+	help
+	  Framebuffer driver for RM68090 SLCD panel.
+
+config FB_HX8347D
+	tristate "HX8347D SLCD framebuffer support"
+	depends on FB
+	select FB_SYS_FILLRECT
+	select FB_SYS_COPYAREA
+	select FB_SYS_IMAGEBLIT
+	help
+	  Framebuffer driver for HX8347D SLCD panel.
+
+config FB_TVOUT
+tristate "TVOUT support"
+depends on FB
+        select FB_SYS_FILLRECT
+        select FB_SYS_COPYAREA
+        select FB_SYS_IMAGEBLIT
+        help
+Framebuffer driver for TVOUT.
\ No newline at end of file
diff --git a/drivers/video/fbdev/Makefile b/drivers/video/fbdev/Makefile
index 8895536a..1ff9991a 100644
--- a/drivers/video/fbdev/Makefile
+++ b/drivers/video/fbdev/Makefile
@@ -130,6 +130,13 @@ obj-$(CONFIG_FB_PUV3_UNIGFX)      += fb-puv3.o
 obj-$(CONFIG_FB_HYPERV)		  += hyperv_fb.o
 obj-$(CONFIG_FB_OPENCORES)	  += ocfb.o
 obj-$(CONFIG_FB_SM712)		  += sm712fb.o
+obj-$(CONFIG_FB_R61520)		  += r61520fb.o
+obj-$(CONFIG_FB_GC9306)		  += gc9306fb.o
+obj-$(CONFIG_FB_ST7789S)		  += st7789sfb.o
+obj-$(CONFIG_FB_ST7789S_TE)		  += st7789sTEfb.o
+obj-$(CONFIG_FB_RM68090)		  += rm68090fb.o
+obj-$(CONFIG_FB_HX8347D)		  += hx8347dfb.o
+obj-$(CONFIG_FB_TVOUT)		  += miyoo-tvout.o
 
 # Platform or fallback drivers go here
 obj-$(CONFIG_FB_UVESA)            += uvesafb.o
diff --git a/drivers/video/fbdev/gc9306fb.c b/drivers/video/fbdev/gc9306fb.c
new file mode 100644
index 00000000..972d1121
--- /dev/null
+++ b/drivers/video/fbdev/gc9306fb.c
@@ -0,0 +1,792 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option)any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#include <linux/cdev.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/fb.h>
+#include <linux/dma-mapping.h>
+#include <linux/device.h>
+#include <linux/platform_device.h>
+#include <linux/uaccess.h>
+#include <linux/pm_runtime.h>
+#include <linux/interrupt.h>
+#include <linux/wait.h>
+#include <linux/clk.h>
+#include <linux/cpufreq.h>
+#include <linux/console.h>
+#include <linux/spinlock.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+#include <linux/lcm.h>
+#include <linux/clk-provider.h>
+#include <video/of_display_timing.h>
+#include <linux/gpio.h>
+#include <linux/omapfb.h>
+#include <linux/compiler.h>
+#include <linux/workqueue.h>
+#include <linux/sched.h>
+#include <asm/io.h>
+#include <asm/gpio.h>
+#include <asm/arch-suniv/cpu.h>
+#include <asm/arch-suniv/dma.h>
+#include <asm/arch-suniv/gpio.h>
+#include <asm/arch-suniv/intc.h>
+#include <asm/arch-suniv/lcdc.h>
+#include <asm/arch-suniv/debe.h>
+#include <asm/arch-suniv/clock.h>
+#include <asm/arch-suniv/common.h>
+
+#define PALETTE_SIZE 256
+#define DRIVER_NAME  "q8-fb"
+#define MIYOO_FB0_PUT_OSD     _IOWR(0x100, 0, unsigned long)
+#define MIYOO_FB0_SET_MODE    _IOWR(0x101, 0, unsigned long)
+
+static bool invert=false;
+module_param(invert,bool,0660);
+
+struct myfb_par {
+    struct device *dev;
+    struct platform_device *pdev;
+
+    resource_size_t p_palette_base;
+    unsigned short *v_palette_base;
+
+    int yoffset;
+    void *vram_virt;
+    uint32_t vram_size;
+    dma_addr_t vram_phys;
+
+    int bpp;
+    int lcdc_irq;
+    u32 pseudo_palette[16];
+    struct fb_videomode mode;
+};
+
+struct suniv_iomm {
+    uint8_t *dma;
+    uint8_t *ccm;
+    uint8_t *gpio;
+    uint8_t *lcdc;
+    uint8_t *debe;
+    uint8_t *intc;
+    uint8_t *timer;
+};
+static int major = -1;
+static struct cdev mycdev;
+static struct class *myclass = NULL;
+struct timer_list mytimer;
+static struct suniv_iomm iomm={0};
+static struct myfb_par *mypar=NULL;
+static struct fb_var_screeninfo myfb_var={0};
+
+static struct fb_fix_screeninfo myfb_fix = {
+        .id = DRIVER_NAME,
+        .type = FB_TYPE_PACKED_PIXELS,
+        .type_aux = 0,
+        .visual = FB_VISUAL_TRUECOLOR,
+        .xpanstep = 0,
+        .ypanstep = 1,
+        .ywrapstep = 0,
+        .accel = FB_ACCEL_NONE
+};
+
+static void suniv_gpio_init(void)
+{
+    uint32_t r=0;
+
+    r = readl(iomm.gpio + PD_CFG0);
+    r&= 0x0000000f;
+    r|= 0x22222220;
+    writel(r, iomm.gpio + PD_CFG0);
+
+    r = readl(iomm.gpio + PD_CFG1);
+    r&= 0x000000f0;
+    r|= 0x22222202;
+    writel(r, iomm.gpio + PD_CFG1);
+
+    r = readl(iomm.gpio + PD_CFG2);
+    r&= 0xff000000;
+    r|= 0x00222222;
+    writel(r, iomm.gpio + PD_CFG2);
+
+    r = readl(iomm.gpio + PE_CFG1);
+    r&= 0xffff0fff;
+    r|= 0x00001000;
+    writel(r, iomm.gpio + PE_CFG1);
+    writel(0xffffffff, iomm.gpio + PE_DATA);
+}
+
+static uint32_t lcdc_wait_busy(void)
+{
+    uint32_t cnt=0;
+
+    suniv_setbits(iomm.lcdc + TCON0_CPU_IF_REG, (1 << 0));
+    ndelay(10);
+    while(1){
+        if(readl(iomm.lcdc + TCON0_CPU_IF_REG) & 0x00c00000){
+            if(cnt > 200){
+                return -1;
+            }
+            else{
+                cnt+= 1;
+            }
+        }
+        break;
+    }
+    return 0;
+}
+
+static uint32_t extend_16b_to_24b(uint32_t value)
+{
+    return ((value & 0xfc00) << 8) | ((value & 0x0300) << 6) | ((value & 0x00e0) << 5) | ((value & 0x001f) << 3);
+}
+
+static void lcdc_wr(uint8_t is_data, uint32_t data)
+{
+    while(lcdc_wait_busy());
+    if(is_data){
+        suniv_setbits(iomm.lcdc + TCON0_CPU_IF_REG, (1 << 25));
+    }
+    else{
+        suniv_clrbits(iomm.lcdc + TCON0_CPU_IF_REG, (1 << 25));
+    }
+    while(lcdc_wait_busy());
+    writel(extend_16b_to_24b(data), iomm.lcdc + TCON0_CPU_WR_REG);
+}
+
+static void lcdc_wr_cmd(uint32_t cmd)
+{
+    lcdc_wr(0, cmd);
+}
+
+static void lcdc_wr_dat(uint32_t cmd)
+{
+    lcdc_wr(1, cmd);
+}
+
+static void refresh_lcd(struct myfb_par *par)
+{
+    if(par->yoffset == 0){
+        suniv_setbits(iomm.debe + DEBE_MODE_CTRL_REG, (1 << 8));
+        suniv_clrbits(iomm.debe + DEBE_MODE_CTRL_REG, (1 << 9));
+    }
+    else{
+        suniv_clrbits(iomm.debe + DEBE_MODE_CTRL_REG, (1 << 8));
+        suniv_setbits(iomm.debe + DEBE_MODE_CTRL_REG, (1 << 9));
+    }
+    suniv_setbits(iomm.debe + DEBE_REGBUFF_CTRL_REG, (1 << 0));
+    suniv_setbits(iomm.lcdc + TCON_CTRL_REG, (1 << 31));
+}
+
+static irqreturn_t lcdc_irq_handler(int irq, void *arg)
+{
+    refresh_lcd(mypar);
+    suniv_clrbits(iomm.lcdc + TCON_INT_REG0, (1 << 15));
+    return IRQ_HANDLED;
+}
+
+static void init_lcd(void)
+{
+    suniv_gpio_init();
+    suniv_clrbits(iomm.lcdc + PE_DATA, (1 << 11));
+    mdelay(150);
+    suniv_setbits(iomm.lcdc + PE_DATA, (1 << 11));
+    mdelay(150);
+    
+    lcdc_wr_cmd(0x11);       // SleepIn
+    mdelay(120);
+    lcdc_wr_cmd(0x28);  // display off
+    //------------- display control setting -----------------------//
+    lcdc_wr_cmd(0xfe);
+    lcdc_wr_cmd(0xef);
+    lcdc_wr_cmd(0x36);
+    //  lcdc_wr_dat(0x48);      // 原始方向：    Y=0 X=1 V=0 L=0     0x48
+    lcdc_wr_dat(0x28);
+    lcdc_wr_cmd(0x3a);
+    lcdc_wr_dat(0x05);
+
+    lcdc_wr_cmd(0x35);
+    lcdc_wr_dat(0x00);
+    lcdc_wr_cmd(0x44);
+    lcdc_wr_dat(0x00);
+    lcdc_wr_dat(0x60);
+
+    //------end display control setting----//
+    //------Power Control Registers Initial----//
+    lcdc_wr_cmd(0xa4);
+    lcdc_wr_dat(0x44);
+    lcdc_wr_dat(0x44);
+    lcdc_wr_cmd(0xa5);
+    lcdc_wr_dat(0x42);
+    lcdc_wr_dat(0x42);
+    lcdc_wr_cmd(0xaa);
+    lcdc_wr_dat(0x88);
+    lcdc_wr_dat(0x88);
+    lcdc_wr_cmd(0xe8);
+    lcdc_wr_dat(0x11);
+    lcdc_wr_dat(0x71);
+    lcdc_wr_cmd(0xe3);
+    lcdc_wr_dat(0x01);
+    lcdc_wr_dat(0x10);
+    lcdc_wr_cmd(0xff);
+    lcdc_wr_dat(0x61);
+    lcdc_wr_cmd(0xAC);
+    lcdc_wr_dat(0x00);
+
+    lcdc_wr_cmd(0xAe);
+    lcdc_wr_dat(0x2b);//20161020
+
+    lcdc_wr_cmd(0xAd);
+    lcdc_wr_dat(0x33);
+    lcdc_wr_cmd(0xAf);
+    lcdc_wr_dat(0x55);
+    lcdc_wr_cmd(0xa6);
+    lcdc_wr_dat(0x2a);
+    lcdc_wr_dat(0x2a);
+    lcdc_wr_cmd(0xa7);
+    lcdc_wr_dat(0x2b);
+    lcdc_wr_dat(0x2b);
+    lcdc_wr_cmd(0xa8);
+    lcdc_wr_dat(0x18);
+    lcdc_wr_dat(0x18);
+    lcdc_wr_cmd(0xa9);
+    lcdc_wr_dat(0x2a);
+    lcdc_wr_dat(0x2a);
+    //-----display window 240X320---------//
+    lcdc_wr_cmd(0x2a);
+    lcdc_wr_dat(0x00);
+    lcdc_wr_dat(0x00);
+    lcdc_wr_dat(0x01);
+    lcdc_wr_dat(0x3f);
+    lcdc_wr_cmd(0x2b);       // 0x002B = 239
+    lcdc_wr_dat(0x00);
+    lcdc_wr_dat(0x00);
+    lcdc_wr_dat(0x00);
+    lcdc_wr_dat(0xef);      // 0x013F = 319
+    if (invert) {
+        lcdc_wr_cmd(0x21); // Display Inversion On (for colors)
+    } else {
+        lcdc_wr_cmd(0x20); //  Display Inversion Off (for colors)
+    }
+    //    lcdc_wr_cmd(0x2c);
+    //--------end display window --------------//
+    //------------gamma setting------------------//
+    lcdc_wr_cmd(0xf0);
+    lcdc_wr_dat(0x02);
+    lcdc_wr_dat(0x01);
+    lcdc_wr_dat(0x00);
+    lcdc_wr_dat(0x00);
+    lcdc_wr_dat(0x02);
+    lcdc_wr_dat(0x09);
+
+    lcdc_wr_cmd(0xf1);
+    lcdc_wr_dat(0x01);
+    lcdc_wr_dat(0x02);
+    lcdc_wr_dat(0x00);
+    lcdc_wr_dat(0x11);
+    lcdc_wr_dat(0x1c);
+    lcdc_wr_dat(0x15);
+
+    lcdc_wr_cmd(0xf2);
+    lcdc_wr_dat(0x0a);
+    lcdc_wr_dat(0x07);
+    lcdc_wr_dat(0x29);
+    lcdc_wr_dat(0x04);
+    lcdc_wr_dat(0x04);
+    lcdc_wr_dat(0x38);//v43n  39
+
+    lcdc_wr_cmd(0xf3);
+    lcdc_wr_dat(0x15);
+    lcdc_wr_dat(0x0d);
+    lcdc_wr_dat(0x55);
+    lcdc_wr_dat(0x04);
+    lcdc_wr_dat(0x03);
+    lcdc_wr_dat(0x65);//v43p 66
+
+    lcdc_wr_cmd(0xf4);
+    lcdc_wr_dat(0x0f);//v50n
+    lcdc_wr_dat(0x1d);//v57n
+    lcdc_wr_dat(0x1e);//v59n
+    lcdc_wr_dat(0x0a);//v61n 0b
+    lcdc_wr_dat(0x0d);//v62n 0d
+    lcdc_wr_dat(0x0f);
+
+    lcdc_wr_cmd(0xf5);
+    lcdc_wr_dat(0x05);//v50p
+    lcdc_wr_dat(0x12);//v57p
+    lcdc_wr_dat(0x11);//v59p
+    lcdc_wr_dat(0x34);//v61p 35
+    lcdc_wr_dat(0x34);//v62p 34
+    lcdc_wr_dat(0x0f);
+    //-------end gamma setting----//
+    lcdc_wr_cmd(0x11);       // SleepOut
+    mdelay(120);
+    lcdc_wr_cmd(0x29);       // Display ON
+    lcdc_wr_cmd(0x2c);       // Display ON
+
+    mypar->yoffset = 0;
+    memset(mypar->vram_virt, 0, 320*240*4);
+}
+
+static void suniv_lcdc_init(struct myfb_par *par)
+{
+    uint32_t ret=0, p1=0, p2=0;
+
+    writel(0, iomm.lcdc + TCON_CTRL_REG);
+    writel(0, iomm.lcdc + TCON_INT_REG0);
+    ret = readl(iomm.lcdc + TCON_CLK_CTRL_REG);
+    ret&= ~(0xf << 28);
+    writel(ret, iomm.lcdc + TCON_CLK_CTRL_REG);
+    writel(0xffffffff, iomm.lcdc + TCON0_IO_CTRL_REG1);
+    writel(0xffffffff, iomm.lcdc + TCON1_IO_CTRL_REG1);
+
+    suniv_setbits(iomm.debe + DEBE_MODE_CTRL_REG, (1 << 0));
+    writel(par->mode.xres << 4, iomm.debe + DEBE_LAY0_LINEWIDTH_REG);
+    writel(par->mode.xres << 4, iomm.debe + DEBE_LAY1_LINEWIDTH_REG);
+    writel((((par->mode.yres) - 1) << 16) | (((par->mode.xres) - 1) << 0), iomm.debe + DEBE_DISP_SIZE_REG);
+    writel((((par->mode.yres) - 1) << 16) | (((par->mode.xres) - 1) << 0), iomm.debe + DEBE_LAY0_SIZE_REG);
+    writel((((par->mode.yres) - 1) << 16) | (((par->mode.xres) - 1) << 0), iomm.debe + DEBE_LAY1_SIZE_REG);
+    writel((5 << 8), iomm.debe + DEBE_LAY0_ATT_CTRL_REG1);
+    writel((5 << 8), iomm.debe + DEBE_LAY1_ATT_CTRL_REG1);
+    suniv_setbits(iomm.debe + DEBE_MODE_CTRL_REG, (1 << 8));
+    suniv_setbits(iomm.debe + DEBE_REGBUFF_CTRL_REG, (1 << 1));
+    suniv_setbits(iomm.debe + DEBE_MODE_CTRL_REG, (1 << 1));
+
+    ret = readl(iomm.lcdc + TCON_CTRL_REG);
+    ret&= ~(1 << 0);
+    writel(ret, iomm.lcdc + TCON_CTRL_REG);
+    ret = (1 + 1 + 1);
+    writel((uint32_t)(par->vram_phys) << 3, iomm.debe + DEBE_LAY0_FB_ADDR_REG);
+    writel((uint32_t)(par->vram_phys) >> 29, iomm.debe + DEBE_LAY0_FB_HI_ADDR_REG);
+    writel((uint32_t)(par->vram_phys+ 320*240*2) << 3, iomm.debe + DEBE_LAY1_FB_ADDR_REG);
+    writel((uint32_t)(par->vram_phys+ 320*240*2) >> 29, iomm.debe + DEBE_LAY1_FB_HI_ADDR_REG);
+
+    writel((1 << 31) | ((ret & 0x1f) << 4) | (1 << 24), iomm.lcdc + TCON0_CTRL_REG);
+    writel((0xf << 28) | (25 << 0), iomm.lcdc + TCON_CLK_CTRL_REG); //6, 15, 25
+    writel((4 << 29) | (1 << 26), iomm.lcdc + TCON0_CPU_IF_REG);
+    writel((1 << 28), iomm.lcdc + TCON0_IO_CTRL_REG0);
+
+    p1 = par->mode.yres - 1;
+    p2 = par->mode.xres - 1;
+    writel((p2 << 16) | (p1 << 0), iomm.lcdc + TCON0_BASIC_TIMING_REG0);
+
+    p1 = 1 + 1;
+    p2 = 1 + 1 + par->mode.xres + 2;
+    writel((p2 << 16) | (p1 << 0), iomm.lcdc + TCON0_BASIC_TIMING_REG1);
+
+    p1 = 1 + 1;
+    p2 = (1 + 1 + par->mode.yres + 1 + 2) << 1;
+    writel((p2 << 16) | (p1 << 0), iomm.lcdc + TCON0_BASIC_TIMING_REG2);
+
+    p1 = 1 + 1;
+    p2 = 1 + 1;
+    writel((p2 << 16) | (p1 << 0), iomm.lcdc + TCON0_BASIC_TIMING_REG3);
+
+    writel(0, iomm.lcdc + TCON0_HV_TIMING_REG);
+    writel(0, iomm.lcdc + TCON0_IO_CTRL_REG1);
+
+    suniv_setbits(iomm.lcdc + TCON_CTRL_REG, (1 << 31));
+    init_lcd();
+    suniv_setbits(iomm.lcdc + TCON_INT_REG0, (1 << 31));
+    suniv_setbits(iomm.lcdc + TCON0_CPU_IF_REG, (1 << 28));
+}
+
+static void suniv_enable_irq(struct myfb_par *par)
+{
+    int ret=0;
+
+    par->lcdc_irq = platform_get_irq(par->pdev, 0);
+    if(par->lcdc_irq < 0){
+        printk("%s, failed to get irq number for lcdc irq\n", __func__);
+    }
+    else{
+        ret = request_irq(par->lcdc_irq, lcdc_irq_handler, IRQF_SHARED, "lcdc_irq", par);
+        if(ret){
+            printk("%s, failed to register lcdc interrupt(%d)\n", __func__, par->lcdc_irq);
+        }
+    }
+}
+
+static void suniv_cpu_init(struct myfb_par *par)
+{
+    uint32_t ret, i;
+    writel(0x91001307, iomm.ccm + PLL_VIDEO_CTRL_REG);
+    while((readl(iomm.ccm + PLL_VIDEO_CTRL_REG) & (1 << 28)) == 0){}
+    while((readl(iomm.ccm + PLL_PERIPH_CTRL_REG) & (1 << 28)) == 0){}
+
+    ret = readl(iomm.ccm + DRAM_GATING_REG);
+    ret|= (1 << 26) | (1 << 24);
+    writel(ret, iomm.ccm + DRAM_GATING_REG);
+
+    suniv_setbits(iomm.ccm + FE_CLK_REG, (1 << 31));
+    suniv_setbits(iomm.ccm + BE_CLK_REG, (1 << 31));
+    suniv_setbits(iomm.ccm + TCON_CLK_REG, (1 << 31) | (1 << 25));
+    suniv_setbits(iomm.ccm + BUS_CLK_GATING_REG1, (1 << 14) | (1 << 12) | (1 << 4));
+    suniv_setbits(iomm.ccm + BUS_SOFT_RST_REG1, (1 << 14) | (1 << 12) | (1 << 4));
+    for(i=0x0800; i<0x1000; i+=4){
+        writel(0, iomm.debe + i);
+    }
+}
+
+static void lcd_delay_init(unsigned long param)
+{
+    suniv_cpu_init(mypar);
+    suniv_lcdc_init(mypar);
+    suniv_enable_irq(mypar);
+}
+
+#define CNVT_TOHW(val, width) ((((val) << (width)) + 0x7FFF - (val)) >> 16)
+static int myfb_setcolreg(unsigned regno, unsigned red, unsigned green, unsigned blue, unsigned transp, struct fb_info *info)
+{
+    red = CNVT_TOHW(red, info->var.red.length);
+    blue = CNVT_TOHW(blue, info->var.blue.length);
+    green = CNVT_TOHW(green, info->var.green.length);
+    ((u32*)(info->pseudo_palette))[regno] = (red << info->var.red.offset) | (green << info->var.green.offset) | (blue << info->var.blue.offset);
+    return 0;
+}
+#undef CNVT_TOHW
+
+static int myfb_check_var(struct fb_var_screeninfo *var, struct fb_info *info)
+{
+    int bpp = var->bits_per_pixel >> 3;
+    struct myfb_par *par = info->par;
+    unsigned long line_size = var->xres_virtual * bpp;
+
+    if((var->xres != 320) || (var->yres != 240) || (var->bits_per_pixel != 16)){
+        return -EINVAL;
+    }
+
+    var->transp.offset = 0;
+    var->transp.length = 0;
+    var->red.offset = 11;
+    var->red.length = 5;
+    var->green.offset = 5;
+    var->green.length = 6;
+    var->blue.offset = 0;
+    var->blue.length = 5;
+    var->red.msb_right = 0;
+    var->green.msb_right = 0;
+    var->blue.msb_right = 0;
+    var->transp.msb_right = 0;
+    if(line_size * var->yres_virtual > par->vram_size){
+        var->yres_virtual = par->vram_size / line_size;
+    }
+    if(var->yres > var->yres_virtual){
+        var->yres = var->yres_virtual;
+    }
+    if(var->xres > var->xres_virtual){
+        var->xres = var->xres_virtual;
+    }
+    if(var->xres + var->xoffset > var->xres_virtual){
+        var->xoffset = var->xres_virtual - var->xres;
+    }
+    if(var->yres + var->yoffset > var->yres_virtual){
+        var->yoffset = var->yres_virtual - var->yres;
+    }
+    return 0;
+}
+
+static int myfb_set_par(struct fb_info *info)
+{
+    struct myfb_par *par = info->par;
+
+    fb_var_to_videomode(&par->mode, &info->var);
+    par->yoffset = info->var.yoffset;
+    par->bpp = info->var.bits_per_pixel;
+    info->fix.visual = FB_VISUAL_TRUECOLOR;
+    info->fix.line_length = (par->mode.xres * par->bpp) / 8;
+    writel((5 << 8), iomm.debe + DEBE_LAY0_ATT_CTRL_REG1);
+    writel((5 << 8), iomm.debe + DEBE_LAY1_ATT_CTRL_REG1);
+    return 0;
+}
+
+static int myfb_ioctl(struct fb_info *info, unsigned int cmd, unsigned long arg)
+{
+    switch(cmd){
+        case FBIO_WAITFORVSYNC:
+            break;
+    }
+    return 0;
+}
+
+static int myfb_mmap(struct fb_info *info, struct vm_area_struct *vma)
+{
+    const unsigned long offset = vma->vm_pgoff << PAGE_SHIFT;
+    const unsigned long size = vma->vm_end - vma->vm_start;
+
+    if(offset + size > info->fix.smem_len){
+        return -EINVAL;
+    }
+
+    if(remap_pfn_range(vma, vma->vm_start, (info->fix.smem_start + offset) >> PAGE_SHIFT, size, vma->vm_page_prot)){
+        return -EAGAIN;
+    }
+    return 0;
+}
+
+static int myfb_pan_display(struct fb_var_screeninfo *var, struct fb_info *info)
+{
+    struct myfb_par *par = info->par;
+
+    if((var->xoffset != info->var.xoffset) || (var->yoffset != info->var.yoffset)){
+        info->var.xoffset = var->xoffset;
+        info->var.yoffset = var->yoffset;
+        par->yoffset = var->yoffset;
+    }
+    return 0;
+}
+
+static struct fb_ops myfb_ops = {
+        .owner          = THIS_MODULE,
+        .fb_check_var   = myfb_check_var,
+        .fb_set_par     = myfb_set_par,
+        .fb_setcolreg   = myfb_setcolreg,
+        .fb_pan_display = myfb_pan_display,
+        .fb_ioctl       = myfb_ioctl,
+        .fb_mmap        = myfb_mmap,
+
+        .fb_fillrect  = sys_fillrect,
+        .fb_copyarea  = sys_copyarea,
+        .fb_imageblit = sys_imageblit,
+};
+
+static int myfb_probe(struct platform_device *device)
+{
+    int ret=0;
+    struct fb_info *info=NULL;
+    struct myfb_par *par=NULL;
+    struct fb_videomode *mode=NULL;
+
+    mode = devm_kzalloc(&device->dev, sizeof(struct fb_videomode), GFP_KERNEL);
+    if(mode == NULL){
+        return -ENOMEM;
+    }
+    mode->name = "320x240";
+    mode->xres = 320;
+    mode->yres = 240;
+    mode->vmode = FB_VMODE_NONINTERLACED;
+    pm_runtime_enable(&device->dev);
+    pm_runtime_get_sync(&device->dev);
+
+    info = framebuffer_alloc(sizeof(struct myfb_par), &device->dev);
+    if(!info){
+        return -ENOMEM;
+    }
+
+    par = info->par;
+    par->pdev = device;
+    par->dev = &device->dev;
+    par->bpp = 16;
+    fb_videomode_to_var(&myfb_var, mode);
+
+    par->vram_size = 320 * 240 * 2 * 2;
+    par->vram_virt = dma_alloc_coherent(NULL, par->vram_size, (resource_size_t*)&par->vram_phys, GFP_KERNEL | GFP_DMA);
+    if(!par->vram_virt){
+        return -EINVAL;
+    }
+    info->screen_base = (char __iomem*)par->vram_virt;
+    myfb_fix.smem_start = par->vram_phys;
+    myfb_fix.smem_len = par->vram_size;
+    myfb_fix.line_length = 320 * 2;
+
+    par->v_palette_base = dma_alloc_coherent(NULL, PALETTE_SIZE, (resource_size_t*)&par->p_palette_base, GFP_KERNEL | GFP_DMA);
+    if(!par->v_palette_base){
+        return -EINVAL;
+    }
+    memset(par->v_palette_base, 0, PALETTE_SIZE);
+    myfb_var.grayscale = 0;
+    myfb_var.bits_per_pixel = par->bpp;
+
+    info->flags = FBINFO_FLAG_DEFAULT;
+    info->fix = myfb_fix;
+    info->var = myfb_var;
+    info->fbops = &myfb_ops;
+    info->pseudo_palette = par->pseudo_palette;
+    info->fix.visual = (info->var.bits_per_pixel <= 8) ? FB_VISUAL_PSEUDOCOLOR : FB_VISUAL_TRUECOLOR;
+    ret = fb_alloc_cmap(&info->cmap, PALETTE_SIZE, 0);
+    if(ret){
+        return -EINVAL;
+    }
+    info->cmap.len = 32;
+
+    myfb_var.activate = FB_ACTIVATE_FORCE;
+    fb_set_var(info, &myfb_var);
+    dev_set_drvdata(&device->dev, info);
+    if(register_framebuffer(info) < 0){
+        return -EINVAL;
+    }
+
+    mypar = par;
+    for(ret=0; ret<of_clk_get_parent_count(device->dev.of_node); ret++){
+        clk_prepare_enable(of_clk_get(device->dev.of_node, ret));
+    }
+    fb_prepare_logo(info, 0);
+    fb_show_logo(info, 0);
+
+    setup_timer(&mytimer, lcd_delay_init, 0);
+    mod_timer(&mytimer, jiffies + HZ);
+    return 0;
+}
+
+static int myfb_remove(struct platform_device *dev)
+{
+    struct fb_info *info = dev_get_drvdata(&dev->dev);
+    struct myfb_par *par = info->par;
+
+    if(info){
+        free_irq(par->lcdc_irq, par);
+        del_timer(&mytimer);
+        flush_scheduled_work();
+        unregister_framebuffer(info);
+        fb_dealloc_cmap(&info->cmap);
+        dma_free_coherent(NULL, PALETTE_SIZE, par->v_palette_base, par->p_palette_base);
+        dma_free_coherent(NULL, par->vram_size, par->vram_virt, par->vram_phys);
+        pm_runtime_put_sync(&dev->dev);
+        pm_runtime_disable(&dev->dev);
+        framebuffer_release(info);
+    }
+    return 0;
+}
+
+static int myfb_suspend(struct platform_device *dev, pm_message_t state)
+{
+    struct fb_info *info = platform_get_drvdata(dev);
+
+    console_lock();
+    fb_set_suspend(info, 1);
+    pm_runtime_put_sync(&dev->dev);
+    console_unlock();
+    return 0;
+}
+
+static int myfb_resume(struct platform_device *dev)
+{
+    struct fb_info *info = platform_get_drvdata(dev);
+
+    console_lock();
+    pm_runtime_get_sync(&dev->dev);
+    fb_set_suspend(info, 0);
+    console_unlock();
+    return 0;
+}
+
+static const struct of_device_id fb_of_match[] = {
+        {
+                .compatible = "allwinner,suniv-f1c500s-tcon0",
+        },{}
+};
+MODULE_DEVICE_TABLE(of, fb_of_match);
+
+static struct platform_driver fb_driver = {
+        .probe    = myfb_probe,
+        .remove   = myfb_remove,
+        .suspend  = myfb_suspend,
+        .resume   = myfb_resume,
+        .driver = {
+                .name   = DRIVER_NAME,
+                .owner  = THIS_MODULE,
+                .of_match_table = of_match_ptr(fb_of_match),
+        },
+};
+
+static void suniv_ioremap(void)
+{
+    iomm.dma = (uint8_t*)ioremap(SUNIV_DMA_BASE, 4096);
+    iomm.ccm = (uint8_t*)ioremap(SUNIV_CCM_BASE, 4096);
+    iomm.gpio = (uint8_t*)ioremap(SUNIV_GPIO_BASE, 4096);
+    iomm.lcdc = (uint8_t*)ioremap(SUNIV_LCDC_BASE, 4096);
+    iomm.debe = (uint8_t*)ioremap(SUNIV_DEBE_BASE, 4096);
+    iomm.intc = (uint8_t*)ioremap(SUNIV_INTC_BASE, 4096);
+}
+
+static void suniv_iounmap(void)
+{
+    iounmap(iomm.dma);
+    iounmap(iomm.ccm);
+    iounmap(iomm.gpio);
+    iounmap(iomm.lcdc);
+    iounmap(iomm.debe);
+    iounmap(iomm.intc);
+    iounmap(iomm.timer);
+}
+
+static int myopen(struct inode *inode, struct file *file)
+{
+    return 0;
+}
+
+static int myclose(struct inode *inode, struct file *file)
+{
+    return 0;
+}
+static long myioctl(struct file *filp, unsigned int cmd, unsigned long arg)
+{
+    int32_t w, bpp;
+
+    switch(cmd){
+        case MIYOO_FB0_PUT_OSD:
+            break;
+        case MIYOO_FB0_SET_MODE:
+            w = (arg >> 16);
+            bpp = (arg & 0xffff);
+            if((bpp != 16)){
+                writel((5 << 8), iomm.debe + DEBE_LAY0_ATT_CTRL_REG1);
+                writel((5 << 8), iomm.debe + DEBE_LAY1_ATT_CTRL_REG1);
+            }
+            else{
+                writel((7 << 8) | 4, iomm.debe + DEBE_LAY0_ATT_CTRL_REG1);
+                writel((7 << 8) | 4, iomm.debe + DEBE_LAY1_ATT_CTRL_REG1);
+            }
+            break;
+    }
+}
+
+static const struct file_operations myfops = {
+        .owner = THIS_MODULE,
+        .open = myopen,
+        .release = myclose,
+        .unlocked_ioctl = myioctl,
+};
+
+static int __init fb_init(void)
+{
+    suniv_ioremap();
+    alloc_chrdev_region(&major, 0, 1, "miyoo_fb0");
+    myclass = class_create(THIS_MODULE, "miyoo_fb0");
+    device_create(myclass, NULL, major, NULL, "miyoo_fb0");
+    cdev_init(&mycdev, &myfops);
+    cdev_add(&mycdev, major, 1);
+    return platform_driver_register(&fb_driver);
+}
+
+static void __exit fb_cleanup(void)
+{
+    suniv_iounmap();
+    device_destroy(myclass, major);
+    cdev_del(&mycdev);
+    class_destroy(myclass);
+    unregister_chrdev_region(major, 1);
+    platform_driver_unregister(&fb_driver);
+}
+
+module_init(fb_init);
+module_exit(fb_cleanup);
+
+MODULE_DESCRIPTION("Framebuffer driver for GC9306");
+MODULE_AUTHOR("Steward Fu <steward.fu@gmail.com>");
+MODULE_LICENSE("GPL");
+
diff --git a/drivers/video/fbdev/hx8347dfb.c b/drivers/video/fbdev/hx8347dfb.c
new file mode 100644
index 00000000..a5540b1e
--- /dev/null
+++ b/drivers/video/fbdev/hx8347dfb.c
@@ -0,0 +1,939 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option)any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+#include <linux/cdev.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/fb.h>
+#include <linux/dma-mapping.h>
+#include <linux/device.h>
+#include <linux/platform_device.h>
+#include <linux/uaccess.h>
+#include <linux/pm_runtime.h>
+#include <linux/interrupt.h>
+#include <linux/wait.h>
+#include <linux/clk.h>
+#include <linux/cpufreq.h>
+#include <linux/console.h>
+#include <linux/spinlock.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+#include <linux/lcm.h>
+#include <linux/clk-provider.h>
+#include <video/of_display_timing.h>
+#include <linux/gpio.h>
+#include <linux/omapfb.h>
+#include <linux/compiler.h>
+#include <linux/workqueue.h>
+#include <asm/io.h>
+#include <asm/gpio.h>
+#include <asm/arch-suniv/cpu.h>
+#include <asm/arch-suniv/dma.h>
+#include <asm/arch-suniv/gpio.h>
+#include <asm/arch-suniv/intc.h>
+#include <asm/arch-suniv/lcdc.h>
+#include <asm/arch-suniv/debe.h>
+#include <asm/arch-suniv/clock.h>
+#include <asm/arch-suniv/common.h>
+
+#define MIYOO_FB0_PUT_OSD     _IOWR(0x100, 0, unsigned long)
+#define MIYOO_FB0_SET_MODE    _IOWR(0x101, 0, unsigned long)
+#define MIYOO_FB0_GET_VER     _IOWR(0x102, 0, unsigned long)
+#define MIYOO_FB0_SET_FLIP    _IOWR(0x103, 0, unsigned long)
+#define MIYOO_FB0_SET_FPBP    _IOWR(0x104, 0, unsigned long)
+#define MIYOO_FB0_GET_FPBP    _IOWR(0x105, 0, unsigned long)
+
+#define NO_POCKET_GO             1
+#define MIYOO3                1
+
+#define LRAM_NUM              1
+#define PALETTE_SIZE          256
+#define DRIVER_NAME           "miyoofb"
+#define SLCD_RESET		        ((32 * 4) + 11) // PE11
+#define SLCD_TE		  		      ((32 * 4) + 10) // PE10
+
+struct myfb_par {
+  struct device *dev;
+  struct platform_device *pdev;
+
+  resource_size_t p_palette_base;
+  unsigned short *v_palette_base;
+ 
+  dma_addr_t vram_phys;
+  uint32_t vram_size;
+  void *vram_virt;
+  int yoffset;
+  
+  dma_addr_t lram_phys[LRAM_NUM];
+  uint32_t lram_size;
+  void *lram_virt[LRAM_NUM];
+  void *dma_addr;
+ 
+  int bpp;
+  int lcdc_irq;
+  int gpio_irq;
+  volatile int have_te;
+  u32 pseudo_palette[16];
+  struct fb_videomode mode;
+};
+
+struct suniv_iomm {
+  uint8_t *dma;
+  uint8_t *ccm;
+  uint8_t *gpio;
+  uint8_t *lcdc;
+  uint8_t *debe;
+  uint8_t *intc;
+};
+static struct suniv_iomm iomm={0};
+
+static int major = -1;
+static struct cdev mycdev;
+static struct class *myclass = NULL;
+static int flip_mode=0;
+static int new_bp=8;
+static int new_fp=8;
+static int def_bp=8;
+static int def_fp=8;
+uint32_t ret;
+int x, y;
+uint16_t *p;
+
+struct myfb_par *mypar;
+static struct fb_var_screeninfo myfb_var;
+static struct fb_fix_screeninfo myfb_fix = {
+  .id = DRIVER_NAME,
+  .type = FB_TYPE_PACKED_PIXELS,
+  .type_aux = 0,
+  .visual = FB_VISUAL_TRUECOLOR,
+  .xpanstep = 0,
+  .ypanstep = 1,
+  .ywrapstep = 0,
+  .accel = FB_ACCEL_NONE
+};
+
+static void suniv_gpio_init(void)
+{
+  uint32_t ret;
+
+  ret = readl(iomm.gpio + PD_CFG0);
+  ret&= 0x0000000f;
+  ret|= 0x22222220;
+  writel(ret, iomm.gpio + PD_CFG0);
+  writel(0x22222202, iomm.gpio + PD_CFG1);
+  writel(0x00222222, iomm.gpio + PD_CFG2);
+  writel(0x00040001, iomm.gpio + PD_PUL0);
+  writel(0x00000000, iomm.gpio + PD_PUL1);
+  //writel(0xffffffff, iomm.gpio + PD_DRV0);
+  writel(0xffffffff, iomm.gpio + PD_DRV1);
+
+  ret = readl(iomm.gpio + PE_PUL0);
+  ret&= 0xff0fffff;
+  ret|= 0x00500000;
+  writel(ret, iomm.gpio + PE_PUL0);
+  
+  ret = readl(iomm.gpio + PE_CFG1);
+  ret&= 0xffff0fff;
+  ret|= 0x00001000;
+  writel(ret, iomm.gpio + PE_CFG1);
+}
+
+static uint32_t lcdc_wait_busy(void)
+{
+	uint32_t cnt=0;
+	
+  suniv_setbits(iomm.lcdc + TCON0_CPU_IF_REG, (1 << 0));
+	ndelay(10);
+	while(1){
+		if(readl(iomm.lcdc + TCON0_CPU_IF_REG) & 0x00c00000){
+			if(cnt > 200){
+				return -1;
+			}
+		  else{
+		  	cnt+= 1;
+			}
+		}
+		break;
+	}
+	return 0;
+}
+
+static uint32_t extend_16b_to_24b(uint32_t value)
+{
+	return ((value & 0xfc00) << 8) | ((value & 0x0300) << 6) | ((value & 0x00e0) << 5) | ((value & 0x001f) << 3);
+}
+
+static void lcdc_wr(uint8_t is_data, uint32_t data)
+{
+	while(lcdc_wait_busy());
+	if(is_data){
+		suniv_setbits(iomm.lcdc + TCON0_CPU_IF_REG, (1 << 25)); // ca=1
+	}
+	else{
+		suniv_clrbits(iomm.lcdc + TCON0_CPU_IF_REG, (1 << 25)); // ca=0	
+	}
+	while(lcdc_wait_busy());
+	writel(extend_16b_to_24b(data), iomm.lcdc + TCON0_CPU_WR_REG);
+}
+
+
+static void lcdc_wr_cmd(uint32_t cmd)
+{
+	lcdc_wr(0, cmd);
+}
+
+static void lcdc_wr_dat(uint32_t cmd)
+{
+	lcdc_wr(1, cmd);
+}
+
+
+static void refresh_lcd(struct myfb_par *par)
+{
+
+    lcdc_wr_cmd(0x22);
+
+  if(par->yoffset == 0){
+	  suniv_setbits(iomm.debe + DEBE_MODE_CTRL_REG, (1 << 8));
+	  suniv_clrbits(iomm.debe + DEBE_MODE_CTRL_REG, (1 << 9));
+  }
+  else{
+	  suniv_clrbits(iomm.debe + DEBE_MODE_CTRL_REG, (1 << 8));
+	  suniv_setbits(iomm.debe + DEBE_MODE_CTRL_REG, (1 << 9));
+  }
+	suniv_setbits(iomm.debe + DEBE_REGBUFF_CTRL_REG, (1 << 0));
+}
+
+static irqreturn_t gpio_irq_handler(int irq, void *arg)
+{
+  static uint32_t cnt=0, report=0;
+  struct myfb_par *par = arg;
+
+  suniv_setbits(iomm.gpio + PE_INT_STA, (1 << 10));
+  if(cnt > 10){
+    par->have_te = 1;
+    if(flip_mode == 0){
+      if(report++ >= 60){
+        report = 0;
+        printk("%s\n", __func__);
+      }
+      refresh_lcd(par);
+    }
+  }
+  else{
+    cnt+= 1;
+  }
+  return IRQ_HANDLED;
+}
+
+static irqreturn_t lcdc_irq_handler(int irq, void *arg)
+{
+  static uint32_t report=0;
+  struct myfb_par *par = arg;
+
+  suniv_clrbits(iomm.lcdc + TCON_INT_REG0, (1 << 15));
+  if(par->have_te == 0){
+    if(flip_mode == 0){
+      if(report++ >= 60){
+        report = 0;
+        //printk("%s\n", __func__);
+      }
+      refresh_lcd(par);
+    }
+  }
+  return IRQ_HANDLED;
+}
+
+static void panel_init(void)
+{
+  
+  suniv_setbits(iomm.lcdc + PE_DATA, (11 << 0));
+  mdelay(50);
+  suniv_clrbits(iomm.lcdc + PE_DATA, (11 << 0));
+  mdelay(150);
+  suniv_setbits(iomm.lcdc + PE_DATA, (11 << 0));
+  mdelay(150);
+
+	//Driving ability Setting
+	lcdc_wr_cmd(0x00);
+	lcdc_wr_dat(0xFF); //read ID
+	lcdc_wr_cmd(0x61);
+	lcdc_wr_dat(0xFF); //read ID
+	lcdc_wr_cmd(0x62);
+	lcdc_wr_dat(0xFF); //read ID
+	lcdc_wr_cmd(0x63);
+	lcdc_wr_dat(0xFF); //read ID
+
+	lcdc_wr_cmd(0xEA);
+	lcdc_wr_dat(0x00); //PTBA[15:8]
+	lcdc_wr_cmd(0xEB);
+	lcdc_wr_dat(0x20); //PTBA[7:0]
+	lcdc_wr_cmd(0xEC);
+	lcdc_wr_dat(0x0C); //STBA[15:8]
+	lcdc_wr_cmd(0xED);
+	lcdc_wr_dat(0xC4); //STBA[7:0]
+	lcdc_wr_cmd(0xE8);
+	lcdc_wr_dat(0x38); //OPON[7:0]
+	lcdc_wr_cmd(0xE9);
+	lcdc_wr_dat(0x10); //OPON1[7:0]
+	lcdc_wr_cmd(0xF1);
+	lcdc_wr_dat(0x01); //OTPS1B
+	lcdc_wr_cmd(0xF2);
+	lcdc_wr_dat(0x10); //GEN
+		
+	//Gamma 2.2 Setting
+	lcdc_wr_cmd(0x40);
+	lcdc_wr_dat(0x01); //
+	lcdc_wr_cmd(0x41);
+	lcdc_wr_dat(0x00); //
+	lcdc_wr_cmd(0x42);
+	lcdc_wr_dat(0x00); //
+	lcdc_wr_cmd(0x43);
+	lcdc_wr_dat(0x10); //
+	lcdc_wr_cmd(0x44);
+	lcdc_wr_dat(0x0E); //
+	lcdc_wr_cmd(0x45);
+	lcdc_wr_dat(0x24); //
+	lcdc_wr_cmd(0x46);
+	lcdc_wr_dat(0x04); //
+	lcdc_wr_cmd(0x47);
+	lcdc_wr_dat(0x50); //
+	lcdc_wr_cmd(0x48);
+	lcdc_wr_dat(0x02); //
+	lcdc_wr_cmd(0x49);
+	lcdc_wr_dat(0x13); //
+	lcdc_wr_cmd(0x4A);
+	lcdc_wr_dat(0x19); //
+	lcdc_wr_cmd(0x4B);
+	lcdc_wr_dat(0x19); //
+	lcdc_wr_cmd(0x4C);
+	lcdc_wr_dat(0x16); //
+	lcdc_wr_cmd(0x50);
+	lcdc_wr_dat(0x1B); //
+	lcdc_wr_cmd(0x51);
+	lcdc_wr_dat(0x31); //
+	lcdc_wr_cmd(0x52);
+	lcdc_wr_dat(0x2F); //
+	lcdc_wr_cmd(0x53);
+	lcdc_wr_dat(0x3F); //
+	lcdc_wr_cmd(0x54);
+	lcdc_wr_dat(0x3F); //
+	lcdc_wr_cmd(0x55);
+	lcdc_wr_dat(0x3E); //
+	lcdc_wr_cmd(0x56);
+	lcdc_wr_dat(0x2F); //
+	lcdc_wr_cmd(0x57);
+	lcdc_wr_dat(0x7B); //
+	lcdc_wr_cmd(0x58);
+	lcdc_wr_dat(0x09); //
+	lcdc_wr_cmd(0x59);
+	lcdc_wr_dat(0x06); //
+	lcdc_wr_cmd(0x5A);
+	lcdc_wr_dat(0x06); //
+	lcdc_wr_cmd(0x5B);
+	lcdc_wr_dat(0x0C); //
+	lcdc_wr_cmd(0x5C);
+	lcdc_wr_dat(0x1D); //
+	lcdc_wr_cmd(0x5D);
+	lcdc_wr_dat(0xCC); //
+		
+	//Power Voltage Setting
+	lcdc_wr_cmd(0x1B);
+	lcdc_wr_dat(0x1B); //VRH=4.65V
+	lcdc_wr_cmd(0x1A);
+	lcdc_wr_dat(0x01); //BT (VGH~15V VGL~-10V DDVDH~5V)
+	lcdc_wr_cmd(0x24);
+	lcdc_wr_dat(0x2F); //VMH(VCOM High voltage ~3.2V)
+	lcdc_wr_cmd(0x25);
+	lcdc_wr_dat(0x57); //VML(VCOM Low voltage -1.2V)
+		
+	//****VCOM offset**///
+	lcdc_wr_cmd(0x23);
+	lcdc_wr_dat(0x88); //for Flicker adjust //can reload from OTP
+	
+	//Power on Setting
+	lcdc_wr_cmd(0x18);
+	lcdc_wr_dat(0x34); //I/P_RADJ N/P_RADJ  Normal mode 60Hz
+	lcdc_wr_cmd(0x19);
+	lcdc_wr_dat(0x01); //OSC_EN='1'  start Osc
+	lcdc_wr_cmd(0x01);
+	lcdc_wr_dat(0x00); //DP_STB='0'  out deep sleep
+	lcdc_wr_cmd(0x1F);
+	lcdc_wr_dat(0x88);// GAS=1  VOMG=00  PON=0  DK=1  XDK=0  DVDH_TRI=0  STB=0
+	mdelay(5);
+	
+	lcdc_wr_cmd(0x1F);
+	lcdc_wr_dat(0x80);// GAS=1 VOMG=00 PON=0 DK=0 XDK=0 DVDH_TRI=0 STB=0	
+	mdelay(5);
+	
+	lcdc_wr_cmd(0x1F);
+	lcdc_wr_dat(0x90);// GAS=1 VOMG=00 PON=1 DK=0 XDK=0 DVDH_TRI=0 STB=0
+	mdelay(5);
+	
+	lcdc_wr_cmd(0x1F);
+	lcdc_wr_dat(0xD0);// GAS=1 VOMG=10 PON=1 DK=0 XDK=0 DDVDH_TRI=0 STB=0	
+	mdelay(5);
+	
+	//262k/65k color selection
+	lcdc_wr_cmd(0x17);
+	lcdc_wr_dat(0x05); //default 0x06 262k color // 0x05 65k color
+	
+	//SET PANEL
+	lcdc_wr_cmd(0x36);
+	lcdc_wr_dat(0x00); //SS_P GS_P REV_P BGR_P
+	
+	//Display ON Setting
+	lcdc_wr_cmd(0x28);
+	lcdc_wr_dat(0x38); //GON=1 DTE=1 D=1000	
+	mdelay(40);
+	
+	lcdc_wr_cmd(0x28);
+	lcdc_wr_dat(0x3F); //GON=1 DTE=1 D=1100
+	lcdc_wr_cmd(0x16);
+	lcdc_wr_dat(0x18); 
+	
+	//Set GRAM Area		
+	lcdc_wr_cmd(0x02);
+	lcdc_wr_dat(0x00);
+	lcdc_wr_cmd(0x03);
+	lcdc_wr_dat(0x00); //Column Start
+	lcdc_wr_cmd(0x04);
+	lcdc_wr_dat(0x00);
+	lcdc_wr_cmd(0x05);
+	lcdc_wr_dat(0xEF); //Column End
+	lcdc_wr_cmd(0x06);
+	lcdc_wr_dat(0x00);
+	lcdc_wr_cmd(0x07);
+	lcdc_wr_dat(0x00); //Row Start
+	lcdc_wr_cmd(0x08);
+	lcdc_wr_dat(0x01);
+	lcdc_wr_cmd(0x09);
+	lcdc_wr_dat(0x3F); //Row End
+	mdelay(1);
+	
+	lcdc_wr_cmd(0x00);
+	lcdc_wr_dat(0xFF); //read ID
+	lcdc_wr_cmd(0x61);
+	lcdc_wr_dat(0xFF); //read ID
+	lcdc_wr_cmd(0x62);
+	lcdc_wr_dat(0xFF); //read ID
+	lcdc_wr_cmd(0x63);
+	lcdc_wr_dat(0xFF); //read ID
+
+
+  writel(0xffffffff, iomm.gpio + PD_DATA);
+  ret = readl(iomm.gpio + PD_CFG0);
+  ret&= 0x0000000f;
+  ret|= 0x22222220;
+  writel(ret, iomm.gpio + PD_CFG0);
+  writel(0x22222202, iomm.gpio + PD_CFG1);
+  writel(0x00222222, iomm.gpio + PD_CFG2);
+
+}
+
+static void suniv_enable_irq(struct myfb_par *par)
+{
+  int ret;
+
+  par->have_te = 0;
+  par->lcdc_irq = platform_get_irq(par->pdev, 0);
+  if (par->lcdc_irq < 0) {
+    printk("%s, failed to get irq number for lcdc irq\n", __func__);
+  }
+  else{
+	  ret = request_irq(par->lcdc_irq, lcdc_irq_handler, IRQF_SHARED, "miyoo_lcdc_irq", par);
+	  if(ret){
+		  printk("%s, failed to register lcdc interrupt(%d)\n", __func__, par->lcdc_irq);
+	  }
+  }
+  
+  par->gpio_irq = -1;//gpio_to_irq(SLCD_TE);
+  if (par->gpio_irq < 0) {
+    //printk("%s, failed to get irq number for gpio irq\n", __func__);
+  }
+  else{
+	  ret = request_irq(par->gpio_irq, gpio_irq_handler, IRQF_TRIGGER_RISING, "miyoo_gpio_irq", par);
+	  if(ret){
+		  printk("%s, failed to register gpio interrupt(%d)\n", __func__, par->gpio_irq);
+	  }
+  }
+}
+
+static void suniv_lcdc_init(struct myfb_par *par)
+{
+  uint32_t ret=0, bp=0, total=0;
+	uint32_t h_front_porch = 8;
+	uint32_t h_back_porch = 8;
+	uint32_t h_sync_len = 1;
+	uint32_t v_front_porch = 8;
+	uint32_t v_back_porch = 8;
+	uint32_t v_sync_len = 1;
+ 
+	writel(0, iomm.lcdc + TCON_CTRL_REG);
+	writel(0, iomm.lcdc + TCON_INT_REG0);
+	ret = readl(iomm.lcdc + TCON_CLK_CTRL_REG);
+	ret&= ~(0xf << 28);
+	writel(ret, iomm.lcdc + TCON_CLK_CTRL_REG);
+  writel(0xffffffff, iomm.lcdc + TCON0_IO_CTRL_REG1);
+	writel(0xffffffff, iomm.lcdc + TCON1_IO_CTRL_REG1);
+
+	suniv_setbits(iomm.debe + DEBE_MODE_CTRL_REG, (1 << 0));
+  writel(par->mode.xres << 4, iomm.debe + DEBE_LAY0_LINEWIDTH_REG);
+  writel(par->mode.xres << 4, iomm.debe + DEBE_LAY1_LINEWIDTH_REG);
+	writel((((par->mode.yres) - 1) << 16) | (((par->mode.xres) - 1) << 0), iomm.debe + DEBE_DISP_SIZE_REG);
+	writel((((par->mode.yres) - 1) << 16) | (((par->mode.xres) - 1) << 0), iomm.debe + DEBE_LAY0_SIZE_REG);
+	writel((((par->mode.yres) - 1) << 16) | (((par->mode.xres) - 1) << 0), iomm.debe + DEBE_LAY1_SIZE_REG);
+	writel((5 << 8), iomm.debe + DEBE_LAY0_ATT_CTRL_REG1);
+  writel((5 << 8), iomm.debe + DEBE_LAY1_ATT_CTRL_REG1);
+	suniv_setbits(iomm.debe + DEBE_MODE_CTRL_REG, (1 << 8));
+	suniv_setbits(iomm.debe + DEBE_REGBUFF_CTRL_REG, (1 << 1));
+  suniv_setbits(iomm.debe + DEBE_MODE_CTRL_REG, (1 << 1));
+
+	ret = readl(iomm.lcdc + TCON_CTRL_REG);
+	ret&= ~(1 << 0);
+	writel(ret, iomm.lcdc + TCON_CTRL_REG);
+	ret = (v_front_porch + v_back_porch + v_sync_len);
+
+    writel((uint32_t)(par->vram_phys) << 3, iomm.debe + DEBE_LAY0_FB_ADDR_REG);
+    writel((uint32_t)(par->vram_phys) >> 29, iomm.debe + DEBE_LAY0_FB_HI_ADDR_REG);
+    writel((uint32_t)(par->vram_phys + 320*240*2) << 3, iomm.debe + DEBE_LAY1_FB_ADDR_REG);
+    writel((uint32_t)(par->vram_phys + 320*240*2) >> 29, iomm.debe + DEBE_LAY1_FB_HI_ADDR_REG);
+	  
+    writel((1 << 31) | ((ret & 0x1f) << 4) | (1 << 24), iomm.lcdc + TCON0_CTRL_REG);
+	  writel((0xf << 28) | (6 << 0), iomm.lcdc + TCON_CLK_CTRL_REG); // 6, 15
+	  writel((4 << 29) | (1 << 26), iomm.lcdc + TCON0_CPU_IF_REG);
+	  writel((1 << 28), iomm.lcdc + TCON0_IO_CTRL_REG0);
+
+
+	writel(((par->mode.xres - 1) << 16) | ((par->mode.yres - 1) << 0), iomm.lcdc + TCON0_BASIC_TIMING_REG0);
+	bp = h_sync_len + h_back_porch;
+	total = par->mode.xres * 1 + h_front_porch + bp;
+	writel(((total - 1) << 16) | ((bp - 1) << 0), iomm.lcdc + TCON0_BASIC_TIMING_REG1);
+	bp = v_sync_len + v_back_porch;
+	total = par->mode.yres + v_front_porch + bp;
+	writel(((total * 2) << 16) | ((bp - 1) << 0), iomm.lcdc + TCON0_BASIC_TIMING_REG2);
+	writel(((h_sync_len - 1) << 16) | ((v_sync_len - 1) << 0), iomm.lcdc + TCON0_BASIC_TIMING_REG3);
+	writel(0, iomm.lcdc + TCON0_HV_TIMING_REG);
+	writel(0, iomm.lcdc + TCON0_IO_CTRL_REG1);	
+  
+	suniv_setbits(iomm.lcdc + TCON_CTRL_REG, (1 << 31));
+  suniv_setbits(iomm.gpio + PE_INT_STA, (1 << 10));
+	suniv_setbits(iomm.lcdc + TCON_INT_REG0, (1 << 31));
+	suniv_setbits(iomm.lcdc + TCON0_CPU_IF_REG, (1 << 28));
+}
+
+static void suniv_cpu_init(struct myfb_par *par)
+{
+  uint32_t ret, i;
+
+  while((readl(iomm.ccm + PLL_VIDEO_CTRL_REG) & (1 << 28)) == 0){}
+  while((readl(iomm.ccm + PLL_PERIPH_CTRL_REG) & (1 << 28)) == 0){}
+
+	ret = readl(iomm.ccm + DRAM_GATING_REG);
+	ret|= (1 << 26) | (1 << 24);
+	writel(ret, iomm.ccm + DRAM_GATING_REG);
+  
+  suniv_setbits(iomm.ccm + FE_CLK_REG, (1 << 31));
+  suniv_setbits(iomm.ccm + BE_CLK_REG, (1 << 31));
+  suniv_setbits(iomm.ccm + TCON_CLK_REG, (1 << 31));
+  suniv_setbits(iomm.ccm + BUS_CLK_GATING_REG1, (1 << 14) | (1 << 12) | (1 << 4));
+  suniv_setbits(iomm.ccm + BUS_SOFT_RST_REG1, (1 << 14) | (1 << 12) | (1 << 4));
+  for(i=0x0800; i<0x1000; i+=4){
+    writel(0, iomm.debe + i);
+  }
+}
+
+#define CNVT_TOHW(val, width) ((((val) << (width)) + 0x7FFF - (val)) >> 16)
+static int myfb_setcolreg(unsigned regno, unsigned red, unsigned green, unsigned blue, unsigned transp, struct fb_info *info)
+{
+  red = CNVT_TOHW(red, info->var.red.length);
+  blue = CNVT_TOHW(blue, info->var.blue.length);
+  green = CNVT_TOHW(green, info->var.green.length);
+  ((u32*)(info->pseudo_palette))[regno] = (red << info->var.red.offset) | (green << info->var.green.offset) | (blue << info->var.blue.offset);
+  return 0;
+}
+#undef CNVT_TOHW
+ 
+static int myfb_check_var(struct fb_var_screeninfo *var, struct fb_info *info)
+{
+  int bpp = var->bits_per_pixel >> 3;
+  struct myfb_par *par = info->par;
+  unsigned long line_size = var->xres_virtual * bpp;
+ 
+  if((var->xres != 320) || (var->yres != 240) || (var->bits_per_pixel != 16)){
+    return -EINVAL;
+  }
+ 
+  var->transp.offset = 0;
+  var->transp.length = 0;
+  var->red.offset = 11;
+  var->red.length = 5;
+  var->green.offset = 5;
+  var->green.length = 6;
+  var->blue.offset = 0;
+  var->blue.length = 5;
+  var->red.msb_right = 0;
+  var->green.msb_right = 0;
+  var->blue.msb_right = 0;
+  var->transp.msb_right = 0;
+  if(line_size * var->yres_virtual > par->vram_size){
+    var->yres_virtual = par->vram_size / line_size;
+  }
+  if(var->yres > var->yres_virtual){
+    var->yres = var->yres_virtual;
+  }
+  if(var->xres > var->xres_virtual){
+    var->xres = var->xres_virtual;
+  }
+  if(var->xres + var->xoffset > var->xres_virtual){
+    var->xoffset = var->xres_virtual - var->xres;
+  }
+  if(var->yres + var->yoffset > var->yres_virtual){
+    var->yoffset = var->yres_virtual - var->yres;
+  }
+  return 0;
+}
+ 
+static int myfb_remove(struct platform_device *dev)
+{
+  int i;
+  struct fb_info *info = dev_get_drvdata(&dev->dev);
+  struct myfb_par *par = info->par;
+ 
+  if(info){
+    flush_scheduled_work();
+    unregister_framebuffer(info);
+    fb_dealloc_cmap(&info->cmap);
+    dma_free_coherent(NULL, PALETTE_SIZE, par->v_palette_base, par->p_palette_base);
+    dma_free_coherent(NULL, par->vram_size, par->vram_virt, par->vram_phys);
+    for(i=0; i<LRAM_NUM; i++){
+      dma_free_coherent(NULL, par->lram_size, par->lram_virt[i], par->lram_phys[i]);
+    }
+    pm_runtime_put_sync(&dev->dev);
+    pm_runtime_disable(&dev->dev);
+    framebuffer_release(info);
+  }
+  return 0;
+}
+ 
+static int myfb_set_par(struct fb_info *info)
+{
+  struct myfb_par *par = info->par;
+   
+  fb_var_to_videomode(&par->mode, &info->var);
+  par->yoffset = info->var.yoffset;
+  par->bpp = info->var.bits_per_pixel;
+  info->fix.visual = FB_VISUAL_TRUECOLOR;
+  info->fix.line_length = (par->mode.xres * par->bpp) / 8; 	
+  writel((5 << 8), iomm.debe + DEBE_LAY0_ATT_CTRL_REG1);
+  writel((5 << 8), iomm.debe + DEBE_LAY1_ATT_CTRL_REG1);
+  return 0;
+}
+ 
+static int myfb_ioctl(struct fb_info *info, unsigned int cmd, unsigned long arg)
+{
+  switch(cmd){
+  case FBIO_WAITFORVSYNC:
+    break;
+  }
+  return 0;
+}
+ 
+static int myfb_mmap(struct fb_info *info, struct vm_area_struct *vma)
+{
+  const unsigned long offset = vma->vm_pgoff << PAGE_SHIFT;
+  const unsigned long size = vma->vm_end - vma->vm_start;
+  
+  if(offset + size > info->fix.smem_len){
+    return -EINVAL;
+  }
+  
+  if(remap_pfn_range(vma, vma->vm_start, (info->fix.smem_start + offset) >> PAGE_SHIFT, size, vma->vm_page_prot)){
+    return -EAGAIN;
+  }
+  return 0;
+}
+
+static int myfb_pan_display(struct fb_var_screeninfo *var, struct fb_info *info)
+{
+  struct myfb_par *par = info->par;
+  if((var->xoffset != info->var.xoffset) || (var->yoffset != info->var.yoffset)){
+    info->var.xoffset = var->xoffset;
+    info->var.yoffset = var->yoffset;
+    par->yoffset = var->yoffset;
+  }
+  return 0;
+}
+
+static struct fb_ops myfb_ops = {
+  .owner          = THIS_MODULE,
+  .fb_check_var   = myfb_check_var,
+  .fb_set_par     = myfb_set_par,
+  .fb_setcolreg   = myfb_setcolreg,
+  .fb_pan_display = myfb_pan_display,
+  .fb_ioctl       = myfb_ioctl,
+  .fb_mmap        = myfb_mmap,
+ 
+  .fb_fillrect  = sys_fillrect,
+  .fb_copyarea  = sys_copyarea,
+  .fb_imageblit = sys_imageblit,
+};
+
+static int myfb_probe(struct platform_device *device)
+{
+  int i, ret;
+  struct fb_info *info;
+  struct myfb_par *par;
+  struct fb_videomode *mode;
+
+  mode = devm_kzalloc(&device->dev, sizeof(struct fb_videomode), GFP_KERNEL);
+  if(mode == NULL){
+    return -ENOMEM;
+  }
+  mode->name = "320x240";
+  mode->xres = 320;
+  mode->yres = 240;
+  mode->vmode = FB_VMODE_NONINTERLACED; 
+  pm_runtime_enable(&device->dev);
+  pm_runtime_get_sync(&device->dev);
+   
+  info = framebuffer_alloc(sizeof(struct myfb_par), &device->dev);
+  if(!info){
+    dev_dbg(&device->dev, "memory allocation failed for fb_info\n");
+    return -ENOMEM;
+  }
+ 
+  par = info->par;
+  par->pdev = device;
+  par->dev = &device->dev;
+  par->bpp = 16;
+  fb_videomode_to_var(&myfb_var, mode);
+  
+  par->vram_size = 320*240*2*2;
+  par->vram_virt = dma_alloc_coherent(NULL, par->vram_size, (resource_size_t*)&par->vram_phys, GFP_KERNEL | GFP_DMA);
+  if(!par->vram_virt){
+    dev_err(&device->dev, "%s, failed to allocate frame buffer(vram)\n", __func__);
+    return -EINVAL;
+  }
+  info->screen_base = (char __iomem*)par->vram_virt;
+  myfb_fix.smem_start = par->vram_phys;
+  myfb_fix.smem_len = par->vram_size;
+  myfb_fix.line_length = 320 * 2;
+  
+  par->lram_size = 320*240*18;
+  for(i=0; i<LRAM_NUM; i++){
+    par->lram_virt[i] = dma_alloc_coherent(NULL, par->lram_size, (resource_size_t*)&par->lram_phys[i], GFP_KERNEL | GFP_DMA);
+    if(!par->lram_virt[i]){
+      dev_err(&device->dev, "%s, failed to allocate frame buffer(lram[%d])\n", __func__, i);
+      return -EINVAL;
+    }
+  }
+   
+  par->v_palette_base = dma_alloc_coherent(NULL, PALETTE_SIZE, (resource_size_t*)&par->p_palette_base, GFP_KERNEL | GFP_DMA);
+  if(!par->v_palette_base){
+    dev_err(&device->dev, "GLCD: kmalloc for palette buffer failed\n");
+    return -EINVAL;
+  }
+  memset(par->v_palette_base, 0, PALETTE_SIZE);
+  myfb_var.grayscale = 0;
+  myfb_var.bits_per_pixel = par->bpp;
+ 
+  info->flags = FBINFO_FLAG_DEFAULT;
+  info->fix = myfb_fix;
+  info->var = myfb_var;
+  info->fbops = &myfb_ops;
+  info->pseudo_palette = par->pseudo_palette;
+  info->fix.visual = (info->var.bits_per_pixel <= 8) ? FB_VISUAL_PSEUDOCOLOR : FB_VISUAL_TRUECOLOR; 
+  ret = fb_alloc_cmap(&info->cmap, PALETTE_SIZE, 0);
+  if(ret){
+    return -EINVAL;
+  }
+  info->cmap.len = 32;
+ 
+  myfb_var.activate = FB_ACTIVATE_FORCE;
+  fb_set_var(info, &myfb_var);
+  dev_set_drvdata(&device->dev, info);
+
+  if(register_framebuffer(info) < 0){
+    dev_err(&device->dev, "failed to register /dev/fb0\n");
+    return -EINVAL;
+  }
+  
+  mypar = par;
+  new_bp = -1;
+  new_fp = -1;
+  for(ret=0; ret<of_clk_get_parent_count(device->dev.of_node); ret++){
+    clk_prepare_enable(of_clk_get(device->dev.of_node, ret));
+  }
+  suniv_cpu_init(par);
+  suniv_gpio_init();
+  suniv_lcdc_init(par);
+  suniv_enable_irq(par);
+  
+  fb_prepare_logo(info, 0);
+  fb_show_logo(info, 0);
+  return 0;
+}
+ 
+static int myfb_suspend(struct platform_device *dev, pm_message_t state)
+{
+  struct fb_info *info = platform_get_drvdata(dev);
+ 
+  console_lock();
+  fb_set_suspend(info, 1);
+  pm_runtime_put_sync(&dev->dev);
+  console_unlock();
+  return 0;
+}
+ 
+static int myfb_resume(struct platform_device *dev)
+{
+  struct fb_info *info = platform_get_drvdata(dev);
+
+  console_lock();
+  pm_runtime_get_sync(&dev->dev);
+  fb_set_suspend(info, 0);
+  console_unlock();
+  return 0;
+}
+
+static const struct of_device_id fb_of_match[] = {
+  {
+    .compatible = "allwinner,suniv-f1c500s-tcon0", 
+  },{}
+};
+MODULE_DEVICE_TABLE(of, fb_of_match);
+ 
+static struct platform_driver fb_driver = {
+  .probe    = myfb_probe,
+  .remove   = myfb_remove,
+  .suspend  = myfb_suspend,
+  .resume   = myfb_resume,
+  .driver = {
+    .name   = DRIVER_NAME,
+    .owner  = THIS_MODULE,
+    .of_match_table = of_match_ptr(fb_of_match),
+  },
+};
+ 
+static void suniv_ioremap(void)
+{
+  iomm.dma = (uint8_t*)ioremap(SUNIV_DMA_BASE, 4096);
+  iomm.ccm = (uint8_t*)ioremap(SUNIV_CCM_BASE, 4096);
+  iomm.gpio = (uint8_t*)ioremap(SUNIV_GPIO_BASE, 4096);
+  iomm.lcdc = (uint8_t*)ioremap(SUNIV_LCDC_BASE, 4096);
+  iomm.debe = (uint8_t*)ioremap(SUNIV_DEBE_BASE, 4096);
+  iomm.intc = (uint8_t*)ioremap(SUNIV_INTC_BASE, 4096);
+}
+
+static void suniv_iounmap(void)
+{
+  iounmap(iomm.dma);
+  iounmap(iomm.ccm);
+  iounmap(iomm.gpio);
+  iounmap(iomm.lcdc);
+  iounmap(iomm.debe);
+  iounmap(iomm.intc);
+}
+
+static int myopen(struct inode *inode, struct file *file)
+{
+  return 0;
+}
+
+static int myclose(struct inode *inode, struct file *file)
+{
+  return 0;
+}
+
+static long myioctl(struct file *filp, unsigned int cmd, unsigned long arg)
+{
+  int32_t w, bpp;
+  unsigned long tmp;
+
+  switch(cmd){
+  case MIYOO_FB0_PUT_OSD:
+    break;
+  case MIYOO_FB0_SET_MODE:
+    w = (arg >> 16);
+    bpp = (arg & 0xffff);
+    if((bpp != 16)){
+	    writel((5 << 8), iomm.debe + DEBE_LAY0_ATT_CTRL_REG1);
+      writel((5 << 8), iomm.debe + DEBE_LAY1_ATT_CTRL_REG1);
+    }
+    else{
+	    writel((7 << 8) | 4, iomm.debe + DEBE_LAY0_ATT_CTRL_REG1);
+	    writel((7 << 8) | 4, iomm.debe + DEBE_LAY1_ATT_CTRL_REG1);
+    }
+    break;
+  case MIYOO_FB0_GET_VER:
+    break;
+  case MIYOO_FB0_SET_FLIP:
+    break;
+  case MIYOO_FB0_GET_FPBP:
+    tmp = (def_fp & 0x0f) << 12;
+    tmp|= (def_bp & 0x0f) <<  8;
+    tmp|= (new_fp & 0x0f) <<  4;
+    tmp|= (new_bp & 0x0f) <<  0;
+    w = copy_to_user((void*)arg, &tmp, sizeof(unsigned long));
+    break;
+  case MIYOO_FB0_SET_FPBP:
+    new_fp = (arg & 0xf0) >> 4;
+    new_bp = (arg & 0x0f) >> 0;
+	  
+    flip_mode = 1;
+    mdelay(100);
+    panel_init();
+    flip_mode = 0;
+	  suniv_setbits(iomm.debe + DEBE_REGBUFF_CTRL_REG, (1 << 0));
+    break;
+  }
+  return 0;
+}
+
+static const struct file_operations myfops = {
+  .owner = THIS_MODULE,
+  .open = myopen,
+  .release = myclose,
+  .unlocked_ioctl = myioctl,
+};
+
+static int __init fb_init(void)
+{
+  suniv_ioremap(); 
+  alloc_chrdev_region(&major, 0, 1, "miyoo_fb0");
+  myclass = class_create(THIS_MODULE, "miyoo_fb0");
+  device_create(myclass, NULL, major, NULL, "miyoo_fb0");
+  cdev_init(&mycdev, &myfops);
+  cdev_add(&mycdev, major, 1);
+  return platform_driver_register(&fb_driver);
+}
+ 
+static void __exit fb_cleanup(void)
+{
+  suniv_iounmap();
+  device_destroy(myclass, major);
+  cdev_del(&mycdev);
+  class_destroy(myclass);
+  unregister_chrdev_region(major, 1);
+  platform_driver_unregister(&fb_driver);
+}
+ 
+module_init(fb_init);
+module_exit(fb_cleanup);
+ 
+MODULE_DESCRIPTION("Allwinner suniv framebuffer driver for Miyoo handheld");
+MODULE_AUTHOR("Steward Fu <steward.fu@gmail.com>");
+MODULE_LICENSE("GPL");
diff --git a/drivers/video/fbdev/miyoo-tvout.c b/drivers/video/fbdev/miyoo-tvout.c
new file mode 100644
index 00000000..8dacdb7d
--- /dev/null
+++ b/drivers/video/fbdev/miyoo-tvout.c
@@ -0,0 +1,969 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option)any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#include <linux/cdev.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/fb.h>
+#include <linux/dma-mapping.h>
+#include <linux/device.h>
+#include <linux/backlight.h>
+#include <linux/platform_device.h>
+#include <linux/uaccess.h>
+#include <linux/pm_runtime.h>
+#include <linux/interrupt.h>
+#include <linux/wait.h>
+#include <linux/clk.h>
+#include <linux/cpufreq.h>
+#include <linux/console.h>
+#include <linux/spinlock.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+#include <linux/lcm.h>
+#include <linux/clk-provider.h>
+#include <video/of_display_timing.h>
+#include <linux/gpio.h>
+#include <linux/omapfb.h>
+#include <linux/compiler.h>
+#include <linux/workqueue.h>
+#include <linux/sched.h>
+#include <asm/io.h>
+#include <asm/gpio.h>
+
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <sound/tlv.h>
+#include <sound/initval.h>
+#include <sound/dmaengine_pcm.h>
+#include <linux/gpio.h>
+
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/gpio.h>
+#include <asm/arch-suniv/cpu.h>
+#include <asm/arch-suniv/dma.h>
+#include <asm/arch-suniv/gpio.h>
+#include <asm/arch-suniv/intc.h>
+#include <asm/arch-suniv/lcdc.h>
+#include <asm/arch-suniv/debe.h>
+#include <asm/arch-suniv/codec.h>
+#include <asm/arch-suniv/clock.h>
+#include <asm/arch-suniv/common.h>
+#include <asm/arch-suniv/tve.h>
+
+#define PALETTE_SIZE 256
+#define DRIVER_NAME  "tvout-fb"
+#define MIYOO_FB0_PUT_OSD     _IOWR(0x100, 0, unsigned long)
+#define MIYOO_FB0_SET_MODE    _IOWR(0x101, 0, unsigned long)
+static int tvmode=0;
+module_param(tvmode,int,0660);
+
+
+struct myfb_app{
+    uint32_t yoffset;
+    uint32_t vsync_count;
+};
+
+struct myfb_par {
+    struct device *dev;
+    struct platform_device *pdev;
+
+    resource_size_t p_palette_base;
+    unsigned short *v_palette_base;
+
+    dma_addr_t vram_phys;
+    uint32_t vram_size;
+    void *vram_virt;
+    int yoffset;
+    void *dma_addr;
+
+    int bpp;
+    int lcdc_irq;
+    int gpio_irq;
+    volatile int have_te;
+    u32 pseudo_palette[16];
+    struct fb_videomode mode;
+};
+
+struct suniv_iomm {
+    uint8_t *dma;
+    uint8_t *ccm;
+    uint8_t *lcdc;
+    uint8_t *debe;
+    uint8_t *intc;
+    uint8_t *timer;
+    uint8_t *tve;
+    uint8_t *defe;
+};
+static int major = -1;
+static struct cdev mycdev;
+static struct class *myclass = NULL;
+struct timer_list mytimer;
+static struct suniv_iomm iomm={0};
+static struct myfb_par *mypar=NULL;
+static struct fb_var_screeninfo myfb_var={0};
+
+uint16_t i;
+uint32_t val;
+tve_mode_e mode;
+static struct fb_fix_screeninfo myfb_fix = {
+        .id = DRIVER_NAME,
+        .type = FB_TYPE_PACKED_PIXELS,
+        .type_aux = 0,
+        .visual = FB_VISUAL_TRUECOLOR,
+        .xpanstep = 0,
+        .ypanstep = 1,
+        .ywrapstep = 0,
+        .accel = FB_ACCEL_NONE
+};
+
+static const uint32_t csc_tab[192] =
+        {
+                //Y/G   Y/G     Y/G     Y/G     U/R     U/R     U/R     U/R     V/B     V/B     V/B     V/B
+                //bt601
+                0x04a8, 0x1e70, 0x1cbf, 0x0878, 0x04a8, 0x0000, 0x0662, 0x3211, 0x04a8, 0x0812, 0x0000, 0x2eb1, //yuv2rgb
+                0x0400, 0x0000, 0x0000, 0x0000, 0x0000, 0x0400, 0x0000, 0x0000, 0x0000, 0x0000, 0x0400, 0x0000, //yuv2yuv
+                0x0400, 0x0000, 0x0000, 0x0000, 0x0000, 0x0400, 0x0000, 0x0000, 0x0000, 0x0000, 0x0400, 0x0000, //rgb2rgb
+                0x0204, 0x0107, 0x0064, 0x0100, 0x1ed6, 0x1f68, 0x01c2, 0x0800, 0x1e87, 0x01c2, 0x1fb7, 0x0800, //rgb2yuv
+
+                //bt709
+                0x04a8, 0x1f26, 0x1ddd, 0x04d0, 0x04a8, 0x0000, 0x072c, 0x307e, 0x04a8, 0x0876, 0x0000, 0x2dea, //yuv2rgb
+                0x0400, 0x0000, 0x0000, 0x0000, 0x0000, 0x0400, 0x0000, 0x0000, 0x0000, 0x0000, 0x0400, 0x0000, //yuv2yuv
+                0x0400, 0x0000, 0x0000, 0x0000, 0x0000, 0x0400, 0x0000, 0x0000, 0x0000, 0x0000, 0x0400, 0x0000, //rgb2rgb
+                0x0275, 0x00bb, 0x003f, 0x0100, 0x1ea6, 0x1f99, 0x01c2, 0x0800, 0x1e67, 0x01c2, 0x1fd7, 0x0800, //rgb2yuv
+
+                //DISP_ YCC
+                0x0400, 0x1e9e, 0x1d24, 0x087b, 0x0400, 0x0000, 0x059c, 0x34c8, 0x0400, 0x0716, 0x0000, 0x31d5, //yuv2rgb
+                0x0400, 0x0000, 0x0000, 0x0000, 0x0000, 0x0400, 0x0000, 0x0000, 0x0000, 0x0000, 0x0400, 0x0000, //yuv2yuv
+                0x0400, 0x0000, 0x0000, 0x0000, 0x0000, 0x0400, 0x0000, 0x0000, 0x0000, 0x0000, 0x0400, 0x0000, //rgb2rgb
+                0x0259, 0x0132, 0x0075, 0x0000, 0x1ead, 0x1f53, 0x0200, 0x0800, 0x1e54, 0x0200, 0x1fac, 0x0800, //rgb2yuv
+
+                //xvYCC
+                0x04a8, 0x1f26, 0x1ddd, 0x04d0, 0x04a8, 0x0000, 0x072c, 0x307e, 0x04a8, 0x0876, 0x0000, 0x2dea, //yuv2rgb
+                0x0400, 0x0000, 0x0000, 0x0000, 0x0000, 0x0400, 0x0000, 0x0000, 0x0000, 0x0000, 0x0400, 0x0000, //yuv2yuv
+                0x0400, 0x0000, 0x0000, 0x0000, 0x0000, 0x0400, 0x0000, 0x0000, 0x0000, 0x0000, 0x0400, 0x0000, //rgb2rgb
+                0x0275, 0x00bb, 0x003f, 0x0100, 0x1ea6, 0x1f99, 0x01c2, 0x0800, 0x1e67, 0x01c2, 0x1fd7, 0x0800, //rgb2yuv
+        };
+
+typedef struct
+{
+    uint16_t width;
+    uint16_t fbwidth;
+    uint16_t height;
+    uint8_t bits_per_pixel;
+} de_layer_params_t;
+
+typedef struct
+{
+    uint32_t width;
+    uint32_t height;
+    de_layer_params_t layer[4];
+    de_mode_e mode;
+} de_params_t;
+
+static de_params_t de;
+
+
+static uint32_t pll_video_get_freq(void) // +
+{
+    uint32_t reg = readl(iomm.ccm + PLL_VIDEO_CTRL_REG);
+
+    if ((reg & (1 << 24)) == 0)
+    {                           // Fractional mode
+        if (reg & (1 << 25))
+            return 297000000;
+        else
+            return 270000000;
+    }
+    else
+    {                           // Integer mode
+        uint32_t mul = (reg >> 8) & 0x7F;
+        uint32_t div = (reg >> 0) & 0xF;
+
+        return (24000000 * (mul + 1) / (div + 1));
+    }
+}
+
+// Video encoder clock configuration
+void clk_tve_config(uint8_t div) // todo: source select
+{
+    if ((div == 0) || (div > 16))
+        return;
+    writel((0x80008100) | (div-1), iomm.ccm + TVE_CLK_REG );
+}
+
+void tve_init(tve_mode_e mode)
+{
+
+    // Determine tve clock division value. PLL_VIDEO should be configured and enabled!
+    uint32_t tve_clk_div = pll_video_get_freq() / 27000000LU;
+    clk_tve_config(tve_clk_div);
+    suniv_setbits(iomm.ccm + BUS_CLK_GATING_REG1, (1 << 10));
+    suniv_setbits(iomm.ccm + BUS_SOFT_RST_REG1, (1 << 10));
+
+    writel(0x433810A1, iomm.tve +TVE_DAC1);
+    if (mode == TVE_MODE_NTSC) // NTSC
+    {
+        writel(0x07030000, iomm.tve +TVE_CFG1 );
+        writel(0x00000120, iomm.tve +TVE_NOTCH_DELAY );
+        writel(0x21F07C1F, iomm.tve +TVE_CHROMA_FREQ );
+        writel(0x00760020, iomm.tve +TVE_FB_PORCH );
+        writel(0x00000016, iomm.tve +TVE_HD_VS );
+        writel(0x0016020D, iomm.tve +TVE_LINE_NUM );
+        writel(0x00F0011A, iomm.tve +TVE_LEVEL );
+        writel(0x00000001, iomm.tve +TVE_CB_RESET );
+        writel(0x00000000, iomm.tve +TVE_VS_NUM );
+        writel(0x00000002, iomm.tve +TVE_FILTER );
+        writel(0x0000004F, iomm.tve +TVE_CBCR_LEVEL );
+        writel(0x00000000, iomm.tve +TVE_TINT_PHASE );
+        writel(0x0016447E, iomm.tve +TVE_B_WIDTH );
+        writel(0x0000A0A0, iomm.tve +TVE_CBCR_GAIN );
+        writel(0x001000F0, iomm.tve +TVE_SYNC_LEVEL );
+        writel(0x01E80320, iomm.tve +TVE_WHITE_LEVEL );
+        writel(0x000005A0, iomm.tve +TVE_ACT_LINE );
+        writel(0x00000000, iomm.tve +TVE_CHROMA_BW );
+        writel(0x00000101, iomm.tve +TVE_CFG2 );
+        writel(0x000E000C, iomm.tve +TVE_RESYNC );
+        writel(0x00000000, iomm.tve +TVE_SLAVE );
+        writel(0x00000000, iomm.tve +TVE_CFG3 );
+        writel(0x00000000, iomm.tve +TVE_CFG4 );
+    }
+    else // PAL
+    {
+        writel(0x07030001, iomm.tve +TVE_CFG1 );
+        writel(0x00000120, iomm.tve +TVE_NOTCH_DELAY );
+        writel(0x2A098ACB, iomm.tve +TVE_CHROMA_FREQ );
+        writel(0x008A0018, iomm.tve +TVE_FB_PORCH );
+        writel(0x00000016, iomm.tve +TVE_HD_VS );
+        writel(0x00160271, iomm.tve +TVE_LINE_NUM );
+        writel(0x00FC00FC, iomm.tve +TVE_LEVEL );
+        writel(0x00000000, iomm.tve +TVE_CB_RESET );
+        writel(0x00000001, iomm.tve +TVE_VS_NUM );
+        writel(0x00000005, iomm.tve +TVE_FILTER );
+        writel(0x00002828, iomm.tve +TVE_CBCR_LEVEL );
+        writel(0x00000000, iomm.tve +TVE_TINT_PHASE );
+        writel(0x0016447E, iomm.tve +TVE_B_WIDTH );
+        writel(0x0000E0E0, iomm.tve +TVE_CBCR_GAIN );
+        writel(0x001000F0, iomm.tve +TVE_SYNC_LEVEL );
+        writel(0x01E80320, iomm.tve +TVE_WHITE_LEVEL );
+        writel(0x000005A0, iomm.tve +TVE_ACT_LINE );
+        writel(0x00000000, iomm.tve +TVE_CHROMA_BW );
+        writel(0x00000101, iomm.tve +TVE_CFG2 );
+        writel(0x800D000C, iomm.tve +TVE_RESYNC );
+        writel(0x00000000, iomm.tve +TVE_SLAVE );
+        writel(0x00000000, iomm.tve +TVE_CFG3 );
+        writel(0x00000000, iomm.tve +TVE_CFG4 );
+    }
+    writel(1, iomm.tve +TVE_ENABLE );
+}
+
+void tve_enable(void)
+{
+    suniv_setbits(iomm.tve +TVE_DAC1, 0x1 << 0);
+    suniv_setbits(iomm.tve +TVE_ENABLE, 0x1 << 0);
+}
+
+static void tcon1_init(tve_mode_e mode) // TCON1 -> TVE
+{
+    uint32_t ret;
+    writel(0, iomm.lcdc + TCON_CTRL_REG);
+    writel(0, iomm.lcdc + TCON_INT_REG0);
+    ret = readl(iomm.lcdc + TCON_CLK_CTRL_REG);
+    ret&= ~(0xf << 28);
+    writel(ret, iomm.lcdc + TCON_CLK_CTRL_REG);
+    writel(0xffffffff, iomm.lcdc + TCON0_IO_CTRL_REG1);
+    writel(0xffffffff, iomm.lcdc + TCON1_IO_CTRL_REG1);
+    ret = readl(iomm.lcdc + TCON_CTRL_REG);
+    ret&= ~(1 << 0);
+    writel(ret, iomm.lcdc + TCON_CTRL_REG);
+    if (mode == TVE_MODE_NTSC)
+    {
+        writel(0x00100130,iomm.lcdc + TCON1_CTRL_REG);
+        writel(((720-1) << 16) | (480/2-1),iomm.lcdc + TCON1_BASIC_REG0);
+        writel(((720-1) << 16) | (480/2-1),iomm.lcdc + TCON1_BASIC_REG1);
+        writel(((720-1) << 16) | (480/2-1),iomm.lcdc + TCON1_BASIC_REG2);
+        writel(((858-1) << 16) | (117),iomm.lcdc + TCON1_BASIC_REG3);
+        writel((525 << 16) | (18),iomm.lcdc + TCON1_BASIC_REG4);
+    }
+    else if (mode == TVE_MODE_PAL)
+    {
+        writel(0x00100150,iomm.lcdc + TCON1_CTRL_REG);
+        writel(((720-1) << 16) | (575/2-1),iomm.lcdc + TCON1_BASIC_REG0);
+        writel(((720-1) << 16) | (575/2-1),iomm.lcdc + TCON1_BASIC_REG1);
+        writel(((720-1) << 16) | (575/2-1),iomm.lcdc + TCON1_BASIC_REG2);
+        writel(((864-1) << 16) | (138),iomm.lcdc + TCON1_BASIC_REG3);
+        writel((625 << 16) | (22),iomm.lcdc + TCON1_BASIC_REG4);
+    }
+
+    writel(0x00010001,iomm.lcdc + TCON1_BASIC_REG5);
+    writel(0x00000000,iomm.lcdc + TCON1_IO_CTRL_REG0);
+    writel(0x0FFFFFFF,iomm.lcdc + TCON1_IO_CTRL_REG1);
+}
+
+static void debe_update_linewidth(uint8_t layer)
+{
+    if (layer > 3)
+        return;
+
+    val = de.layer[layer].width * de.layer[layer].bits_per_pixel;
+    writel(val, iomm.debe + DEBE_LAY0_LINEWIDTH_REG + layer*4);
+}
+
+void debe_layer_set_size(uint8_t layer, uint16_t w, uint16_t h)
+{
+    if (layer > 3)
+        return;
+    de.layer[layer].width = w;
+    de.layer[layer].height = h;
+
+    writel(((h - 1) << 16) | (w - 1), iomm.debe + DEBE_LAY0_SIZE_REG + layer*4);
+
+    debe_update_linewidth(layer);
+}
+
+void debe_layer_init(uint8_t layer)
+{
+    if (layer > 3)
+        return;
+    de.layer[layer].width = de.width;
+    de.layer[layer].height = de.height;
+
+    writel((20 << 0) | (20 << 16), iomm.debe + DEBE_LAY0_CODNT_REG + layer*4);
+    writel(((de.height - 1) << 16) | (de.width - 1), iomm.debe + DEBE_LAY0_SIZE_REG + layer*4 );
+
+    debe_update_linewidth(layer);
+}
+
+void debe_layer_set_mode(uint8_t layer, debe_color_mode_e mode)
+{
+    if (layer > 3)
+        return;
+    if (mode == DEBE_MODE_DEFE_VIDEO)
+    {
+        val = readl(iomm.debe + DEBE_LAY0_ATT_CTRL_REG0 + layer*4) & ~(3 << 1);
+        writel(val | (1 << 1), iomm.debe + DEBE_LAY0_ATT_CTRL_REG0 + layer*4);
+    }
+    else if (mode == DEBE_MODE_YUV)
+    {
+        val = readl(iomm.debe + DEBE_LAY0_ATT_CTRL_REG0 + layer*4) & ~(3 << 1);
+        writel(val | (1 << 2),iomm.debe + DEBE_LAY0_ATT_CTRL_REG0 + layer*4);
+    }
+    else
+    {
+        de.layer[layer].bits_per_pixel = (mode >> 8) & 0x00FF;
+
+        if (mode & DEBE_PALETTE_EN)
+            suniv_setbits(iomm.debe + DEBE_LAY0_ATT_CTRL_REG0 + layer*4, (1 << 22));
+        else
+            suniv_clrbits(iomm.debe + DEBE_LAY0_ATT_CTRL_REG0 + layer*4, (1 << 22));
+
+        val = readl(iomm.debe + DEBE_LAY0_ATT_CTRL_REG1 + layer*4) & ~(0x0F << 8);
+        writel(val | ((mode & 0x0F) << 8),iomm.debe + DEBE_LAY0_ATT_CTRL_REG1 + layer*4);
+
+        debe_update_linewidth(layer);
+    }
+}
+
+static void debe_init(struct myfb_par *par)
+{
+    writel((1 << 1), iomm.debe + DEBE_MODE_CTRL_REG);
+    for (i = 0; i < 1; i++)
+    {
+        writel(0, iomm.debe + DEBE_LAY0_ATT_CTRL_REG1 + i*4);
+        de.layer[i].bits_per_pixel = 32;
+        debe_layer_init(i);
+        debe_layer_set_mode(i, DEBE_MODE_DEFE_VIDEO);
+    }
+    for (i = 0; i < 4; i++) {
+        writel(csc_tab[12 * 3 + i] << 16, iomm.debe + DEBE_COEF00_REG + i * 4 + 0 * 4);
+        writel(csc_tab[12 * 3 + i + 4] << 16, iomm.debe + DEBE_COEF00_REG + i * 4 + 4 * 4);
+        writel(csc_tab[12 * 3 + i + 8] << 16, iomm.debe + DEBE_COEF00_REG + i * 4 + 8 * 4);
+    }
+    suniv_setbits(iomm.debe + DEBE_MODE_CTRL_REG, (1 << 5)); // CSC enable
+}
+
+// TCON clock configuration
+void clk_tcon_config(void)
+{
+    uint32_t val = readl(iomm.ccm + TCON_CLK_REG) & ~(0x7 << 24);
+    writel( val | (0 << 24), iomm.ccm + TCON_CLK_REG);
+}
+
+void defe_init_spl_422(uint16_t in_w, uint16_t in_h, struct myfb_par *par)
+{
+    suniv_setbits(iomm.defe+DEFE_EN, 0x01); // Enable DEFE
+    suniv_setbits(iomm.defe+DEFE_EN, (1 << 31)); // Enable CPU access
+    writel((0 << 0) | (1 << 1), iomm.defe+DEFE_BYPASS); // CSC/scaler bypass disabled
+
+    writel((uint32_t)((par->vram_phys)), iomm.defe+DEFE_ADDR0);
+    writel(in_w*4, iomm.defe+DEFE_STRIDE0);
+    writel((in_w-1) | ((in_h-1) << 16), iomm.defe+DEFE_IN_SIZE);
+    if (tvmode == 0) {
+        writel((665-1) | ((450-1) << 16), iomm.defe+DEFE_OUT_SIZE);
+        writel((31500 << 0), iomm.defe+DEFE_H_FACT); // H scale
+        writel((70600 << 0), iomm.defe+DEFE_V_FACT); // V scale
+    }
+    else {
+        writel((665-1) | ((546-1) << 16), iomm.defe+DEFE_OUT_SIZE);
+        writel((31500 << 0), iomm.defe+DEFE_H_FACT); // H scale
+        writel((59000 << 0), iomm.defe+DEFE_V_FACT); // V scale
+    }
+
+
+    writel( (1 << 8 ) | (5 << 4) | (1 << 0), iomm.defe+DEFE_IN_FMT); // ARGB888
+    writel( (1 << 4), iomm.defe+DEFE_OUT_FMT); // Output interlace enable
+    suniv_setbits(iomm.defe+DEFE_FRM_CTRL, (1 << 23)); // Enable CPU access to filter RAM (if enabled, filter is bypassed?)
+    suniv_clrbits(iomm.defe+DEFE_EN, (1 << 31)); // Disable CPU access (?)
+    suniv_setbits(iomm.defe+DEFE_FRM_CTRL, (1 << 0)); // Registers ready
+    suniv_setbits(iomm.defe+DEFE_FRM_CTRL, (1 << 16)); // Start frame processing
+}
+
+static void suniv_tve_init(struct myfb_par *par)
+{
+    de.mode = DE_TV;
+
+    if (tvmode == 0) {
+        mode = TVE_MODE_NTSC;
+        de.width = 665;
+        de.height = 450;
+    }
+    else {
+        mode = TVE_MODE_PAL;
+        de.width = 665;
+        de.height = 546;
+    }
+    defe_init_spl_422(320, 240, par);
+    debe_init(par);
+    tcon1_init(mode);
+    suniv_setbits(iomm.lcdc + TCON1_CTRL_REG, (1 << 31));
+    suniv_setbits(iomm.tve + TVE_DAC1, 0x1 << 0);
+    suniv_setbits(iomm.tve + TVE_ENABLE, 0x1 << 0);
+    suniv_setbits(iomm.lcdc + TCON_CTRL_REG, (1 << 31));
+    suniv_setbits(iomm.debe + DEBE_MODE_CTRL_REG, (1 << 0));
+    suniv_setbits(iomm.debe + DEBE_MODE_CTRL_REG, (1 << 8));
+    tve_init(mode);
+}
+
+static void pll_video_init(uint8_t mul, uint8_t div) // out = (24MHz*N) / M
+{
+    if ((mul == 0) || (div == 0))
+        return;
+    if ((mul > 128) || (div > 16))
+        return;
+
+    // mul = n
+    // div = m
+
+    uint32_t val = readl(iomm.ccm + PLL_VIDEO_CTRL_REG);
+    val &= (1 << 31) | (1 << 28);
+    val |= ((mul - 1) << 8) | (div - 1) | (1 << 24);
+    writel(val, iomm.ccm + PLL_VIDEO_CTRL_REG);
+}
+
+// CPU clock configuration
+void clk_cpu_config(clk_source_cpu_e source)
+{
+    uint32_t reg = readl(iomm.ccm +CCU_CPU_CFG) & ~(0x3 << 16);
+    writel( reg | (source << 16), iomm.ccm+CCU_CPU_CFG);
+}
+
+static void pll_periph_init(uint8_t mul, uint8_t div) // out = (24MHz*N) / M
+{
+    if ((mul == 0) || (div == 0))
+        return;
+    if ((mul > 32) || (div > 4))
+        return;
+
+    // mul = n
+    // div = m
+
+    uint32_t val = readl(iomm.ccm + CCU_PLL_PERIPH_CTRL);
+    val &= (1 << 31) | (1 << 28);
+    val |= ((mul - 1) << 8) | ((div - 1) << 4) | (1 << 18); // do we need 24m output?
+    writel(val, iomm.ccm + CCU_PLL_PERIPH_CTRL);
+}
+
+// Enable PLL
+inline void clk_pll_enable(pll_ch_e pll)
+{
+    writel((readl(iomm.ccm+pll)|(1 << 31)), iomm.ccm+pll);
+}
+
+// Get PLL lock state
+uint8_t clk_pll_is_locked(pll_ch_e pll)
+{
+    uint32_t val = readl(iomm.ccm + pll);
+    return ((val >> 28) & 0x1);
+}
+
+void clk_hclk_config(uint8_t div) // HCLK = CPUCLK / div
+{
+    if ((div == 0) || (div > 4))
+        return;
+
+    uint32_t val = readl(iomm.ccm+CCU_AHB_APB_CFG) & ~(0x3 << 16);
+    writel(val | ((div-1) << 16), iomm.ccm+CCU_AHB_APB_CFG);
+}
+
+void clk_apb_config(clk_div_apb_e div) // APB = AHB / div
+{
+    uint32_t val = readl(iomm.ccm+CCU_AHB_APB_CFG) & ~(0x3 << 8);
+    writel( val | (div << 8), iomm.ccm+CCU_AHB_APB_CFG);
+}
+
+void clk_ahb_config(clk_source_ahb_e src, uint8_t prediv, uint8_t div) // AHB = (src or src/prediv)/div
+{
+    if ((prediv == 0) || (prediv > 4))
+        return;
+    if ((div == 0) || ((div > 4) && (div != 8)) || (div == 3))
+        return;
+    if (div == 4)
+        div = 3;
+    if (div == 8)
+        div = 4;
+
+    uint32_t val = readl(iomm.ccm+CCU_AHB_APB_CFG) & ~((0x3 << 12) | (0xF << 4));
+    writel(val | (src << 12) | ((prediv-1) << 6) | ((div-1) << 4), iomm.ccm+CCU_AHB_APB_CFG);
+}
+
+static void pll_cpu_init(uint8_t mul, uint8_t div) // out = (24MHz*N*K) / (M*P)
+{
+    if ((mul == 0) || (div == 0))
+        return;
+    if ((mul > 128) || (div > 16))
+        return;
+
+    uint8_t n, k, m, p;
+    // mul = n*k
+    // n = 1..32
+    // k = 1..4
+    for (k = 1; k <= 4; k++)
+    {
+        n = mul / k;
+        if ((n < 32) && (n * k == mul))
+            break;
+    }
+    if (n * k != mul)
+        return;
+    // div = m*p
+    // m = 1..4
+    // k = 1,2,4
+    for (m = 1; m <= 4; m++)
+    {
+        p = div / m;
+        if (((p == 1) || (p == 2) || (p == 4)) && (m * p == div))
+            break;
+    }
+    if (m * p != div)
+        return;
+
+    p--;
+    if (p == 3)
+        p = 2;
+
+    uint32_t val = readl(iomm.ccm + CCU_PLL_CPU_CTRL);
+    val &= (1 << 31) | (1 << 28);
+    val |= ((n - 1) << 8) | ((k - 1) << 4) | (m - 1) | (p << 16);
+    writel(val, iomm.ccm + CCU_PLL_CPU_CTRL);
+}
+
+static void suniv_cpu_init(struct myfb_par *par)
+{
+    uint32_t ret, i;
+
+    // Set CPU clock to 24MHz
+    clk_cpu_config(CLK_CPU_SRC_OSC24M);
+    mdelay(10); // Wait for some clock cycles
+
+    pll_periph_init(25, 1); // PLL_PERIPH = 24M*25/1 = 600M
+    clk_pll_enable(PLL_PERIPH);
+    while (!clk_pll_is_locked(PLL_PERIPH)); // Wait for PLL to lock
+
+    // Configure bus clocks
+    clk_hclk_config(1); // HCLK = CLK_CPU
+    clk_ahb_config(CLK_AHB_SRC_PLL_PERIPH_PREDIV, 3, 1); // AHB = PLL_PERIPH/3/1 = 200M
+    clk_apb_config(CLK_APB_DIV_2); // APB = AHB/2 = 100M
+    mdelay(10);
+
+    // Configure video clocks
+    pll_video_init(99,8); // 24*99/8 = 297MHz
+    clk_pll_enable(PLL_VIDEO);
+
+    // Configure CPU PLL
+    pll_cpu_init(30, 1); // PLL_CPU = 24M*30/1 = 720M
+    clk_pll_enable(PLL_CPU);
+    while (!clk_pll_is_locked(PLL_CPU)); // Wait for PLL to lock
+
+    // Select PLL as CPU clock source
+    clk_cpu_config(CLK_CPU_SRC_PLL_CPU);
+    mdelay(10);
+    while((readl(iomm.ccm + PLL_VIDEO_CTRL_REG) & (1 << 28)) == 0){}
+    while((readl(iomm.ccm + PLL_PERIPH_CTRL_REG) & (1 << 28)) == 0){}
+
+    ret = readl(iomm.ccm + DRAM_GATING_REG);
+    ret|= (1 << 26) | (1 << 24);
+    writel(ret, iomm.ccm + DRAM_GATING_REG);
+
+    suniv_setbits(iomm.ccm + FE_CLK_REG, (1 << 31));
+    suniv_setbits(iomm.ccm + BE_CLK_REG, (1 << 31));
+    suniv_setbits(iomm.ccm + TCON_CLK_REG, (1 << 31) | (0 << 25));
+    suniv_setbits(iomm.ccm + BUS_CLK_GATING_REG1, (1 << 14) | (1 << 12) | (1 << 4));
+    suniv_setbits(iomm.ccm + BUS_SOFT_RST_REG1, (1 << 14) | (1 << 12) | (1 << 4));
+    for(i=0x0800; i<0x1000; i+=4){
+        writel(0, iomm.debe + i);
+    }
+}
+
+
+#define CNVT_TOHW(val, width) ((((val) << (width)) + 0x7FFF - (val)) >> 16)
+static int myfb_setcolreg(unsigned regno, unsigned red, unsigned green, unsigned blue, unsigned transp, struct fb_info *info)
+{
+    red = CNVT_TOHW(red, info->var.red.length);
+    blue = CNVT_TOHW(blue, info->var.blue.length);
+    green = CNVT_TOHW(green, info->var.green.length);
+    ((u32*)(info->pseudo_palette))[regno] = (red << info->var.red.offset) | (green << info->var.green.offset) | (blue << info->var.blue.offset);
+    return 0;
+}
+#undef CNVT_TOHW
+
+static int myfb_check_var(struct fb_var_screeninfo *var, struct fb_info *info)
+{
+    int bpp = var->bits_per_pixel >> 3;
+    struct myfb_par *par = info->par;
+    unsigned long line_size = var->xres_virtual * bpp;
+
+    if((var->xres != 320) || (var->yres != 240) || (var->bits_per_pixel != 32)){
+        return -EINVAL;
+    }
+
+    var->transp.offset = 0;
+    var->transp.length = 0;
+    var->red.offset = 16;
+    var->red.length = 8;
+    var->green.offset = 8;
+    var->green.length = 8;
+    var->blue.offset = 0;
+    var->blue.length = 8;
+    var->red.msb_right = 0;
+    var->green.msb_right = 0;
+    var->blue.msb_right = 0;
+    var->transp.msb_right = 0;
+    if(line_size * var->yres_virtual > par->vram_size){
+        var->yres_virtual = par->vram_size / line_size;
+    }
+    if(var->yres > var->yres_virtual){
+        var->yres = var->yres_virtual;
+    }
+    if(var->xres > var->xres_virtual){
+        var->xres = var->xres_virtual;
+    }
+    if(var->xres + var->xoffset > var->xres_virtual){
+        var->xoffset = var->xres_virtual - var->xres;
+    }
+    if(var->yres + var->yoffset > var->yres_virtual){
+        var->yoffset = var->yres_virtual - var->yres;
+    }
+    return 0;
+}
+
+static int myfb_remove(struct platform_device *dev)
+{
+    int i;
+    struct fb_info *info = dev_get_drvdata(&dev->dev);
+    struct myfb_par *par = info->par;
+
+    if(info){
+        flush_scheduled_work();
+        unregister_framebuffer(info);
+        fb_dealloc_cmap(&info->cmap);
+        dma_free_coherent(NULL, PALETTE_SIZE, par->v_palette_base, par->p_palette_base);
+        dma_free_coherent(NULL, par->vram_size, par->vram_virt, par->vram_phys);
+        pm_runtime_put_sync(&dev->dev);
+        pm_runtime_disable(&dev->dev);
+        framebuffer_release(info);
+    }
+    return 0;
+}
+
+static int myfb_set_par(struct fb_info *info)
+{
+    struct myfb_par *par = info->par;
+
+    fb_var_to_videomode(&par->mode, &info->var);
+    par->yoffset = info->var.yoffset;
+    par->bpp = info->var.bits_per_pixel;
+    info->fix.visual = FB_VISUAL_TRUECOLOR;
+    info->fix.line_length = (par->mode.xres * par->bpp) / 8;
+    writel((9 << 8), iomm.debe + DEBE_LAY0_ATT_CTRL_REG1);
+    writel((9 << 8), iomm.debe + DEBE_LAY1_ATT_CTRL_REG1);
+    return 0;
+}
+
+static int myfb_ioctl(struct fb_info *info, unsigned int cmd, unsigned long arg)
+{
+    switch(cmd){
+        case FBIO_WAITFORVSYNC:
+            break;
+    }
+    return 0;
+}
+
+static int myfb_mmap(struct fb_info *info, struct vm_area_struct *vma)
+{
+    const unsigned long offset = vma->vm_pgoff << PAGE_SHIFT;
+    const unsigned long size = vma->vm_end - vma->vm_start;
+
+    if(offset + size > info->fix.smem_len){
+        return -EINVAL;
+    }
+
+    if(remap_pfn_range(vma, vma->vm_start, (info->fix.smem_start + offset) >> PAGE_SHIFT, size, vma->vm_page_prot)){
+        return -EAGAIN;
+    }
+    return 0;
+}
+
+static int myfb_pan_display(struct fb_var_screeninfo *var, struct fb_info *info)
+{
+    struct myfb_par *par = info->par;
+    if((var->xoffset != info->var.xoffset) || (var->yoffset != info->var.yoffset)){
+        info->var.xoffset = var->xoffset;
+        info->var.yoffset = var->yoffset;
+        par->yoffset = var->yoffset;
+    }
+    return 0;
+}
+
+static struct fb_ops myfb_ops = {
+        .owner          = THIS_MODULE,
+        .fb_check_var   = myfb_check_var,
+        .fb_set_par     = myfb_set_par,
+        .fb_setcolreg   = myfb_setcolreg,
+        .fb_pan_display = myfb_pan_display,
+        .fb_ioctl       = myfb_ioctl,
+        .fb_mmap        = myfb_mmap,
+
+        .fb_fillrect  = sys_fillrect,
+        .fb_copyarea  = sys_copyarea,
+        .fb_imageblit = sys_imageblit,
+};
+
+static int myfb_probe(struct platform_device *device)
+{
+    int i, ret;
+    struct fb_info *info;
+    struct myfb_par *par;
+    struct fb_videomode *mode;
+
+    mode = devm_kzalloc(&device->dev, sizeof(struct fb_videomode), GFP_KERNEL);
+    if(mode == NULL){
+        return -ENOMEM;
+    }
+    mode->name = "320x240";
+    mode->xres = 320;
+    mode->yres = 240;
+    mode->vmode = FB_VMODE_NONINTERLACED;
+    pm_runtime_enable(&device->dev);
+    pm_runtime_get_sync(&device->dev);
+
+    info = framebuffer_alloc(sizeof(struct myfb_par), &device->dev);
+    if(!info){
+        dev_dbg(&device->dev, "memory allocation failed for fb_info\n");
+        return -ENOMEM;
+    }
+
+    par = info->par;
+    par->pdev = device;
+    par->dev = &device->dev;
+    par->bpp = 32;
+    fb_videomode_to_var(&myfb_var, mode);
+
+    par->vram_size = 320*240*2*2;
+    par->vram_virt = dma_alloc_coherent(NULL, par->vram_size, (resource_size_t*)&par->vram_phys, GFP_KERNEL | GFP_DMA);
+    if(!par->vram_virt){
+        dev_err(&device->dev, "%s, failed to allocate frame buffer(vram)\n", __func__);
+        return -EINVAL;
+    }
+    info->screen_base = (char __iomem*)par->vram_virt;
+    myfb_fix.smem_start = par->vram_phys;
+    myfb_fix.smem_len = par->vram_size;
+    myfb_fix.line_length = 320 * 4;
+
+    par->v_palette_base = dma_alloc_coherent(NULL, PALETTE_SIZE, (resource_size_t*)&par->p_palette_base, GFP_KERNEL | GFP_DMA);
+    if(!par->v_palette_base){
+        dev_err(&device->dev, "GLCD: kmalloc for palette buffer failed\n");
+        return -EINVAL;
+    }
+    memset(par->v_palette_base, 0, PALETTE_SIZE);
+    myfb_var.grayscale = 0;
+    myfb_var.bits_per_pixel = par->bpp;
+
+    info->flags = FBINFO_FLAG_DEFAULT;
+    info->fix = myfb_fix;
+    info->var = myfb_var;
+    info->fbops = &myfb_ops;
+    info->pseudo_palette = par->pseudo_palette;
+    info->fix.visual = (info->var.bits_per_pixel <= 8) ? FB_VISUAL_PSEUDOCOLOR : FB_VISUAL_TRUECOLOR;
+    ret = fb_alloc_cmap(&info->cmap, PALETTE_SIZE, 0);
+    if(ret){
+        return -EINVAL;
+    }
+    info->cmap.len = 32;
+
+    myfb_var.activate = FB_ACTIVATE_FORCE;
+    fb_set_var(info, &myfb_var);
+    dev_set_drvdata(&device->dev, info);
+
+    if(register_framebuffer(info) < 0){
+        dev_err(&device->dev, "failed to register /dev/fb0\n");
+        return -EINVAL;
+    }
+
+    mypar = par;
+    for(ret=0; ret<of_clk_get_parent_count(device->dev.of_node); ret++){
+        clk_prepare_enable(of_clk_get(device->dev.of_node, ret));
+    }
+    suniv_cpu_init(par);
+    suniv_tve_init(par);
+
+    fb_prepare_logo(info, 0);
+    fb_show_logo(info, 0);
+    return 0;
+}
+
+static int myfb_suspend(struct platform_device *dev, pm_message_t state)
+{
+    struct fb_info *info = platform_get_drvdata(dev);
+
+    console_lock();
+    fb_set_suspend(info, 1);
+    pm_runtime_put_sync(&dev->dev);
+    console_unlock();
+    return 0;
+}
+
+static int myfb_resume(struct platform_device *dev)
+{
+    struct fb_info *info = platform_get_drvdata(dev);
+
+    console_lock();
+    pm_runtime_get_sync(&dev->dev);
+    fb_set_suspend(info, 0);
+    console_unlock();
+    return 0;
+}
+
+static const struct of_device_id fb_of_match[] = {
+        {
+                .compatible = "allwinner,suniv-f1c500s-tcon0",
+        },{}
+};
+MODULE_DEVICE_TABLE(of, fb_of_match);
+
+static struct platform_driver fb_driver = {
+        .probe    = myfb_probe,
+        .remove   = myfb_remove,
+        .suspend  = myfb_suspend,
+        .resume   = myfb_resume,
+        .driver = {
+                .name   = DRIVER_NAME,
+                .owner  = THIS_MODULE,
+                .of_match_table = of_match_ptr(fb_of_match),
+        },
+};
+
+static void suniv_ioremap(void)
+{
+    iomm.dma = (uint8_t*)ioremap(SUNIV_DMA_BASE, 4096);
+    iomm.ccm = (uint8_t*)ioremap(SUNIV_CCM_BASE, 4096);
+    iomm.lcdc = (uint8_t*)ioremap(SUNIV_LCDC_BASE, 4096);
+    iomm.debe = (uint8_t*)ioremap(SUNIV_DEBE_BASE, 4096);
+    iomm.defe = (uint8_t*)ioremap(SUNIV_DEFE_BASE, 4096);
+    iomm.intc = (uint8_t*)ioremap(SUNIV_INTC_BASE, 4096);
+    iomm.tve = (uint8_t*)ioremap(SUNIV_TVE_BASE, 1024);
+}
+
+static void suniv_iounmap(void)
+{
+    iounmap(iomm.dma);
+    iounmap(iomm.ccm);
+    iounmap(iomm.lcdc);
+    iounmap(iomm.debe);
+    iounmap(iomm.defe);
+    iounmap(iomm.tve);
+    iounmap(iomm.intc);
+}
+
+static int myopen(struct inode *inode, struct file *file)
+{
+    return 0;
+}
+
+static int myclose(struct inode *inode, struct file *file)
+{
+    return 0;
+}
+
+static long myioctl(struct file *filp, unsigned int cmd, unsigned long arg)
+{
+    int32_t w, bpp;
+    unsigned long tmp;
+
+    switch(cmd){
+        case MIYOO_FB0_PUT_OSD:
+            break;
+        case MIYOO_FB0_SET_MODE:
+            break;
+    }
+    return 0;
+}
+
+static const struct file_operations myfops = {
+        .owner = THIS_MODULE,
+        .open = myopen,
+        .release = myclose,
+        .unlocked_ioctl = myioctl,
+};
+
+static int __init fb_init(void)
+{
+    suniv_ioremap();
+    alloc_chrdev_region(&major, 0, 1, "miyoo_tvout_fb0");
+    myclass = class_create(THIS_MODULE, "miyoo_tvout_fb0");
+    device_create(myclass, NULL, major, NULL, "miyoo_tvout_fb0");
+    cdev_init(&mycdev, &myfops);
+    cdev_add(&mycdev, major, 1);
+    return platform_driver_register(&fb_driver);
+}
+
+static void __exit fb_cleanup(void)
+{
+    suniv_iounmap();
+    device_destroy(myclass, major);
+    cdev_del(&mycdev);
+    class_destroy(myclass);
+    unregister_chrdev_region(major, 1);
+    platform_driver_unregister(&fb_driver);
+}
+
+module_init(fb_init);
+module_exit(fb_cleanup);
+
+MODULE_DESCRIPTION("Framebuffer driver for TVE");
+MODULE_AUTHOR("Tiopex <tiopxyz@gmail.com>");
+MODULE_LICENSE("GPL");
diff --git a/drivers/video/fbdev/r61520fb.c b/drivers/video/fbdev/r61520fb.c
new file mode 100644
index 00000000..093b4d8b
--- /dev/null
+++ b/drivers/video/fbdev/r61520fb.c
@@ -0,0 +1,1797 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option)any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+#include <linux/cdev.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/fb.h>
+#include <linux/dma-mapping.h>
+#include <linux/device.h>
+#include <linux/platform_device.h>
+#include <linux/uaccess.h>
+#include <linux/pm_runtime.h>
+#include <linux/interrupt.h>
+#include <linux/wait.h>
+#include <linux/clk.h>
+#include <linux/cpufreq.h>
+#include <linux/console.h>
+#include <linux/spinlock.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+#include <linux/lcm.h>
+#include <linux/clk-provider.h>
+#include <video/of_display_timing.h>
+#include <linux/gpio.h>
+#include <linux/omapfb.h>
+#include <linux/compiler.h>
+#include <linux/workqueue.h>
+#include <asm/io.h>
+#include <asm/gpio.h>
+#include <asm/arch-suniv/cpu.h>
+#include <asm/arch-suniv/dma.h>
+#include <asm/arch-suniv/gpio.h>
+#include <asm/arch-suniv/intc.h>
+#include <asm/arch-suniv/lcdc.h>
+#include <asm/arch-suniv/debe.h>
+#include <asm/arch-suniv/clock.h>
+#include <asm/arch-suniv/common.h>
+
+//#define DEBUG
+#define MIYOO_FB0_PUT_OSD     _IOWR(0x100, 0, unsigned long)
+#define MIYOO_FB0_SET_MODE    _IOWR(0x101, 0, unsigned long)
+#define MIYOO_FB0_GET_VER     _IOWR(0x102, 0, unsigned long)
+#define MIYOO_FB0_SET_FLIP    _IOWR(0x103, 0, unsigned long)
+#define MIYOO_FB0_SET_FPBP    _IOWR(0x104, 0, unsigned long)
+#define MIYOO_FB0_GET_FPBP    _IOWR(0x105, 0, unsigned long)
+
+#define NO_POCKET_GO             1
+#define MIYOO3                1
+
+#define LRAM_NUM              1
+#define PALETTE_SIZE          256
+#define DRIVER_NAME           "miyoofb"
+#define SLCD_RESET		        ((32 * 4) + 11) // PE11
+#define SLCD_TE		  		      ((32 * 4) + 10) // PE10
+
+static bool flip=false;
+module_param(flip,bool,0660);
+
+static bool debug=false;
+module_param(debug,bool,0660);
+
+static bool lowcurrent=false;
+module_param(lowcurrent,bool,0660);
+
+static uint32_t version=0;
+module_param(version,uint,0660);
+
+static bool invert=false;
+module_param(invert,bool,0660);
+
+// Which LCD controller are we driving? E.g. R61520, R61526, R61581, etc. 
+// Should be a number 1-4, but I'm not yet sure which numbers correspond to which panels
+// 1 = R61520 - R61520 doesn't support the 0x04 read_DDB_start / Read Display ID Information command.
+// 2 = ST7789S
+// 3 = R61505W
+// 4 = ?
+// Will be automatically detected if left unset (which usually works)
+
+struct myfb_par {
+  struct device *dev;
+  struct platform_device *pdev;
+
+  resource_size_t p_palette_base;
+  unsigned short *v_palette_base;
+ 
+  dma_addr_t vram_phys;
+  uint32_t vram_size;
+  void *vram_virt;
+  int yoffset;
+  
+  dma_addr_t lram_phys[LRAM_NUM];
+  uint32_t lram_size;
+  void *lram_virt[LRAM_NUM];
+  void *dma_addr;
+ 
+  int bpp;
+  int lcdc_irq;
+  int gpio_irq;
+  volatile int have_te;
+  u32 pseudo_palette[16];
+  struct fb_videomode mode;
+};
+
+struct suniv_iomm {
+  uint8_t *dma;
+  uint8_t *ccm;
+  uint8_t *gpio;
+  uint8_t *lcdc;
+  uint8_t *debe;
+  uint8_t *intc;
+};
+static struct suniv_iomm iomm={0};
+
+static int major = -1;
+static struct cdev mycdev;
+static struct class *myclass = NULL;
+static uint32_t miyoo_ver=0;
+static int flip_mode=0;
+static int new_bp=8;
+static int new_fp=8;
+static int def_bp=8;
+static int def_fp=8;
+uint32_t ret;
+int x, y;
+uint16_t *p;
+uint32_t ddr_clock;
+
+struct myfb_par *mypar;
+static struct fb_var_screeninfo myfb_var;
+static struct fb_fix_screeninfo myfb_fix = {
+  .id = DRIVER_NAME,
+  .type = FB_TYPE_PACKED_PIXELS,
+  .type_aux = 0,
+  .visual = FB_VISUAL_TRUECOLOR,
+  .xpanstep = 0,
+  .ypanstep = 1,
+  .ywrapstep = 0,
+  .accel = FB_ACCEL_NONE
+};
+
+static void suniv_gpio_init(void)
+{
+  uint32_t ret;
+
+  ret = readl(iomm.gpio + PD_CFG0);
+  ret&= 0x0000000f;
+  ret|= 0x22222220;
+  writel(ret, iomm.gpio + PD_CFG0);
+    ret = readl(iomm.gpio + PD_CFG1);
+    ret&= 0x000000f0;
+    ret|= 0x22222212;
+    writel(ret, iomm.gpio + PD_CFG1);
+  writel(0x00222222, iomm.gpio + PD_CFG2);
+  writel(0x00040001, iomm.gpio + PD_PUL0);
+  writel(0x00000000, iomm.gpio + PD_PUL1);
+  //writel(0xffffffff, iomm.gpio + PD_DRV0);
+  writel(0xffffffff, iomm.gpio + PD_DRV1);
+
+  if (lowcurrent){
+    writel(0x00000000, iomm.gpio + PD_DRV0);
+  }
+
+  ret = readl(iomm.gpio + PE_PUL0);
+  ret&= 0xff0fffff;
+  ret|= 0x00500000;
+  writel(ret, iomm.gpio + PE_PUL0);
+  
+  ret = readl(iomm.gpio + PE_CFG1);
+  ret&= 0xffff0fff;
+  ret|= 0x00001000;
+  writel(ret, iomm.gpio + PE_CFG1);
+}
+
+static uint32_t lcdc_wait_busy(void)
+{
+	uint32_t cnt=0;
+	
+  suniv_setbits(iomm.lcdc + TCON0_CPU_IF_REG, (1 << 0));
+	ndelay(10);
+	while(1){
+		if(readl(iomm.lcdc + TCON0_CPU_IF_REG) & 0x00c00000){
+			if(cnt > 200){
+				return -1;
+			}
+		  else{
+		  	cnt+= 1;
+			}
+		}
+		break;
+	}
+	return 0;
+}
+
+static uint32_t extend_16b_to_24b(uint32_t value)
+{
+	return ((value & 0xfc00) << 8) | ((value & 0x0300) << 6) | ((value & 0x00e0) << 5) | ((value & 0x001f) << 3);
+}
+
+static uint32_t extend_24b_to_16b(uint32_t value)
+{
+	return ((value & 0xfc0000) >> 8) | ((value & 0xc000) >> 6) | ((value & 0x1c00) >> 5) | ((value & 0x00f8) >> 3);
+}
+
+static void lcdc_wr(uint8_t is_data, uint32_t data)
+{
+	while(lcdc_wait_busy());
+	if(is_data){
+		suniv_setbits(iomm.lcdc + TCON0_CPU_IF_REG, (1 << 25)); // ca=1
+	}
+	else{
+		suniv_clrbits(iomm.lcdc + TCON0_CPU_IF_REG, (1 << 25)); // ca=0	
+	}
+	while(lcdc_wait_busy());
+	writel(extend_16b_to_24b(data), iomm.lcdc + TCON0_CPU_WR_REG);
+}
+
+
+static void lcdc_wr_cmd(uint32_t cmd)
+{
+	lcdc_wr(0, cmd);
+}
+
+static uint32_t lcdc_rd_dat(void)
+{
+	while(lcdc_wait_busy());
+	suniv_setbits(iomm.lcdc + TCON0_CPU_IF_REG, (1 << 25)); // ca=1
+	while(lcdc_wait_busy());
+	return extend_24b_to_16b(readl(iomm.lcdc + TCON0_CPU_RD_REG));
+}
+
+static void gpio_wr(uint32_t is_data, uint32_t val)
+{
+  uint32_t ret;
+
+  ret = (val & 0x00ff) << 1;
+  ret|= (val & 0xff00) << 2;
+  ret|= is_data ? 0x80000 : 0;
+  ret|= 0x100000; 
+  writel(ret, iomm.gpio + PD_DATA);
+  ret|= 0x40000;
+  writel(ret, iomm.gpio + PD_DATA);
+}
+
+static void ser_wr(uint8_t is_data, uint8_t data)
+{
+  int bit;
+ 
+  suniv_clrbits(iomm.gpio + PC_DATA, 1 << 0); // csx
+	if(is_data){
+    suniv_setbits(iomm.gpio + PE_DATA, 1 << 0); // wrx
+	}
+	else{
+    suniv_clrbits(iomm.gpio + PE_DATA, 1 << 0); // wrx
+	}
+  for(bit=7; bit>=0; bit--){
+  	suniv_clrbits(iomm.gpio + PC_DATA, 1 << 3); // dcx
+		if((data >> bit) & 1){
+			suniv_setbits(iomm.gpio + PE_DATA, 1 << 1); // sda
+		}
+		else{
+			suniv_clrbits(iomm.gpio + PE_DATA, 1 << 1); // sda
+		}
+    udelay(10);
+  	suniv_setbits(iomm.gpio + PC_DATA, 1 << 3); // dcx
+    udelay(10);
+  }
+}
+
+static void ser_wr_cmd(uint8_t data)
+{
+  ser_wr(0, data);
+}
+ 
+static void ser_wr_dat(uint8_t data)
+{
+  ser_wr(1, data);
+}
+
+static uint32_t ser_rd_dat(void)
+{
+  int bit;
+	uint32_t ret=0;
+ 
+  suniv_clrbits(iomm.gpio + PC_DATA, 1 << 0); // csx
+	suniv_clrbits(iomm.gpio + PE_CFG0, 1 << 4); // sda
+  suniv_setbits(iomm.gpio + PE_DATA, 1 << 0); // wrx
+  for(bit=31; bit>=0; bit--){
+    udelay(10);
+  	suniv_clrbits(iomm.gpio + PC_DATA, 1 << 3); // dcx
+		ret<<= 1;
+		if(readl(iomm.gpio + PE_DATA) & 2){ // sda
+			ret|= 1;
+		}
+    udelay(10);
+  	suniv_setbits(iomm.gpio + PC_DATA, 1 << 3); // dcx
+  }
+	suniv_setbits(iomm.gpio + PE_CFG0, 1 << 4); // sda
+	return ret;
+}
+
+static void ser_init(void)
+{
+  suniv_setbits(iomm.gpio + PC_CFG0, 1 << 0); // csx
+  suniv_clrbits(iomm.gpio + PC_CFG0, 1 << 1);
+  suniv_clrbits(iomm.gpio + PC_CFG0, 1 << 2);
+  suniv_setbits(iomm.gpio + PC_DATA, 1 << 0);
+
+  suniv_setbits(iomm.gpio + PC_CFG0, 1 << 12); // dcx
+  suniv_clrbits(iomm.gpio + PC_CFG0, 1 << 13);
+  suniv_clrbits(iomm.gpio + PC_CFG0, 1 << 14);
+  suniv_setbits(iomm.gpio + PC_DATA, 1 << 3);
+
+  suniv_setbits(iomm.gpio + PE_CFG0, 1 << 0); // wrx
+  suniv_clrbits(iomm.gpio + PE_CFG0, 1 << 1);
+  suniv_clrbits(iomm.gpio + PE_CFG0, 1 << 2);
+  suniv_setbits(iomm.gpio + PE_DATA, 1 << 0);
+  suniv_setbits(iomm.gpio + PE_PUL0, 1 << 0);
+  suniv_clrbits(iomm.gpio + PE_PUL0, 1 << 1);
+
+  suniv_setbits(iomm.gpio + PE_CFG0, 1 << 4); // sda
+  suniv_clrbits(iomm.gpio + PE_CFG0, 1 << 5);
+  suniv_clrbits(iomm.gpio + PE_CFG0, 1 << 6);
+  suniv_setbits(iomm.gpio + PE_DATA, 1 << 1);
+  suniv_setbits(iomm.gpio + PE_PUL0, 1 << 2);
+  suniv_clrbits(iomm.gpio + PE_PUL0, 1 << 3);
+}
+
+static void ser_deinit(void)
+{
+  suniv_clrbits(iomm.gpio + PE_CFG0, 1 << 0);
+  suniv_clrbits(iomm.gpio + PE_CFG0, 1 << 1);
+  suniv_clrbits(iomm.gpio + PE_CFG0, 1 << 2);
+
+  suniv_clrbits(iomm.gpio + PE_CFG0, 1 << 4);
+  suniv_clrbits(iomm.gpio + PE_CFG0, 1 << 5);
+  suniv_clrbits(iomm.gpio + PE_CFG0, 1 << 6);
+}
+
+static void gpio_wr_cmd(uint32_t val)
+{
+  gpio_wr(0, val);
+}
+
+static void gpio_wr_dat(uint32_t val)
+{
+  gpio_wr(1, val);
+}
+
+static void refresh_lcd(struct myfb_par *par)
+{
+  if((miyoo_ver <= 2) || (miyoo_ver == 4)){
+    lcdc_wr_cmd(0x2c);
+  }
+  if(par->yoffset == 0){
+	  suniv_setbits(iomm.debe + DEBE_MODE_CTRL_REG, (1 << 8));
+	  suniv_clrbits(iomm.debe + DEBE_MODE_CTRL_REG, (1 << 9));
+  }
+  else{
+	  suniv_clrbits(iomm.debe + DEBE_MODE_CTRL_REG, (1 << 8));
+	  suniv_setbits(iomm.debe + DEBE_MODE_CTRL_REG, (1 << 9));
+  }
+	suniv_setbits(iomm.debe + DEBE_REGBUFF_CTRL_REG, (1 << 0));
+}
+
+static irqreturn_t gpio_irq_handler(int irq, void *arg)
+{
+  static uint32_t cnt=0, report=0;
+  struct myfb_par *par = arg;
+
+  suniv_setbits(iomm.gpio + PE_INT_STA, (1 << 10));
+  if(cnt > 10){
+    par->have_te = 1;
+    if(flip_mode == 0){
+      if(report++ >= 60){
+        report = 0;
+        printk("%s\n", __func__);
+      }
+      refresh_lcd(par);
+    }
+  }
+  else{
+    cnt+= 1;
+  }
+  return IRQ_HANDLED;
+}
+
+static irqreturn_t lcdc_irq_handler(int irq, void *arg)
+{
+  static uint32_t report=0;
+  struct myfb_par *par = arg;
+
+  suniv_clrbits(iomm.lcdc + TCON_INT_REG0, (1 << 15));
+  if(par->have_te == 0){
+    if(flip_mode == 0){
+      if(report++ >= 60){
+        report = 0;
+        //printk("%s\n", __func__);
+      }
+      refresh_lcd(par);
+    }
+  }
+  return IRQ_HANDLED;
+}
+
+
+static void readReg(uint32_t reg, uint8_t n, const char *msg) //this is for debugging registers on TFT panels
+{
+  uint32_t res;
+  lcdc_wr_cmd(reg);
+  res = lcdc_rd_dat();
+  printk("REG 0x%02x:     ", reg);
+  for(x=0; x<n; x++){
+    res = lcdc_rd_dat();
+    printk(KERN_CONT "%02x ",res);
+  }
+  printk(KERN_CONT "%s ",msg);
+}
+
+
+
+
+
+static int panel_init(void)
+{
+  uint16_t x, ver[4]={0};
+  
+  suniv_setbits(iomm.lcdc + PE_DATA, (11 << 0));
+  mdelay(50);
+  suniv_clrbits(iomm.lcdc + PE_DATA, (11 << 0));
+  mdelay(150);
+  suniv_setbits(iomm.lcdc + PE_DATA, (11 << 0));
+  mdelay(150);
+
+
+  
+if(debug){
+    printk(" ");
+    printk("TFT IDENTIFICATION 8BITS:");
+    printk(" ");
+    readReg(0x00, 4, "ID: ILI9320, ILI9325, ILI9335, ...");
+    readReg(0x04, 4, "Manufacturer ID");
+    readReg(0x09, 5, "Status Register");
+    readReg(0x0A, 2, "Get Power Mode");
+    readReg(0x0C, 2, "Get Pixel Format");
+    readReg(0x30, 5, "PTLAR");
+    readReg(0x33, 7, "VSCRLDEF");
+    readReg(0x61, 2, "RDID1 HX8347-G");
+    readReg(0x62, 2, "RDID2 HX8347-G");
+    readReg(0x63, 2, "RDID3 HX8347-G");
+    readReg(0x64, 2, "RDID1 HX8347-A");
+    readReg(0x65, 2, "RDID2 HX8347-A");
+    readReg(0x66, 2, "RDID3 HX8347-A");
+    readReg(0x67, 2, "RDID Himax HX8347-A");
+    readReg(0x70, 2, "Panel Himax HX8347-A");
+    readReg(0xA1, 5, "RD_DDB SSD1963");
+    readReg(0xB0, 2, "RGB Interface Signal Control");
+    readReg(0xB3, 5, "Frame Memory");
+    readReg(0xB4, 2, "Frame Mode");
+    readReg(0xB6, 5, "Display Control");
+    readReg(0xB7, 2, "Entry Mode Set");
+    readReg(0xBF, 6, "ILI9481, HX8357-B");
+    readReg(0xC0, 9, "Panel Control");
+    readReg(0xC1, 4, "Display Timing");
+    readReg(0xC5, 2, "Frame Rate");
+    readReg(0xC8, 13, "GAMMA");
+    readReg(0xCC, 2, "Panel Control");
+    readReg(0xD0, 4, "Power Control");
+    readReg(0xD1, 4, "VCOM Control");
+    readReg(0xD2, 3, "Power Normal");
+    readReg(0xD3, 4, "ILI9341, ILI9488");
+    readReg(0xD4, 4, "Novatek");
+    readReg(0xDA, 2, "RDID1");
+    readReg(0xDB, 2, "RDID2");
+    readReg(0xDC, 2, "RDID3");
+    readReg(0xE0, 16, "GAMMA-P");
+    readReg(0xE1, 16, "GAMMA-N");
+    readReg(0xEF, 6, "ILI9327");
+    readReg(0xF2, 12, "Adjust Control 2");
+    readReg(0xF6, 4, "Interface Control");
+  }
+
+  suniv_setbits(iomm.lcdc + PE_DATA, (11 << 0));
+  mdelay(50);
+  suniv_clrbits(iomm.lcdc + PE_DATA, (11 << 0));
+  mdelay(150);
+  suniv_setbits(iomm.lcdc + PE_DATA, (11 << 0));
+  mdelay(150);
+
+  lcdc_wr_cmd(0x04);
+  for(x=0; x<4; x++){
+    ver[x] = lcdc_rd_dat();
+  }
+  if(ver[2]){
+    miyoo_ver = 2;
+  }
+  else{
+    lcdc_wr_cmd(0x00);
+    for(x=0; x<4; x++){
+      ver[x] = lcdc_rd_dat();
+    }
+    miyoo_ver = 3;
+    if(ver[2] == 0){
+      miyoo_ver = 1;
+      ser_init();
+      ser_wr_cmd(0x04);
+      ret = ser_rd_dat();
+      if(ret == 0x42c2a97f){
+        miyoo_ver = 4;
+      }
+      ser_deinit();
+    }
+  }
+
+  if (version && version != miyoo_ver) {
+    printk("Warning: LCD controller detected as version %d, but being overridden by module_param as version %d (detection 2 of 2)", miyoo_ver, version);
+    miyoo_ver = version;
+  }
+
+  ret = readl(iomm.gpio + PD_CFG0);
+  ret&= 0x0000000f;
+  ret|= 0x11111110;
+  writel(ret, iomm.gpio + PD_CFG0);
+  writel(0x11111101, iomm.gpio + PD_CFG1);
+  writel(0x00111111, iomm.gpio + PD_CFG2);
+  writel(0xffffffff, iomm.gpio + PD_DATA);
+    mdelay(150);
+  switch(miyoo_ver){
+  case 1: // R61520
+    gpio_wr_cmd(0xb0);
+    gpio_wr_dat(0x00);
+
+    gpio_wr_cmd(0xb1);
+    gpio_wr_dat(0x00);
+
+    gpio_wr_cmd(0xb3);
+    gpio_wr_dat(0x02);
+    gpio_wr_dat(0x00); // every frame
+    gpio_wr_dat(0x00);
+    gpio_wr_dat(0x00);
+
+    gpio_wr_cmd(0xb4);
+    gpio_wr_dat(0x00);
+
+    gpio_wr_cmd(0xc0);
+    gpio_wr_dat(0x07);
+    gpio_wr_dat(0x4f); // nl 320 lines
+    gpio_wr_dat(0x00);
+    gpio_wr_dat(0x00); // 1 line
+    gpio_wr_dat(0x00); // line inversion
+    gpio_wr_dat(0x00); 
+    gpio_wr_dat(0x01);
+    gpio_wr_dat(0x33); // pcdiv 0x33
+
+    gpio_wr_cmd(0xc1);
+    gpio_wr_dat(0x01); // line inversion
+    gpio_wr_dat(0x00); // division 0x00
+    gpio_wr_dat(0x1a); // clock 0x1a
+    if((new_fp == -1) || (new_bp == -1)){
+      def_bp = new_bp = 0x08;
+      def_fp = new_fp = 0x08;
+    }
+    gpio_wr_dat(new_bp); // bp0 0x08
+    gpio_wr_dat(new_fp); // fp0 0x08
+
+    gpio_wr_cmd(0xc3);
+    gpio_wr_dat(0x01); // line inversion
+    gpio_wr_dat(0x00); // division 0x00
+    gpio_wr_dat(0x1a); // clock 0x1a
+    gpio_wr_dat(new_bp); // bp2 0x0a
+    gpio_wr_dat(new_fp); // fp2 0x09
+
+    gpio_wr_cmd(0xc4);
+    gpio_wr_dat(0x11);
+    gpio_wr_dat(0x01);
+    gpio_wr_dat(0x43);
+    gpio_wr_dat(0x01);
+
+    gpio_wr_cmd(0xc8);
+    gpio_wr_dat(0x00);
+    gpio_wr_dat(0x0a);
+    gpio_wr_dat(0x08);
+    gpio_wr_dat(0x8a);
+    gpio_wr_dat(0x08);
+    gpio_wr_dat(0x09);
+    gpio_wr_dat(0x05);
+    gpio_wr_dat(0x10);
+    gpio_wr_dat(0x00);
+    gpio_wr_dat(0x23);
+    gpio_wr_dat(0x10);
+    gpio_wr_dat(0x05);
+    gpio_wr_dat(0x05);
+    gpio_wr_dat(0x60);
+    gpio_wr_dat(0x0a);
+    gpio_wr_dat(0x08);
+    gpio_wr_dat(0x05);
+    gpio_wr_dat(0x00);
+    gpio_wr_dat(0x10);
+    gpio_wr_dat(0x00);
+
+    gpio_wr_cmd(0xc9);
+    gpio_wr_dat(0x00);
+    gpio_wr_dat(0x0a);
+    gpio_wr_dat(0x08);
+    gpio_wr_dat(0x8a);
+    gpio_wr_dat(0x08);
+    gpio_wr_dat(0x09);
+    gpio_wr_dat(0x05);
+    gpio_wr_dat(0x10);
+    gpio_wr_dat(0x00);
+    gpio_wr_dat(0x23);
+    gpio_wr_dat(0x10);
+    gpio_wr_dat(0x05);
+    gpio_wr_dat(0x09);
+    gpio_wr_dat(0x88);
+    gpio_wr_dat(0x0a);
+    gpio_wr_dat(0x08);
+    gpio_wr_dat(0x0a);
+    gpio_wr_dat(0x00);
+    gpio_wr_dat(0x23);
+    gpio_wr_dat(0x00);
+
+    gpio_wr_cmd(0xca);
+    gpio_wr_dat(0x00);
+    gpio_wr_dat(0x0a);
+    gpio_wr_dat(0x08);
+    gpio_wr_dat(0x8a);
+    gpio_wr_dat(0x08);
+    gpio_wr_dat(0x09);
+    gpio_wr_dat(0x05);
+    gpio_wr_dat(0x10);
+    gpio_wr_dat(0x00);
+    gpio_wr_dat(0x23);
+    gpio_wr_dat(0x10);
+    gpio_wr_dat(0x05);
+    gpio_wr_dat(0x09);
+    gpio_wr_dat(0x88);
+    gpio_wr_dat(0x0a);
+    gpio_wr_dat(0x08);
+    gpio_wr_dat(0x0a);
+    gpio_wr_dat(0x00);
+    gpio_wr_dat(0x23);
+    gpio_wr_dat(0x00);
+
+    gpio_wr_cmd(0xd0);
+    gpio_wr_dat(0x07);
+    gpio_wr_dat(0xc6);
+    gpio_wr_dat(0xdc);
+
+    gpio_wr_cmd(0xd1);
+    gpio_wr_dat(0x54);
+    gpio_wr_dat(0x0d);
+    gpio_wr_dat(0x02);
+
+    gpio_wr_cmd(0xd2);
+    gpio_wr_dat(0x63);
+    gpio_wr_dat(0x24);
+
+    gpio_wr_cmd(0xd4);
+    gpio_wr_dat(0x63);
+    gpio_wr_dat(0x24);
+
+    gpio_wr_cmd(0xd8);
+    gpio_wr_dat(0x07);
+    gpio_wr_dat(0x07);
+
+    gpio_wr_cmd(0xe0);
+    gpio_wr_dat(0x00);
+    gpio_wr_dat(0x00);
+
+    gpio_wr_cmd(0x13);
+
+    if (invert) {
+      gpio_wr_cmd(0x21); // enter_invert_mode for colors
+    } else {
+      gpio_wr_cmd(0x20); // exit_invert_mode for colors
+    }
+
+    gpio_wr_cmd(0x35);
+    gpio_wr_dat(0x00); // te mode
+
+    gpio_wr_cmd(0x44);
+    gpio_wr_dat(0x00);
+    gpio_wr_dat(0x30);
+
+    gpio_wr_cmd(0x36);
+    if(flip){
+        gpio_wr_dat(0x38);
+    } else {
+        gpio_wr_dat(0xe0);
+    }
+
+    gpio_wr_cmd(0x3a);
+    gpio_wr_dat(0x55);
+
+    gpio_wr_cmd(0x2a);
+    gpio_wr_dat(0x00);
+    gpio_wr_dat(0x00);
+    gpio_wr_dat(0x01);
+    gpio_wr_dat(0x3f);
+
+    gpio_wr_cmd(0x2b);
+    gpio_wr_dat(0x00);
+    gpio_wr_dat(0x00);
+    gpio_wr_dat(0x00);
+    gpio_wr_dat(0xef);
+    
+    gpio_wr_cmd(0x11);
+    mdelay(150);
+    gpio_wr_cmd(0x29);
+    mdelay(150);
+    gpio_wr_cmd(0x2c);
+    break;
+  case 2: // ST7789S
+    gpio_wr_cmd(0x11);
+    mdelay(250);
+                  
+    gpio_wr_cmd(0x36);
+    if(flip){
+    	gpio_wr_dat(0xB0); //screen direction //0x70 for 3.5, 0xB0 for pg
+    } else {
+    	gpio_wr_dat(0x70); //screen direction //0x70 for 3.5, 0xB0 for pg
+    }
+                          
+    gpio_wr_cmd(0x3a);
+    gpio_wr_dat(0x05);
+      
+    gpio_wr_cmd(0x2a);
+    gpio_wr_dat(0x00);
+    gpio_wr_dat(0x00);
+    gpio_wr_dat(0x01);
+    gpio_wr_dat(0x3f);
+
+    gpio_wr_cmd(0x2b);
+    gpio_wr_dat(0x00);
+    gpio_wr_dat(0x00);
+    gpio_wr_dat(0x00);
+    gpio_wr_dat(0xef);
+        
+    // ST7789S Frame rate setting
+    gpio_wr_cmd(0xb2);
+    if((new_fp == -1) || (new_bp == -1)){
+      def_bp = new_bp = 9;
+      def_fp = new_fp = 10;
+    }
+    // BP:10 and FP:4 or BP:13 FP:2 
+    gpio_wr_dat(new_bp); // bp 0x0a
+    gpio_wr_dat(new_fp); // fp 0x0b
+    gpio_wr_dat(0x00);        			
+    gpio_wr_dat(0x33);
+    gpio_wr_dat(0x33);
+
+    // Gate Control
+    gpio_wr_cmd(0xb7);
+    gpio_wr_dat(0x35);
+
+    // ?
+    gpio_wr_cmd(0xb8);
+    gpio_wr_dat(0x2f);
+    gpio_wr_dat(0x2b);
+    gpio_wr_dat(0x2f);
+
+    // ST7789S Power setting
+    gpio_wr_cmd(0xbb);
+    gpio_wr_dat(0x15);
+          
+    gpio_wr_cmd(0xc0);
+    gpio_wr_dat(0x3C);
+        
+    gpio_wr_cmd(0xc2);
+    gpio_wr_dat(0x01);							
+
+    gpio_wr_cmd(0xc3);
+    gpio_wr_dat(0x13); // or 0x0b?
+
+    if (invert) {
+      gpio_wr_cmd(0x21); // Display Inversion On (INVON for colors)
+    } else {
+      gpio_wr_cmd(0x20); //  Display Inversion Off (INVOFF for colors)
+    }
+
+    gpio_wr_cmd(0xc4);
+    gpio_wr_dat(0x20);
+
+    gpio_wr_cmd(0xc6);
+    gpio_wr_dat(0x04); // 0x04, 0x1f
+
+    gpio_wr_cmd(0xd0);
+    gpio_wr_dat(0xa4);
+    gpio_wr_dat(0xa1);
+        
+    gpio_wr_cmd(0xe8);
+    gpio_wr_dat(0x03);
+
+    gpio_wr_cmd(0xe9);
+    gpio_wr_dat(0x0d);
+    gpio_wr_dat(0x12);
+    gpio_wr_dat(0x00);
+
+    // ST7789S gamma setting
+    gpio_wr_cmd(0xe0);
+    gpio_wr_dat(0x70);
+    gpio_wr_dat(0x00);
+    gpio_wr_dat(0x06);
+    gpio_wr_dat(0x09);
+    gpio_wr_dat(0x0b);
+    gpio_wr_dat(0x2a);
+    gpio_wr_dat(0x3c);
+    gpio_wr_dat(0x33);
+    gpio_wr_dat(0x4b);
+    gpio_wr_dat(0x08);
+    gpio_wr_dat(0x16);
+    gpio_wr_dat(0x14);
+    gpio_wr_dat(0x2a);
+    gpio_wr_dat(0x23);
+        
+    gpio_wr_cmd(0xe1);
+    gpio_wr_dat(0xd0);
+    gpio_wr_dat(0x00);
+    gpio_wr_dat(0x06);
+    gpio_wr_dat(0x09);
+    gpio_wr_dat(0x0b);
+    gpio_wr_dat(0x29);
+    gpio_wr_dat(0x36);
+    gpio_wr_dat(0x54);
+    gpio_wr_dat(0x4b);
+    gpio_wr_dat(0x0d);
+    gpio_wr_dat(0x16);
+    gpio_wr_dat(0x14);
+    gpio_wr_dat(0x28);
+    gpio_wr_dat(0x22);
+
+    mdelay(50);
+    gpio_wr_cmd(0x29);
+    mdelay(50);
+    gpio_wr_cmd(0x2c);
+    mdelay(100);
+    break;
+  case 3:
+    gpio_wr_cmd(0xa4);
+    gpio_wr_dat(0x0001);
+    mdelay(50);
+    gpio_wr_cmd(0x9c);
+    gpio_wr_dat(0x0033); // pcdiv
+    gpio_wr_cmd(0x60);
+    gpio_wr_dat(0x2700); // 320 lines
+    gpio_wr_cmd(0x08);
+    if((new_fp == -1) || (new_bp == -1)){
+      def_bp = new_bp = 0x08;
+      def_fp = new_fp = 0x08;
+    }
+    gpio_wr_dat((new_fp << 8)| new_bp); // fp, bp
+    gpio_wr_cmd(0x30);
+    gpio_wr_dat(0x0103); // gamma
+    gpio_wr_cmd(0x31);
+    gpio_wr_dat(0x1811);
+    gpio_wr_cmd(0x32);
+    gpio_wr_dat(0x0501);
+    gpio_wr_cmd(0x33);
+    gpio_wr_dat(0x0510);
+    gpio_wr_cmd(0x34);
+    gpio_wr_dat(0x2010);
+    gpio_wr_cmd(0x35);
+    gpio_wr_dat(0x1005);
+    gpio_wr_cmd(0x36);
+    gpio_wr_dat(0x1105);
+    gpio_wr_cmd(0x37);
+    gpio_wr_dat(0x1109);
+    gpio_wr_cmd(0x38);
+    gpio_wr_dat(0x0301);
+    gpio_wr_cmd(0x39);
+    gpio_wr_dat(0x1020);
+    gpio_wr_cmd(0x90);
+    gpio_wr_dat(0x001f); // 80hz, 0x0016, 0x1f
+    gpio_wr_cmd(0x10);
+    gpio_wr_dat(0x0530); // bt, ap
+    gpio_wr_cmd(0x11);
+    gpio_wr_dat(0x0247); // dc1, dc0, vc
+    gpio_wr_cmd(0x12);
+    gpio_wr_dat(0x01bc);
+    gpio_wr_cmd(0x13);
+    gpio_wr_dat(0x1000);
+    mdelay(50);
+    gpio_wr_cmd(0x01);
+    gpio_wr_dat(0x0100);
+    gpio_wr_cmd(0x02);
+    gpio_wr_dat(0x0200);
+    gpio_wr_cmd(0x03);
+    gpio_wr_dat(0x1028); // 0x1028
+    gpio_wr_cmd(0x09);
+    gpio_wr_dat(0x0001);
+    gpio_wr_cmd(0x0a);
+    gpio_wr_dat(0x0008); // one frame
+    gpio_wr_cmd(0x0c);
+    gpio_wr_dat(0x0000);
+    gpio_wr_cmd(0x0d);
+    gpio_wr_dat(0xd000); // frame mark 0xd000
+    gpio_wr_cmd(0x0e);
+    gpio_wr_dat(0x0030);
+    gpio_wr_cmd(0x0f);
+    gpio_wr_dat(0x0000);
+    gpio_wr_cmd(0x20);
+    gpio_wr_dat(0x0000); // H Start
+    gpio_wr_cmd(0x21);
+    gpio_wr_dat(0x0000); // V Start
+    gpio_wr_cmd(0x29);
+    gpio_wr_dat(0x002e);
+    gpio_wr_cmd(0x50);
+    gpio_wr_dat(0x0000);
+    gpio_wr_cmd(0x51);
+    gpio_wr_dat(0xd0ef);
+    gpio_wr_cmd(0x52);
+    gpio_wr_dat(0x0000);
+    gpio_wr_cmd(0x53);
+    gpio_wr_dat(0x013f);
+    gpio_wr_cmd(0x61);
+    gpio_wr_dat(0x0000);
+    gpio_wr_cmd(0x6a);
+    gpio_wr_dat(0x0000);
+    gpio_wr_cmd(0x80);
+    gpio_wr_dat(0x0000);
+    gpio_wr_cmd(0x81);
+    gpio_wr_dat(0x0000);
+    gpio_wr_cmd(0x82);
+    gpio_wr_dat(0x005f);
+    gpio_wr_cmd(0x93);
+    gpio_wr_dat(0x0507);
+    gpio_wr_cmd(0x07);
+    gpio_wr_dat(0x0100);
+    mdelay(150);
+    gpio_wr_cmd(0x22);
+    mdelay(150);
+    break;
+  case 4:
+    ser_init();
+  #if 0
+		ser_wr_cmd(0x36);
+		ser_wr_dat(0x80);
+	 
+		ser_wr_cmd(0xb2); // porch
+		ser_wr_dat(0x08); // bpa
+		ser_wr_dat(0x08); // fpa
+		ser_wr_dat(0x00); // psen
+		ser_wr_dat(0x88); // bpb
+		ser_wr_dat(0x88); // bpc
+	 
+		ser_wr_cmd(0xb7);
+		ser_wr_dat(0x35);
+	 
+		ser_wr_cmd(0xb8);
+		ser_wr_dat(0x2f);
+		ser_wr_dat(0x2b);
+		ser_wr_dat(0x2f);
+	 
+		ser_wr_cmd(0xbb);
+		ser_wr_dat(0x24);
+	 
+		ser_wr_cmd(0xc0);
+		ser_wr_dat(0x2C);
+	 
+		ser_wr_cmd(0xc3);
+		ser_wr_dat(0x10);
+	 
+		ser_wr_cmd(0xc4);
+		ser_wr_dat(0x20);
+	 
+		ser_wr_cmd(0xc6);
+		ser_wr_dat(0x11);
+	 
+		ser_wr_cmd(0xd0);
+		ser_wr_dat(0xa4);
+		ser_wr_dat(0xa1);
+	 
+		ser_wr_cmd(0xe8);
+		ser_wr_dat(0x03);
+	 
+		ser_wr_cmd(0xe9);
+		ser_wr_dat(0x0d);
+		ser_wr_dat(0x12);
+		ser_wr_dat(0x00);
+	 
+		ser_wr_cmd(0xe0);
+		ser_wr_dat(0xd0);
+		ser_wr_dat(0x00);
+		ser_wr_dat(0x00);
+		ser_wr_dat(0x08);
+		ser_wr_dat(0x11);
+		ser_wr_dat(0x1a);
+		ser_wr_dat(0x2b);
+		ser_wr_dat(0x33);
+		ser_wr_dat(0x42);
+		ser_wr_dat(0x26);
+		ser_wr_dat(0x12);
+		ser_wr_dat(0x21);
+		ser_wr_dat(0x2f);
+		ser_wr_dat(0x11);
+	 
+		ser_wr_cmd(0xe1);
+		ser_wr_dat(0xd0);
+		ser_wr_dat(0x02);
+		ser_wr_dat(0x09);
+		ser_wr_dat(0x0d);
+		ser_wr_dat(0x0d);
+		ser_wr_dat(0x27);
+		ser_wr_dat(0x2b);
+		ser_wr_dat(0x33);
+		ser_wr_dat(0x42);
+		ser_wr_dat(0x17);
+		ser_wr_dat(0x12);
+		ser_wr_dat(0x11);
+		ser_wr_dat(0x2f);
+		ser_wr_dat(0x31);
+	 
+		ser_wr_cmd(0x21);
+	 
+		ser_wr_cmd(0xb0);
+		ser_wr_dat(0x11); // rgb interface
+		ser_wr_dat(0x00); 
+		ser_wr_dat(0x00); 
+	 
+		ser_wr_cmd(0xb1);
+		ser_wr_dat(0x40); // de mode
+		ser_wr_dat(0x00); 
+		ser_wr_dat(0x00); // bpb, hpb 
+	 
+		ser_wr_cmd(0x3a); 
+		ser_wr_dat(0x55);
+	 
+		ser_wr_cmd(0x2a);
+		ser_wr_dat(0x00);
+		ser_wr_dat(0x00);
+		ser_wr_dat(0x00);
+		ser_wr_dat(0xef);
+	 
+		ser_wr_cmd(0x2b);
+		ser_wr_dat(0x00);
+		ser_wr_dat(0x00);
+		ser_wr_dat(0x01);
+		ser_wr_dat(0x3f);
+	 
+		ser_wr_cmd(0x11); 
+		mdelay(120); 
+		ser_wr_cmd(0x29);
+		mdelay(120);
+		ser_wr_cmd(0x2c);
+		mdelay(120);
+  #else
+    ser_wr_cmd(0x36);
+    ser_wr_dat(0x00);
+
+    ser_wr_cmd(0xb2); // porch
+    ser_wr_dat(0x08); // back porch
+    ser_wr_dat(0x08); // front porch
+    ser_wr_dat(0x00); // psen
+    ser_wr_dat(0x88);
+    ser_wr_dat(0x88);
+   
+    ser_wr_cmd(0xb7);
+    ser_wr_dat(0x35);
+    
+    // Power settings
+    ser_wr_cmd(0xbb);
+    ser_wr_dat(0x15);
+   
+    ser_wr_cmd(0xc0);
+    ser_wr_dat(0x6e);
+
+    ser_wr_cmd(0xc2);
+    ser_wr_dat(0x01);
+
+    ser_wr_cmd(0xc3);
+    ser_wr_dat(0x0b);
+   
+    ser_wr_cmd(0xc4);
+    ser_wr_dat(0x20);
+   
+    ser_wr_cmd(0xc6);
+    ser_wr_dat(0x0f);
+   
+    ser_wr_cmd(0xca);
+    ser_wr_dat(0x0f);
+
+    ser_wr_cmd(0xc8);
+    ser_wr_dat(0x08);
+
+    ser_wr_cmd(0x55);
+    ser_wr_dat(0x90);
+
+    ser_wr_cmd(0xd0);
+    ser_wr_dat(0xa4);
+    ser_wr_dat(0xa1);
+    
+    ser_wr_cmd(0xe0);
+    ser_wr_dat(0xd0);
+    ser_wr_dat(0x00);
+    ser_wr_dat(0x00);
+    ser_wr_dat(0x08);
+    ser_wr_dat(0x11);
+    ser_wr_dat(0x1a);
+    ser_wr_dat(0x2b);
+    ser_wr_dat(0x33);
+    ser_wr_dat(0x42);
+    ser_wr_dat(0x26);
+    ser_wr_dat(0x12);
+    ser_wr_dat(0x21);
+    ser_wr_dat(0x2f);
+    ser_wr_dat(0x11);
+   
+    ser_wr_cmd(0xe1);
+    ser_wr_dat(0xd0);
+    ser_wr_dat(0x02);
+    ser_wr_dat(0x09);
+    ser_wr_dat(0x0d);
+    ser_wr_dat(0x0d);
+    ser_wr_dat(0x27);
+    ser_wr_dat(0x2b);
+    ser_wr_dat(0x33);
+    ser_wr_dat(0x42);
+    ser_wr_dat(0x17);
+    ser_wr_dat(0x12);
+    ser_wr_dat(0x11);
+    ser_wr_dat(0x2f);
+    ser_wr_dat(0x31);
+
+    ser_wr_cmd(0x21);
+   
+    ser_wr_cmd(0xb0);
+    ser_wr_dat(0x11); // rgb interface
+    ser_wr_dat(0x00);
+   
+    ser_wr_cmd(0xb1);
+    ser_wr_dat(0x40); // rgb mode
+    ser_wr_dat(0x08); // vbp 
+    ser_wr_dat(0x08); // hbp
+
+    ser_wr_cmd(0x3a); 
+    ser_wr_dat(0x55); // 18bit=0x66, 16bit=0x55
+
+    ser_wr_cmd(0x2b);
+    ser_wr_dat(0x00);
+    ser_wr_dat(0x00);
+    ser_wr_dat(0x00);
+    ser_wr_dat(0xef);
+   
+    ser_wr_cmd(0x2a);
+    ser_wr_dat(0x00);
+    ser_wr_dat(0x00);
+    ser_wr_dat(0x01);
+    ser_wr_dat(0x3f);
+
+    ser_wr_cmd(0x11); 
+    mdelay(120); 
+    ser_wr_cmd(0x29);
+    mdelay(120);
+    ser_wr_cmd(0x2c); 
+    mdelay(120);
+  #endif
+    ser_deinit();
+    break;
+  }
+
+#if defined(MIYOO3)
+  for(x=0;x<320;x++) gpio_wr_dat(0x00);
+#endif
+  writel(0xffffffff, iomm.gpio + PD_DATA);
+  ret = readl(iomm.gpio + PD_CFG0);
+  ret&= 0x0000000f;
+  ret|= 0x22222220;
+  writel(ret, iomm.gpio + PD_CFG0);
+    ret = readl(iomm.gpio + PD_CFG1);
+    ret&= 0x000000f0;
+    ret|= 0x22222212;
+    writel(ret, iomm.gpio + PD_CFG1);
+  writel(0x00222222, iomm.gpio + PD_CFG2);
+  return miyoo_ver;
+}
+
+static void suniv_enable_irq(struct myfb_par *par)
+{
+  int ret;
+
+  par->have_te = 0;
+  par->lcdc_irq = platform_get_irq(par->pdev, 0);
+  if (par->lcdc_irq < 0) {
+    printk("%s, failed to get irq number for lcdc irq\n", __func__);
+  }
+  else{
+	  ret = request_irq(par->lcdc_irq, lcdc_irq_handler, IRQF_SHARED, "miyoo_lcdc_irq", par);
+	  if(ret){
+		  printk("%s, failed to register lcdc interrupt(%d)\n", __func__, par->lcdc_irq);
+	  }
+  }
+  
+  par->gpio_irq = -1;//gpio_to_irq(SLCD_TE);
+  if (par->gpio_irq < 0) {
+    //printk("%s, failed to get irq number for gpio irq\n", __func__);
+  }
+  else{
+	  ret = request_irq(par->gpio_irq, gpio_irq_handler, IRQF_TRIGGER_RISING, "miyoo_gpio_irq", par);
+	  if(ret){
+		  printk("%s, failed to register gpio interrupt(%d)\n", __func__, par->gpio_irq);
+	  }
+  }
+}
+
+static void suniv_lcdc_init(struct myfb_par *par)
+{
+  uint32_t ret=0, bp=0, total=0, ver=0;
+	uint32_t h_front_porch = 8;
+	uint32_t h_back_porch = 8;
+	uint32_t h_sync_len = 1;
+	uint32_t v_front_porch = 8;
+	uint32_t v_back_porch = 8;
+	uint32_t v_sync_len = 1;
+      
+  ser_init();
+  ser_wr_cmd(0x04);
+  if(ser_rd_dat() == 0x42c2a97f){
+    ver = 4;
+  }
+  ser_deinit();
+
+  if (version == 4 && ver != 4) {
+    printk("Warning: LCD controller not detected as version 4, but being overridden by module_param as version 4 (detection 1 of 2)");
+    ver = version;
+  }
+    suniv_setbits(iomm.lcdc + TCON1_CTRL_REG, (0 << 31));
+    suniv_setbits(iomm.lcdc + TCON_CTRL_REG, (0 << 31));
+	writel(0, iomm.lcdc + TCON_CTRL_REG);
+	writel(0, iomm.lcdc + TCON_INT_REG0);
+	ret = readl(iomm.lcdc + TCON_CLK_CTRL_REG);
+	ret&= ~(0xf << 28);
+	writel(ret, iomm.lcdc + TCON_CLK_CTRL_REG);
+  writel(0xffffffff, iomm.lcdc + TCON0_IO_CTRL_REG1);
+	writel(0xffffffff, iomm.lcdc + TCON1_IO_CTRL_REG1);
+
+	suniv_setbits(iomm.debe + DEBE_MODE_CTRL_REG, (1 << 0));
+  writel(par->mode.xres << 4, iomm.debe + DEBE_LAY0_LINEWIDTH_REG);
+  writel(par->mode.xres << 4, iomm.debe + DEBE_LAY1_LINEWIDTH_REG);
+	writel((((par->mode.yres) - 1) << 16) | (((par->mode.xres) - 1) << 0), iomm.debe + DEBE_DISP_SIZE_REG);
+	writel((((par->mode.yres) - 1) << 16) | (((par->mode.xres) - 1) << 0), iomm.debe + DEBE_LAY0_SIZE_REG);
+	writel((((par->mode.yres) - 1) << 16) | (((par->mode.xres) - 1) << 0), iomm.debe + DEBE_LAY1_SIZE_REG);
+	writel((5 << 8), iomm.debe + DEBE_LAY0_ATT_CTRL_REG1);
+  writel((5 << 8), iomm.debe + DEBE_LAY1_ATT_CTRL_REG1);
+    ret = readl(iomm.debe + DEBE_LAY0_ATT_CTRL_REG0 ) & ~(3 << 1);
+    writel(ret | (0 << 1), iomm.debe + DEBE_LAY0_ATT_CTRL_REG0);
+	suniv_setbits(iomm.debe + DEBE_MODE_CTRL_REG, (1 << 8));
+	suniv_setbits(iomm.debe + DEBE_REGBUFF_CTRL_REG, (1 << 1));
+  suniv_setbits(iomm.debe + DEBE_MODE_CTRL_REG, (1 << 1));
+
+	ret = readl(iomm.lcdc + TCON_CTRL_REG);
+	ret&= ~(1 << 0);
+	writel(ret, iomm.lcdc + TCON_CTRL_REG);
+	ret = (v_front_porch + v_back_porch + v_sync_len);
+  if(ver == 4){
+    writel((uint32_t)(par->lram_phys[0]) << 3, iomm.debe + DEBE_LAY0_FB_ADDR_REG);
+    writel((uint32_t)(par->lram_phys[0]) >> 29, iomm.debe + DEBE_LAY0_FB_HI_ADDR_REG);
+    writel((uint32_t)(par->lram_phys[0]) << 3, iomm.debe + DEBE_LAY1_FB_ADDR_REG);
+    writel((uint32_t)(par->lram_phys[0]) >> 29, iomm.debe + DEBE_LAY1_FB_HI_ADDR_REG);
+    
+    //writel((uint32_t)(par->vram_phys) << 3, iomm.debe + DEBE_LAY0_FB_ADDR_REG);
+    //writel((uint32_t)(par->vram_phys) >> 29, iomm.debe + DEBE_LAY0_FB_HI_ADDR_REG);
+    //writel((uint32_t)(par->vram_phys + 320*240*2) << 3, iomm.debe + DEBE_LAY1_FB_ADDR_REG);
+    //writel((uint32_t)(par->vram_phys + 320*240*2) >> 29, iomm.debe + DEBE_LAY1_FB_HI_ADDR_REG);
+	  
+    writel((1 << 31) | ((ret & 0x1f) << 4) | (0 << 24), iomm.lcdc + TCON0_CTRL_REG);
+		writel(0x11111111, iomm.lcdc + TCON_FRM_SEED0_R_REG);
+		writel(0x11111111, iomm.lcdc + TCON_FRM_SEED0_G_REG);
+		writel(0x11111111, iomm.lcdc + TCON_FRM_SEED0_B_REG);
+		writel(0x11111111, iomm.lcdc + TCON_FRM_SEED1_R_REG);
+		writel(0x11111111, iomm.lcdc + TCON_FRM_SEED1_G_REG);
+		writel(0x11111111, iomm.lcdc + TCON_FRM_SEED1_B_REG);
+		writel(0x01010000, iomm.lcdc + TCON_FRM_TBL_REG0);
+		writel(0x15151111, iomm.lcdc + TCON_FRM_TBL_REG1);
+		writel(0x57575555, iomm.lcdc + TCON_FRM_TBL_REG2);
+		writel(0x7f7f7777, iomm.lcdc + TCON_FRM_TBL_REG3);
+		//writel((1 << 31) | (0 << 4), iomm.lcdc + TCON_FRM_CTRL_REG); // 18bit
+		writel((1 << 31) | (5 << 4), iomm.lcdc + TCON_FRM_CTRL_REG); // 16bit
+	  writel((0xf << 28) | (6 << 0), iomm.lcdc + TCON_CLK_CTRL_REG); // 6, 15
+	  writel((1 << 28) | (1 << 25) | (1 << 24), iomm.lcdc + TCON0_IO_CTRL_REG0);
+
+    p = par->lram_virt[0];
+    for(y=0; y<240; y++){
+      for(x=0; x<320; x++){
+        if(y < 80){
+          *p++ = 0xf800;
+        }
+        else if(y < 160){
+          *p++ = 0x7e0;
+        }
+        else{
+          *p++ = 0x1f;
+        }
+      }
+    }
+  
+    //suniv_setbits(iomm.gpio + PE_CFG0, 1 << 16);
+    //suniv_setbits(iomm.gpio + PE_CFG0, 1 << 17);
+    //suniv_clrbits(iomm.gpio + PE_CFG0, 1 << 18);
+    
+    //suniv_setbits(iomm.gpio + PE_CFG0, 1 << 20);
+    //suniv_setbits(iomm.gpio + PE_CFG0, 1 << 21);
+    //suniv_clrbits(iomm.gpio + PE_CFG0, 1 << 22);
+  }
+  else{
+    writel((uint32_t)(par->vram_phys) << 3, iomm.debe + DEBE_LAY0_FB_ADDR_REG);
+    writel((uint32_t)(par->vram_phys) >> 29, iomm.debe + DEBE_LAY0_FB_HI_ADDR_REG);
+    writel((uint32_t)(par->vram_phys + 320*240*2) << 3, iomm.debe + DEBE_LAY1_FB_ADDR_REG);
+    writel((uint32_t)(par->vram_phys + 320*240*2) >> 29, iomm.debe + DEBE_LAY1_FB_HI_ADDR_REG);
+	  
+    writel((1 << 31) | ((ret & 0x1f) << 4) | (1 << 24), iomm.lcdc + TCON0_CTRL_REG);
+	  writel((0xf << 28) | (6 << 0), iomm.lcdc + TCON_CLK_CTRL_REG); // 6, 15
+	  writel((4 << 29) | (1 << 26), iomm.lcdc + TCON0_CPU_IF_REG);
+	  writel((1 << 28), iomm.lcdc + TCON0_IO_CTRL_REG0);
+  }
+
+	writel(((par->mode.xres - 1) << 16) | ((par->mode.yres - 1) << 0), iomm.lcdc + TCON0_BASIC_TIMING_REG0);
+	bp = h_sync_len + h_back_porch;
+	total = par->mode.xres * 1 + h_front_porch + bp;
+	writel(((total - 1) << 16) | ((bp - 1) << 0), iomm.lcdc + TCON0_BASIC_TIMING_REG1);
+	bp = v_sync_len + v_back_porch;
+	total = par->mode.yres + v_front_porch + bp;
+	writel(((total * 2) << 16) | ((bp - 1) << 0), iomm.lcdc + TCON0_BASIC_TIMING_REG2);
+	writel(((h_sync_len - 1) << 16) | ((v_sync_len - 1) << 0), iomm.lcdc + TCON0_BASIC_TIMING_REG3);
+	writel(0, iomm.lcdc + TCON0_HV_TIMING_REG);
+	writel(0, iomm.lcdc + TCON0_IO_CTRL_REG1);	
+  
+	suniv_setbits(iomm.lcdc + TCON_CTRL_REG, (1 << 31)); 
+  printk("miyoo panel config as v%d\n", panel_init()); 
+  suniv_setbits(iomm.gpio + PE_INT_STA, (1 << 10));
+	suniv_setbits(iomm.lcdc + TCON_INT_REG0, (1 << 31));
+	suniv_setbits(iomm.lcdc + TCON0_CPU_IF_REG, (1 << 28));
+}
+
+static void suniv_cpu_init(struct myfb_par *par)
+{
+  uint32_t ret, i;
+    writel(0x91001307, iomm.ccm + PLL_VIDEO_CTRL_REG);
+  while((readl(iomm.ccm + PLL_VIDEO_CTRL_REG) & (1 << 28)) == 0){}
+  while((readl(iomm.ccm + PLL_PERIPH_CTRL_REG) & (1 << 28)) == 0){}
+
+	ret = readl(iomm.ccm + DRAM_GATING_REG);
+	ret|= (1 << 26) | (1 << 24);
+	writel(ret, iomm.ccm + DRAM_GATING_REG);
+  
+  suniv_setbits(iomm.ccm + FE_CLK_REG, (1 << 31));
+  suniv_setbits(iomm.ccm + BE_CLK_REG, (1 << 31));
+  suniv_setbits(iomm.ccm + TCON_CLK_REG, (1 << 31));
+  suniv_setbits(iomm.ccm + BUS_CLK_GATING_REG1, (1 << 14) | (1 << 12) | (1 << 4));
+  suniv_setbits(iomm.ccm + BUS_SOFT_RST_REG1, (1 << 14) | (1 << 12) | (1 << 4));
+  for(i=0x0800; i<0x1000; i+=4){
+    writel(0, iomm.debe + i);
+  }
+
+  //writel(0x90001c01, iomm.ccm + PLL_DDR_CTRL_REG);
+  //while((readl(iomm.ccm + PLL_DDR_CTRL_REG) & (1 << 28)) == 0){}
+  ddr_clock = readl(iomm.ccm + PLL_DDR_CTRL_REG);
+#if defined(DEBUG)
+  printk("DDR_clock set to 0x%x", (uint32_t)ddr_clock);
+#endif
+}
+
+#define CNVT_TOHW(val, width) ((((val) << (width)) + 0x7FFF - (val)) >> 16)
+static int myfb_setcolreg(unsigned regno, unsigned red, unsigned green, unsigned blue, unsigned transp, struct fb_info *info)
+{
+  red = CNVT_TOHW(red, info->var.red.length);
+  blue = CNVT_TOHW(blue, info->var.blue.length);
+  green = CNVT_TOHW(green, info->var.green.length);
+  ((u32*)(info->pseudo_palette))[regno] = (red << info->var.red.offset) | (green << info->var.green.offset) | (blue << info->var.blue.offset);
+  return 0;
+}
+#undef CNVT_TOHW
+
+static int myfb_check_var(struct fb_var_screeninfo *var, struct fb_info *info)
+{
+  int bpp = var->bits_per_pixel >> 3;
+  struct myfb_par *par = info->par;
+  unsigned long line_size = var->xres_virtual * bpp;
+
+  if((var->xres != 320) || (var->yres != 240) || (var->bits_per_pixel != 16)){
+    return -EINVAL;
+  }
+
+  var->transp.offset = 0;
+  var->transp.length = 0;
+  var->red.offset = 11;
+  var->red.length = 5;
+  var->green.offset = 5;
+  var->green.length = 6;
+  var->blue.offset = 0;
+  var->blue.length = 5;
+  var->red.msb_right = 0;
+  var->green.msb_right = 0;
+  var->blue.msb_right = 0;
+  var->transp.msb_right = 0;
+  if(line_size * var->yres_virtual > par->vram_size){
+    var->yres_virtual = par->vram_size / line_size;
+  }
+  if(var->yres > var->yres_virtual){
+    var->yres = var->yres_virtual;
+  }
+  if(var->xres > var->xres_virtual){
+    var->xres = var->xres_virtual;
+  }
+  if(var->xres + var->xoffset > var->xres_virtual){
+    var->xoffset = var->xres_virtual - var->xres;
+  }
+  if(var->yres + var->yoffset > var->yres_virtual){
+    var->yoffset = var->yres_virtual - var->yres;
+  }
+  return 0;
+}
+
+static int myfb_remove(struct platform_device *dev)
+{
+  int i;
+  struct fb_info *info = dev_get_drvdata(&dev->dev);
+  struct myfb_par *par = info->par;
+
+  if(info){
+    free_irq(par->lcdc_irq, par);
+    free_irq(par->gpio_irq, par);
+    flush_scheduled_work();
+    unregister_framebuffer(info);
+    fb_dealloc_cmap(&info->cmap);
+    dma_free_coherent(NULL, PALETTE_SIZE, par->v_palette_base, par->p_palette_base);
+    dma_free_coherent(NULL, par->vram_size, par->vram_virt, par->vram_phys);
+    for(i=0; i<LRAM_NUM; i++){
+      dma_free_coherent(NULL, par->lram_size, par->lram_virt[i], par->lram_phys[i]);
+    }
+    pm_runtime_put_sync(&dev->dev);
+    pm_runtime_disable(&dev->dev);
+    framebuffer_release(info);
+  }
+  return 0;
+}
+
+static int myfb_set_par(struct fb_info *info)
+{
+  struct myfb_par *par = info->par;
+
+  fb_var_to_videomode(&par->mode, &info->var);
+  par->yoffset = info->var.yoffset;
+  par->bpp = info->var.bits_per_pixel;
+  info->fix.visual = FB_VISUAL_TRUECOLOR;
+  info->fix.line_length = (par->mode.xres * par->bpp) / 8;
+  writel((5 << 8), iomm.debe + DEBE_LAY0_ATT_CTRL_REG1);
+  writel((5 << 8), iomm.debe + DEBE_LAY1_ATT_CTRL_REG1);
+  return 0;
+}
+
+static int myfb_ioctl(struct fb_info *info, unsigned int cmd, unsigned long arg)
+{
+  switch(cmd){
+  case FBIO_WAITFORVSYNC:
+    break;
+  }
+  return 0;
+}
+
+static int myfb_mmap(struct fb_info *info, struct vm_area_struct *vma)
+{
+  const unsigned long offset = vma->vm_pgoff << PAGE_SHIFT;
+  const unsigned long size = vma->vm_end - vma->vm_start;
+
+  if(offset + size > info->fix.smem_len){
+    return -EINVAL;
+  }
+
+  if(remap_pfn_range(vma, vma->vm_start, (info->fix.smem_start + offset) >> PAGE_SHIFT, size, vma->vm_page_prot)){
+    return -EAGAIN;
+  }
+  return 0;
+}
+
+static int myfb_pan_display(struct fb_var_screeninfo *var, struct fb_info *info)
+{
+  struct myfb_par *par = info->par;
+  if((var->xoffset != info->var.xoffset) || (var->yoffset != info->var.yoffset)){
+    info->var.xoffset = var->xoffset;
+    info->var.yoffset = var->yoffset;
+    par->yoffset = var->yoffset;
+  }
+  return 0;
+}
+
+static struct fb_ops myfb_ops = {
+  .owner          = THIS_MODULE,
+  .fb_check_var   = myfb_check_var,
+  .fb_set_par     = myfb_set_par,
+  .fb_setcolreg   = myfb_setcolreg,
+  .fb_pan_display = myfb_pan_display,
+  .fb_ioctl       = myfb_ioctl,
+  .fb_mmap        = myfb_mmap,
+
+  .fb_fillrect  = sys_fillrect,
+  .fb_copyarea  = sys_copyarea,
+  .fb_imageblit = sys_imageblit,
+};
+
+static int myfb_probe(struct platform_device *device)
+{
+  int i, ret;
+  struct fb_info *info;
+  struct myfb_par *par;
+  struct fb_videomode *mode;
+
+  mode = devm_kzalloc(&device->dev, sizeof(struct fb_videomode), GFP_KERNEL);
+  if(mode == NULL){
+    return -ENOMEM;
+  }
+  mode->name = "320x240";
+  mode->xres = 320;
+  mode->yres = 240;
+  mode->vmode = FB_VMODE_NONINTERLACED;
+  pm_runtime_enable(&device->dev);
+  pm_runtime_get_sync(&device->dev);
+
+  info = framebuffer_alloc(sizeof(struct myfb_par), &device->dev);
+  if(!info){
+    dev_dbg(&device->dev, "memory allocation failed for fb_info\n");
+    return -ENOMEM;
+  }
+
+  par = info->par;
+  par->pdev = device;
+  par->dev = &device->dev;
+  par->bpp = 16;
+  fb_videomode_to_var(&myfb_var, mode);
+
+  par->vram_size = 320*240*2*2;
+  par->vram_virt = dma_alloc_coherent(NULL, par->vram_size, (resource_size_t*)&par->vram_phys, GFP_KERNEL | GFP_DMA);
+  if(!par->vram_virt){
+    dev_err(&device->dev, "%s, failed to allocate frame buffer(vram)\n", __func__);
+    return -EINVAL;
+  }
+  info->screen_base = (char __iomem*)par->vram_virt;
+  myfb_fix.smem_start = par->vram_phys;
+  myfb_fix.smem_len = par->vram_size;
+  myfb_fix.line_length = 320 * 2;
+
+  par->lram_size = 320*240*18;
+  for(i=0; i<LRAM_NUM; i++){
+    par->lram_virt[i] = dma_alloc_coherent(NULL, par->lram_size, (resource_size_t*)&par->lram_phys[i], GFP_KERNEL | GFP_DMA);
+    if(!par->lram_virt[i]){
+      dev_err(&device->dev, "%s, failed to allocate frame buffer(lram[%d])\n", __func__, i);
+      return -EINVAL;
+    }
+  }
+
+  par->v_palette_base = dma_alloc_coherent(NULL, PALETTE_SIZE, (resource_size_t*)&par->p_palette_base, GFP_KERNEL | GFP_DMA);
+  if(!par->v_palette_base){
+    dev_err(&device->dev, "GLCD: kmalloc for palette buffer failed\n");
+    return -EINVAL;
+  }
+  memset(par->v_palette_base, 0, PALETTE_SIZE);
+  myfb_var.grayscale = 0;
+  myfb_var.bits_per_pixel = par->bpp;
+
+  info->flags = FBINFO_FLAG_DEFAULT;
+  info->fix = myfb_fix;
+  info->var = myfb_var;
+  info->fbops = &myfb_ops;
+  info->pseudo_palette = par->pseudo_palette;
+  info->fix.visual = (info->var.bits_per_pixel <= 8) ? FB_VISUAL_PSEUDOCOLOR : FB_VISUAL_TRUECOLOR;
+  ret = fb_alloc_cmap(&info->cmap, PALETTE_SIZE, 0);
+  if(ret){
+    return -EINVAL;
+  }
+  info->cmap.len = 32;
+
+  myfb_var.activate = FB_ACTIVATE_FORCE;
+  fb_set_var(info, &myfb_var);
+  dev_set_drvdata(&device->dev, info);
+
+  if(register_framebuffer(info) < 0){
+    dev_err(&device->dev, "failed to register /dev/fb0\n");
+    return -EINVAL;
+  }
+
+  mypar = par;
+  new_bp = -1;
+  new_fp = -1;
+  for(ret=0; ret<of_clk_get_parent_count(device->dev.of_node); ret++){
+    clk_prepare_enable(of_clk_get(device->dev.of_node, ret));
+  }
+  suniv_cpu_init(par);
+  suniv_gpio_init();
+  suniv_lcdc_init(par);
+  suniv_enable_irq(par);
+
+  fb_prepare_logo(info, 0);
+  fb_show_logo(info, 0);
+  return 0;
+}
+
+static int myfb_suspend(struct platform_device *dev, pm_message_t state)
+{
+  struct fb_info *info = platform_get_drvdata(dev);
+
+  console_lock();
+  fb_set_suspend(info, 1);
+  pm_runtime_put_sync(&dev->dev);
+  console_unlock();
+  return 0;
+}
+
+static int myfb_resume(struct platform_device *dev)
+{
+  struct fb_info *info = platform_get_drvdata(dev);
+
+  console_lock();
+  pm_runtime_get_sync(&dev->dev);
+  fb_set_suspend(info, 0);
+  console_unlock();
+  return 0;
+}
+
+static const struct of_device_id fb_of_match[] = {
+  {
+    .compatible = "allwinner,suniv-f1c500s-tcon0",
+  },{}
+};
+MODULE_DEVICE_TABLE(of, fb_of_match);
+
+static struct platform_driver fb_driver = {
+  .probe    = myfb_probe,
+  .remove   = myfb_remove,
+  .suspend  = myfb_suspend,
+  .resume   = myfb_resume,
+  .driver = {
+    .name   = DRIVER_NAME,
+    .owner  = THIS_MODULE,
+    .of_match_table = of_match_ptr(fb_of_match),
+  },
+};
+
+static void suniv_ioremap(void)
+{
+  iomm.dma = (uint8_t*)ioremap(SUNIV_DMA_BASE, 4096);
+  iomm.ccm = (uint8_t*)ioremap(SUNIV_CCM_BASE, 4096);
+  iomm.gpio = (uint8_t*)ioremap(SUNIV_GPIO_BASE, 4096);
+  iomm.lcdc = (uint8_t*)ioremap(SUNIV_LCDC_BASE, 4096);
+  iomm.debe = (uint8_t*)ioremap(SUNIV_DEBE_BASE, 4096);
+  iomm.intc = (uint8_t*)ioremap(SUNIV_INTC_BASE, 4096);
+}
+
+static void suniv_iounmap(void)
+{
+  iounmap(iomm.dma);
+  iounmap(iomm.ccm);
+  iounmap(iomm.gpio);
+  iounmap(iomm.lcdc);
+  iounmap(iomm.debe);
+  iounmap(iomm.intc);
+}
+
+static int myopen(struct inode *inode, struct file *file)
+{
+  return 0;
+}
+
+static int myclose(struct inode *inode, struct file *file)
+{
+  return 0;
+}
+
+static long myioctl(struct file *filp, unsigned int cmd, unsigned long arg)
+{
+  int32_t w, bpp;
+  unsigned long tmp;
+
+  switch(cmd){
+  case MIYOO_FB0_PUT_OSD:
+    break;
+  case MIYOO_FB0_SET_MODE:
+    w = (arg >> 16);
+    bpp = (arg & 0xffff);
+    if((bpp != 16)){
+	    writel((5 << 8), iomm.debe + DEBE_LAY0_ATT_CTRL_REG1);
+      writel((5 << 8), iomm.debe + DEBE_LAY1_ATT_CTRL_REG1);
+    }
+    else{
+	    writel((7 << 8) | 4, iomm.debe + DEBE_LAY0_ATT_CTRL_REG1);
+	    writel((7 << 8) | 4, iomm.debe + DEBE_LAY1_ATT_CTRL_REG1);
+    }
+    break;
+  case MIYOO_FB0_GET_VER:
+#if defined(MIYOO3)
+    w = copy_to_user((void*)arg, &miyoo_ver, sizeof(uint32_t));
+    break;
+#elif defined(POCKETGO)
+    w = copy_to_user((void*)arg, &miyoo_ver_temp, sizeof(uint32_t));
+    break
+#else
+    w = copy_to_user((void*)arg, &miyoo_ver, sizeof(uint32_t));
+    break;
+#endif
+  case MIYOO_FB0_SET_FLIP:
+    flip = (bool)arg;
+    ret = readl(iomm.gpio + PD_CFG0);
+    ret&= 0x0000000f;
+    ret|= 0x11111110;
+    writel(0x11111101, iomm.gpio + PD_CFG1);
+    writel(0x00111111, iomm.gpio + PD_CFG2);
+    writel(0xffffffff, iomm.gpio + PD_DATA);
+    mdelay(50);
+    gpio_wr_cmd(0x28);
+    mdelay(250);
+    gpio_wr_cmd(0x36);
+    if(flip){
+    	gpio_wr_dat(0xB0); //screen direction //0x70 for 3.5, 0xB0 for pg
+    } else {
+    	gpio_wr_dat(0x70); //screen direction //0x70 for 3.5, 0xB0 for pg
+    }
+    mdelay(50);
+    gpio_wr_cmd(0x29);
+    mdelay(50);
+    gpio_wr_cmd(0x2c);
+    mdelay(100);
+    writel(0xffffffff, iomm.gpio + PD_DATA);
+    ret = readl(iomm.gpio + PD_CFG0);
+    ret&= 0x0000000f;
+    ret|= 0x22222220;
+    writel(ret, iomm.gpio + PD_CFG0);
+          ret = readl(iomm.gpio + PD_CFG1);
+          ret&= 0x000000f0;
+          ret|= 0x22222212;
+          writel(ret, iomm.gpio + PD_CFG1);
+    writel(0x00222222, iomm.gpio + PD_CFG2);
+    break;
+  case MIYOO_FB0_GET_FPBP:
+    tmp = (def_fp & 0x0f) << 12;
+    tmp|= (def_bp & 0x0f) <<  8;
+    tmp|= (new_fp & 0x0f) <<  4;
+    tmp|= (new_bp & 0x0f) <<  0;
+    w = copy_to_user((void*)arg, &tmp, sizeof(unsigned long));
+    break;
+  case MIYOO_FB0_SET_FPBP:
+    new_fp = (arg & 0xf0) >> 4;
+    new_bp = (arg & 0x0f) >> 0;
+
+    flip_mode = 1;
+    mdelay(100);
+    panel_init();
+    flip_mode = 0;
+	  suniv_setbits(iomm.debe + DEBE_REGBUFF_CTRL_REG, (1 << 0));
+    break;
+  }
+  return 0;
+}
+
+static const struct file_operations myfops = {
+  .owner = THIS_MODULE,
+  .open = myopen,
+  .release = myclose,
+  .unlocked_ioctl = myioctl,
+};
+
+static int __init fb_init(void)
+{
+    suniv_ioremap();
+    alloc_chrdev_region(&major, 0, 1, "miyoo_fb0");
+    myclass = class_create(THIS_MODULE, "miyoo_fb0");
+    device_create(myclass, NULL, major, NULL, "miyoo_fb0");
+    cdev_init(&mycdev, &myfops);
+    cdev_add(&mycdev, major, 1);
+    return platform_driver_register(&fb_driver);
+}
+
+static void __exit fb_cleanup(void)
+{
+  suniv_iounmap();
+  device_destroy(myclass, major);
+  cdev_del(&mycdev);
+  class_destroy(myclass);
+  unregister_chrdev_region(major, 1);
+  platform_driver_unregister(&fb_driver);
+}
+
+module_init(fb_init);
+module_exit(fb_cleanup);
+
+MODULE_DESCRIPTION("Allwinner suniv framebuffer driver for Miyoo handheld");
+MODULE_AUTHOR("Steward Fu <steward.fu@gmail.com>");
+MODULE_LICENSE("GPL");
diff --git a/drivers/video/fbdev/rm68090fb.c b/drivers/video/fbdev/rm68090fb.c
new file mode 100644
index 00000000..ada2c24b
--- /dev/null
+++ b/drivers/video/fbdev/rm68090fb.c
@@ -0,0 +1,875 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option)any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+#include <linux/cdev.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/fb.h>
+#include <linux/dma-mapping.h>
+#include <linux/device.h>
+#include <linux/platform_device.h>
+#include <linux/uaccess.h>
+#include <linux/pm_runtime.h>
+#include <linux/interrupt.h>
+#include <linux/wait.h>
+#include <linux/clk.h>
+#include <linux/cpufreq.h>
+#include <linux/console.h>
+#include <linux/spinlock.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+#include <linux/lcm.h>
+#include <linux/clk-provider.h>
+#include <video/of_display_timing.h>
+#include <linux/gpio.h>
+#include <linux/omapfb.h>
+#include <linux/compiler.h>
+#include <linux/workqueue.h>
+#include <asm/io.h>
+#include <asm/gpio.h>
+#include <asm/arch-suniv/cpu.h>
+#include <asm/arch-suniv/dma.h>
+#include <asm/arch-suniv/gpio.h>
+#include <asm/arch-suniv/intc.h>
+#include <asm/arch-suniv/lcdc.h>
+#include <asm/arch-suniv/debe.h>
+#include <asm/arch-suniv/clock.h>
+#include <asm/arch-suniv/common.h>
+
+#define MIYOO_FB0_PUT_OSD     _IOWR(0x100, 0, unsigned long)
+#define MIYOO_FB0_SET_MODE    _IOWR(0x101, 0, unsigned long)
+#define MIYOO_FB0_GET_VER     _IOWR(0x102, 0, unsigned long)
+#define MIYOO_FB0_SET_FLIP    _IOWR(0x103, 0, unsigned long)
+#define MIYOO_FB0_SET_FPBP    _IOWR(0x104, 0, unsigned long)
+#define MIYOO_FB0_GET_FPBP    _IOWR(0x105, 0, unsigned long)
+
+#define NO_POCKET_GO             1
+#define MIYOO3                1
+
+#define LRAM_NUM              1
+#define PALETTE_SIZE          256
+#define DRIVER_NAME           "miyoofb"
+#define SLCD_RESET		        ((32 * 4) + 11) // PE11
+#define SLCD_TE		  		      ((32 * 4) + 10) // PE10
+
+struct myfb_par {
+  struct device *dev;
+  struct platform_device *pdev;
+
+  resource_size_t p_palette_base;
+  unsigned short *v_palette_base;
+ 
+  dma_addr_t vram_phys;
+  uint32_t vram_size;
+  void *vram_virt;
+  int yoffset;
+  
+  dma_addr_t lram_phys[LRAM_NUM];
+  uint32_t lram_size;
+  void *lram_virt[LRAM_NUM];
+  void *dma_addr;
+ 
+  int bpp;
+  int lcdc_irq;
+  int gpio_irq;
+  volatile int have_te;
+  u32 pseudo_palette[16];
+  struct fb_videomode mode;
+};
+
+struct suniv_iomm {
+  uint8_t *dma;
+  uint8_t *ccm;
+  uint8_t *gpio;
+  uint8_t *lcdc;
+  uint8_t *debe;
+  uint8_t *intc;
+};
+static struct suniv_iomm iomm={0};
+
+static int major = -1;
+static struct cdev mycdev;
+static struct class *myclass = NULL;
+static int flip_mode=0;
+static int new_bp=8;
+static int new_fp=8;
+static int def_bp=8;
+static int def_fp=8;
+uint32_t ret;
+int x, y;
+uint16_t *p;
+
+struct myfb_par *mypar;
+static struct fb_var_screeninfo myfb_var;
+static struct fb_fix_screeninfo myfb_fix = {
+  .id = DRIVER_NAME,
+  .type = FB_TYPE_PACKED_PIXELS,
+  .type_aux = 0,
+  .visual = FB_VISUAL_TRUECOLOR,
+  .xpanstep = 0,
+  .ypanstep = 1,
+  .ywrapstep = 0,
+  .accel = FB_ACCEL_NONE
+};
+
+static void suniv_gpio_init(void)
+{
+  uint32_t ret;
+
+  ret = readl(iomm.gpio + PD_CFG0);
+  ret&= 0x0000000f;
+  ret|= 0x22222220;
+  writel(ret, iomm.gpio + PD_CFG0);
+  writel(0x22222202, iomm.gpio + PD_CFG1);
+  writel(0x00222222, iomm.gpio + PD_CFG2);
+  writel(0x00040001, iomm.gpio + PD_PUL0);
+  writel(0x00000000, iomm.gpio + PD_PUL1);
+  //writel(0xffffffff, iomm.gpio + PD_DRV0);
+  writel(0xffffffff, iomm.gpio + PD_DRV1);
+
+  ret = readl(iomm.gpio + PE_PUL0);
+  ret&= 0xff0fffff;
+  ret|= 0x00500000;
+  writel(ret, iomm.gpio + PE_PUL0);
+  
+  ret = readl(iomm.gpio + PE_CFG1);
+  ret&= 0xffff0fff;
+  ret|= 0x00001000;
+  writel(ret, iomm.gpio + PE_CFG1);
+}
+
+static uint32_t lcdc_wait_busy(void)
+{
+	uint32_t cnt=0;
+	
+  suniv_setbits(iomm.lcdc + TCON0_CPU_IF_REG, (1 << 0));
+	ndelay(10);
+	while(1){
+		if(readl(iomm.lcdc + TCON0_CPU_IF_REG) & 0x00c00000){
+			if(cnt > 200){
+				return -1;
+			}
+		  else{
+		  	cnt+= 1;
+			}
+		}
+		break;
+	}
+	return 0;
+}
+
+static uint32_t extend_16b_to_24b(uint32_t value)
+{
+	return ((value & 0xfc00) << 8) | ((value & 0x0300) << 6) | ((value & 0x00e0) << 5) | ((value & 0x001f) << 3);
+}
+
+static void lcdc_wr(uint8_t is_data, uint32_t data)
+{
+	while(lcdc_wait_busy());
+	if(is_data){
+		suniv_setbits(iomm.lcdc + TCON0_CPU_IF_REG, (1 << 25)); // ca=1
+	}
+	else{
+		suniv_clrbits(iomm.lcdc + TCON0_CPU_IF_REG, (1 << 25)); // ca=0	
+	}
+	while(lcdc_wait_busy());
+	writel(extend_16b_to_24b(data), iomm.lcdc + TCON0_CPU_WR_REG);
+}
+
+
+static void lcdc_wr_cmd(uint32_t cmd)
+{
+	lcdc_wr(0, cmd);
+}
+
+static void lcdc_wr_dat(uint32_t cmd)
+{
+	lcdc_wr(1, cmd);
+}
+
+
+static void refresh_lcd(struct myfb_par *par)
+{
+
+    lcdc_wr_cmd(0x22);
+
+  if(par->yoffset == 0){
+	  suniv_setbits(iomm.debe + DEBE_MODE_CTRL_REG, (1 << 8));
+	  suniv_clrbits(iomm.debe + DEBE_MODE_CTRL_REG, (1 << 9));
+  }
+  else{
+	  suniv_clrbits(iomm.debe + DEBE_MODE_CTRL_REG, (1 << 8));
+	  suniv_setbits(iomm.debe + DEBE_MODE_CTRL_REG, (1 << 9));
+  }
+	suniv_setbits(iomm.debe + DEBE_REGBUFF_CTRL_REG, (1 << 0));
+}
+
+static irqreturn_t gpio_irq_handler(int irq, void *arg)
+{
+  static uint32_t cnt=0, report=0;
+  struct myfb_par *par = arg;
+
+  suniv_setbits(iomm.gpio + PE_INT_STA, (1 << 10));
+  if(cnt > 10){
+    par->have_te = 1;
+    if(flip_mode == 0){
+      if(report++ >= 60){
+        report = 0;
+        printk("%s\n", __func__);
+      }
+      refresh_lcd(par);
+    }
+  }
+  else{
+    cnt+= 1;
+  }
+  return IRQ_HANDLED;
+}
+
+static irqreturn_t lcdc_irq_handler(int irq, void *arg)
+{
+  static uint32_t report=0;
+  struct myfb_par *par = arg;
+
+  suniv_clrbits(iomm.lcdc + TCON_INT_REG0, (1 << 15));
+  if(par->have_te == 0){
+    if(flip_mode == 0){
+      if(report++ >= 60){
+        report = 0;
+        //printk("%s\n", __func__);
+      }
+      refresh_lcd(par);
+    }
+  }
+  return IRQ_HANDLED;
+}
+
+static void panel_init(void)
+{
+  
+  suniv_setbits(iomm.lcdc + PE_DATA, (11 << 0));
+  mdelay(50);
+  suniv_clrbits(iomm.lcdc + PE_DATA, (11 << 0));
+  mdelay(150);
+  suniv_setbits(iomm.lcdc + PE_DATA, (11 << 0));
+  mdelay(150);
+
+  lcdc_wr_cmd(0x01); 
+  lcdc_wr_dat(0x0100); // Set SS and SM bit
+  lcdc_wr_cmd(0x02);
+  lcdc_wr_dat(0x0700); // Set line inversion
+  lcdc_wr_cmd(0x03);
+  lcdc_wr_dat(0x1008); // Set Write direction
+  lcdc_wr_cmd(0x04);
+  lcdc_wr_dat(0x0000); // Set Scaling function off
+  lcdc_wr_cmd(0x08); 
+  lcdc_wr_dat(0x0207); // Set BP and FP
+  lcdc_wr_cmd(0x09); 
+  lcdc_wr_dat(0x0000); // Set non-display area
+  lcdc_wr_cmd(0x0A); 
+  lcdc_wr_dat(0x0000); // Frame marker control
+  lcdc_wr_cmd(0x0C); 
+  lcdc_wr_dat(0x0000); // Set interface control
+  lcdc_wr_cmd(0x0D); 
+  lcdc_wr_dat(0x0000); // Frame marker Position
+  lcdc_wr_cmd(0x0F); 
+  lcdc_wr_dat(0x0000); // Set RGB interface 
+  //--------------- Power On Sequence----------------//
+  lcdc_wr_cmd(0x10); 
+  lcdc_wr_dat(0x0000); // Set SAP);BT[3:0]);AP);SLP);STB
+  lcdc_wr_cmd(0x11); 
+  lcdc_wr_dat(0x0007); // Set DC1[2:0]);DC0[2:0]);VC
+  lcdc_wr_cmd(0x12); 
+  lcdc_wr_dat(0x0000); // Set VREG1OUT voltage
+  lcdc_wr_cmd(0x13); 
+  lcdc_wr_dat(0x0000); // Set VCOM AMP voltage
+  lcdc_wr_cmd(0x07); 
+  lcdc_wr_dat(0x0001); // Set VCOM AMP voltage
+  lcdc_wr_cmd(0x07); 
+  lcdc_wr_dat(0x0020); // Set VCOM AMP voltage
+  mdelay(200);
+  lcdc_wr_cmd(0x10); 
+  lcdc_wr_dat(0x1290); // Set SAP);BT[3:0]);AP);SLP);STB
+  lcdc_wr_cmd(0x11); 
+  lcdc_wr_dat(0x0221); // Set DC1[2:0]);DC0[2:0]);VC[2:0]
+  mdelay(50);
+  lcdc_wr_cmd(0x12); 
+  lcdc_wr_dat(0x0081); // Set VREG1OUT voltaged
+  mdelay(50);
+  lcdc_wr_cmd(0x13); 
+  lcdc_wr_dat(0x1500); // Set VCOM AMP voltage
+  lcdc_wr_cmd(0x29); 
+  lcdc_wr_dat(0x000c); // Set VCOMH voltage
+  lcdc_wr_cmd(0x2B); 
+  lcdc_wr_dat(0x000D); // Set Frame rate.
+  mdelay(50);
+  lcdc_wr_cmd(0x20); 
+  lcdc_wr_dat(0x0000); // Set GRAM Horizontal Address
+  lcdc_wr_cmd(0x21); 
+  lcdc_wr_dat(0x0000); // Set GRAM Vertical Address
+  //****************************************************
+  lcdc_wr_cmd(0x30); 
+  lcdc_wr_dat(0x0303);
+  lcdc_wr_cmd(0x31); 
+  lcdc_wr_dat(0x0006);
+  lcdc_wr_cmd(0x32); 
+  lcdc_wr_dat(0x0001);
+  lcdc_wr_cmd(0x35); 
+  lcdc_wr_dat(0x0204);
+  lcdc_wr_cmd(0x36); 
+  lcdc_wr_dat(0x0004);
+  lcdc_wr_cmd(0x37); 
+  lcdc_wr_dat(0x0407);
+  lcdc_wr_cmd(0x38); 
+  lcdc_wr_dat(0x0000);
+  lcdc_wr_cmd(0x39); 
+  lcdc_wr_dat(0x0404);
+  lcdc_wr_cmd(0x3C); 
+  lcdc_wr_dat(0x0402);
+  lcdc_wr_cmd(0x3D); 
+  lcdc_wr_dat(0x0004);
+  //---------------  RAM Address Control ----------------//
+  lcdc_wr_cmd(0x50); 
+  lcdc_wr_dat(0x0000); // Set GRAM Horizontal Start Address
+  lcdc_wr_cmd(0x51); 
+  lcdc_wr_dat(0x00EF); // Set GRAM Horizontal End Address
+  lcdc_wr_cmd(0x52); 
+  lcdc_wr_dat(0x0000); // Set GRAM Vertical Start Address
+  lcdc_wr_cmd(0x53); 
+  lcdc_wr_dat(0x013F); // Set GRAM Vertical End Address
+  //---------------  Panel Image Control -----------------//
+  lcdc_wr_cmd(0x60); 
+  lcdc_wr_dat(0x2700); // Set Gate Scan line
+  lcdc_wr_cmd(0x61); 
+  lcdc_wr_dat(0x0001); // Set NDL); VLE); REV
+  lcdc_wr_cmd(0x6A); 
+  lcdc_wr_dat(0x0000); // Set Scrolling line
+  //---------------  Panel Interface Control---------------//
+  lcdc_wr_cmd(0x90); 
+  lcdc_wr_dat(0x0010);
+  lcdc_wr_cmd(0x92); 
+  lcdc_wr_dat(0x0000);
+  //--------------- Display On-------------------------------//
+  lcdc_wr_cmd(0x07); 
+  lcdc_wr_dat(0x0133); // Display on
+  lcdc_wr_cmd(0x22);
+
+
+  writel(0xffffffff, iomm.gpio + PD_DATA);
+  ret = readl(iomm.gpio + PD_CFG0);
+  ret&= 0x0000000f;
+  ret|= 0x22222220;
+  writel(ret, iomm.gpio + PD_CFG0);
+  writel(0x22222202, iomm.gpio + PD_CFG1);
+  writel(0x00222222, iomm.gpio + PD_CFG2);
+
+}
+
+static void suniv_enable_irq(struct myfb_par *par)
+{
+  int ret;
+
+  par->have_te = 0;
+  par->lcdc_irq = platform_get_irq(par->pdev, 0);
+  if (par->lcdc_irq < 0) {
+    printk("%s, failed to get irq number for lcdc irq\n", __func__);
+  }
+  else{
+	  ret = request_irq(par->lcdc_irq, lcdc_irq_handler, IRQF_SHARED, "miyoo_lcdc_irq", par);
+	  if(ret){
+		  printk("%s, failed to register lcdc interrupt(%d)\n", __func__, par->lcdc_irq);
+	  }
+  }
+  
+  par->gpio_irq = -1;//gpio_to_irq(SLCD_TE);
+  if (par->gpio_irq < 0) {
+    //printk("%s, failed to get irq number for gpio irq\n", __func__);
+  }
+  else{
+	  ret = request_irq(par->gpio_irq, gpio_irq_handler, IRQF_TRIGGER_RISING, "miyoo_gpio_irq", par);
+	  if(ret){
+		  printk("%s, failed to register gpio interrupt(%d)\n", __func__, par->gpio_irq);
+	  }
+  }
+}
+
+static void suniv_lcdc_init(struct myfb_par *par)
+{
+  uint32_t ret=0, bp=0, total=0;
+	uint32_t h_front_porch = 8;
+	uint32_t h_back_porch = 8;
+	uint32_t h_sync_len = 1;
+	uint32_t v_front_porch = 8;
+	uint32_t v_back_porch = 8;
+	uint32_t v_sync_len = 1;
+ 
+	writel(0, iomm.lcdc + TCON_CTRL_REG);
+	writel(0, iomm.lcdc + TCON_INT_REG0);
+	ret = readl(iomm.lcdc + TCON_CLK_CTRL_REG);
+	ret&= ~(0xf << 28);
+	writel(ret, iomm.lcdc + TCON_CLK_CTRL_REG);
+  writel(0xffffffff, iomm.lcdc + TCON0_IO_CTRL_REG1);
+	writel(0xffffffff, iomm.lcdc + TCON1_IO_CTRL_REG1);
+
+	suniv_setbits(iomm.debe + DEBE_MODE_CTRL_REG, (1 << 0));
+  writel(par->mode.xres << 4, iomm.debe + DEBE_LAY0_LINEWIDTH_REG);
+  writel(par->mode.xres << 4, iomm.debe + DEBE_LAY1_LINEWIDTH_REG);
+	writel((((par->mode.yres) - 1) << 16) | (((par->mode.xres) - 1) << 0), iomm.debe + DEBE_DISP_SIZE_REG);
+	writel((((par->mode.yres) - 1) << 16) | (((par->mode.xres) - 1) << 0), iomm.debe + DEBE_LAY0_SIZE_REG);
+	writel((((par->mode.yres) - 1) << 16) | (((par->mode.xres) - 1) << 0), iomm.debe + DEBE_LAY1_SIZE_REG);
+	writel((5 << 8), iomm.debe + DEBE_LAY0_ATT_CTRL_REG1);
+  writel((5 << 8), iomm.debe + DEBE_LAY1_ATT_CTRL_REG1);
+	suniv_setbits(iomm.debe + DEBE_MODE_CTRL_REG, (1 << 8));
+	suniv_setbits(iomm.debe + DEBE_REGBUFF_CTRL_REG, (1 << 1));
+  suniv_setbits(iomm.debe + DEBE_MODE_CTRL_REG, (1 << 1));
+
+	ret = readl(iomm.lcdc + TCON_CTRL_REG);
+	ret&= ~(1 << 0);
+	writel(ret, iomm.lcdc + TCON_CTRL_REG);
+	ret = (v_front_porch + v_back_porch + v_sync_len);
+
+    writel((uint32_t)(par->vram_phys) << 3, iomm.debe + DEBE_LAY0_FB_ADDR_REG);
+    writel((uint32_t)(par->vram_phys) >> 29, iomm.debe + DEBE_LAY0_FB_HI_ADDR_REG);
+    writel((uint32_t)(par->vram_phys + 320*240*2) << 3, iomm.debe + DEBE_LAY1_FB_ADDR_REG);
+    writel((uint32_t)(par->vram_phys + 320*240*2) >> 29, iomm.debe + DEBE_LAY1_FB_HI_ADDR_REG);
+	  
+    writel((1 << 31) | ((ret & 0x1f) << 4) | (1 << 24), iomm.lcdc + TCON0_CTRL_REG);
+	  writel((0xf << 28) | (6 << 0), iomm.lcdc + TCON_CLK_CTRL_REG); // 6, 15
+	  writel((4 << 29) | (1 << 26), iomm.lcdc + TCON0_CPU_IF_REG);
+	  writel((1 << 28), iomm.lcdc + TCON0_IO_CTRL_REG0);
+
+
+	writel(((par->mode.xres - 1) << 16) | ((par->mode.yres - 1) << 0), iomm.lcdc + TCON0_BASIC_TIMING_REG0);
+	bp = h_sync_len + h_back_porch;
+	total = par->mode.xres * 1 + h_front_porch + bp;
+	writel(((total - 1) << 16) | ((bp - 1) << 0), iomm.lcdc + TCON0_BASIC_TIMING_REG1);
+	bp = v_sync_len + v_back_porch;
+	total = par->mode.yres + v_front_porch + bp;
+	writel(((total * 2) << 16) | ((bp - 1) << 0), iomm.lcdc + TCON0_BASIC_TIMING_REG2);
+	writel(((h_sync_len - 1) << 16) | ((v_sync_len - 1) << 0), iomm.lcdc + TCON0_BASIC_TIMING_REG3);
+	writel(0, iomm.lcdc + TCON0_HV_TIMING_REG);
+	writel(0, iomm.lcdc + TCON0_IO_CTRL_REG1);	
+  
+	suniv_setbits(iomm.lcdc + TCON_CTRL_REG, (1 << 31));
+  suniv_setbits(iomm.gpio + PE_INT_STA, (1 << 10));
+	suniv_setbits(iomm.lcdc + TCON_INT_REG0, (1 << 31));
+	suniv_setbits(iomm.lcdc + TCON0_CPU_IF_REG, (1 << 28));
+}
+
+static void suniv_cpu_init(struct myfb_par *par)
+{
+  uint32_t ret, i;
+    writel(0x91001307, iomm.ccm + PLL_VIDEO_CTRL_REG);
+    while((readl(iomm.ccm + PLL_VIDEO_CTRL_REG) & (1 << 28)) == 0){}
+    while((readl(iomm.ccm + PLL_PERIPH_CTRL_REG) & (1 << 28)) == 0){}
+
+	ret = readl(iomm.ccm + DRAM_GATING_REG);
+	ret|= (1 << 26) | (1 << 24);
+	writel(ret, iomm.ccm + DRAM_GATING_REG);
+  
+  suniv_setbits(iomm.ccm + FE_CLK_REG, (1 << 31));
+  suniv_setbits(iomm.ccm + BE_CLK_REG, (1 << 31));
+  suniv_setbits(iomm.ccm + TCON_CLK_REG, (1 << 31));
+  suniv_setbits(iomm.ccm + BUS_CLK_GATING_REG1, (1 << 14) | (1 << 12) | (1 << 4));
+  suniv_setbits(iomm.ccm + BUS_SOFT_RST_REG1, (1 << 14) | (1 << 12) | (1 << 4));
+  for(i=0x0800; i<0x1000; i+=4){
+    writel(0, iomm.debe + i);
+  }
+}
+
+#define CNVT_TOHW(val, width) ((((val) << (width)) + 0x7FFF - (val)) >> 16)
+static int myfb_setcolreg(unsigned regno, unsigned red, unsigned green, unsigned blue, unsigned transp, struct fb_info *info)
+{
+  red = CNVT_TOHW(red, info->var.red.length);
+  blue = CNVT_TOHW(blue, info->var.blue.length);
+  green = CNVT_TOHW(green, info->var.green.length);
+  ((u32*)(info->pseudo_palette))[regno] = (red << info->var.red.offset) | (green << info->var.green.offset) | (blue << info->var.blue.offset);
+  return 0;
+}
+#undef CNVT_TOHW
+ 
+static int myfb_check_var(struct fb_var_screeninfo *var, struct fb_info *info)
+{
+  int bpp = var->bits_per_pixel >> 3;
+  struct myfb_par *par = info->par;
+  unsigned long line_size = var->xres_virtual * bpp;
+ 
+  if((var->xres != 320) || (var->yres != 240) || (var->bits_per_pixel != 16)){
+    return -EINVAL;
+  }
+ 
+  var->transp.offset = 0;
+  var->transp.length = 0;
+  var->red.offset = 11;
+  var->red.length = 5;
+  var->green.offset = 5;
+  var->green.length = 6;
+  var->blue.offset = 0;
+  var->blue.length = 5;
+  var->red.msb_right = 0;
+  var->green.msb_right = 0;
+  var->blue.msb_right = 0;
+  var->transp.msb_right = 0;
+  if(line_size * var->yres_virtual > par->vram_size){
+    var->yres_virtual = par->vram_size / line_size;
+  }
+  if(var->yres > var->yres_virtual){
+    var->yres = var->yres_virtual;
+  }
+  if(var->xres > var->xres_virtual){
+    var->xres = var->xres_virtual;
+  }
+  if(var->xres + var->xoffset > var->xres_virtual){
+    var->xoffset = var->xres_virtual - var->xres;
+  }
+  if(var->yres + var->yoffset > var->yres_virtual){
+    var->yoffset = var->yres_virtual - var->yres;
+  }
+  return 0;
+}
+ 
+static int myfb_remove(struct platform_device *dev)
+{
+  int i;
+  struct fb_info *info = dev_get_drvdata(&dev->dev);
+  struct myfb_par *par = info->par;
+ 
+  if(info){
+    free_irq(par->lcdc_irq, par);
+    free_irq(par->gpio_irq, par);
+    flush_scheduled_work();
+    unregister_framebuffer(info);
+    fb_dealloc_cmap(&info->cmap);
+    dma_free_coherent(NULL, PALETTE_SIZE, par->v_palette_base, par->p_palette_base);
+    dma_free_coherent(NULL, par->vram_size, par->vram_virt, par->vram_phys);
+    for(i=0; i<LRAM_NUM; i++){
+      dma_free_coherent(NULL, par->lram_size, par->lram_virt[i], par->lram_phys[i]);
+    }
+    pm_runtime_put_sync(&dev->dev);
+    pm_runtime_disable(&dev->dev);
+    framebuffer_release(info);
+  }
+  return 0;
+}
+ 
+static int myfb_set_par(struct fb_info *info)
+{
+  struct myfb_par *par = info->par;
+   
+  fb_var_to_videomode(&par->mode, &info->var);
+  par->yoffset = info->var.yoffset;
+  par->bpp = info->var.bits_per_pixel;
+  info->fix.visual = FB_VISUAL_TRUECOLOR;
+  info->fix.line_length = (par->mode.xres * par->bpp) / 8; 	
+  writel((5 << 8), iomm.debe + DEBE_LAY0_ATT_CTRL_REG1);
+  writel((5 << 8), iomm.debe + DEBE_LAY1_ATT_CTRL_REG1);
+  return 0;
+}
+ 
+static int myfb_ioctl(struct fb_info *info, unsigned int cmd, unsigned long arg)
+{
+  switch(cmd){
+  case FBIO_WAITFORVSYNC:
+    break;
+  }
+  return 0;
+}
+ 
+static int myfb_mmap(struct fb_info *info, struct vm_area_struct *vma)
+{
+  const unsigned long offset = vma->vm_pgoff << PAGE_SHIFT;
+  const unsigned long size = vma->vm_end - vma->vm_start;
+  
+  if(offset + size > info->fix.smem_len){
+    return -EINVAL;
+  }
+  
+  if(remap_pfn_range(vma, vma->vm_start, (info->fix.smem_start + offset) >> PAGE_SHIFT, size, vma->vm_page_prot)){
+    return -EAGAIN;
+  }
+  return 0;
+}
+
+static int myfb_pan_display(struct fb_var_screeninfo *var, struct fb_info *info)
+{
+  struct myfb_par *par = info->par;
+  if((var->xoffset != info->var.xoffset) || (var->yoffset != info->var.yoffset)){
+    info->var.xoffset = var->xoffset;
+    info->var.yoffset = var->yoffset;
+    par->yoffset = var->yoffset;
+  }
+  return 0;
+}
+
+static struct fb_ops myfb_ops = {
+  .owner          = THIS_MODULE,
+  .fb_check_var   = myfb_check_var,
+  .fb_set_par     = myfb_set_par,
+  .fb_setcolreg   = myfb_setcolreg,
+  .fb_pan_display = myfb_pan_display,
+  .fb_ioctl       = myfb_ioctl,
+  .fb_mmap        = myfb_mmap,
+ 
+  .fb_fillrect  = sys_fillrect,
+  .fb_copyarea  = sys_copyarea,
+  .fb_imageblit = sys_imageblit,
+};
+
+static int myfb_probe(struct platform_device *device)
+{
+  int i, ret;
+  struct fb_info *info;
+  struct myfb_par *par;
+  struct fb_videomode *mode;
+
+  mode = devm_kzalloc(&device->dev, sizeof(struct fb_videomode), GFP_KERNEL);
+  if(mode == NULL){
+    return -ENOMEM;
+  }
+  mode->name = "320x240";
+  mode->xres = 320;
+  mode->yres = 240;
+  mode->vmode = FB_VMODE_NONINTERLACED; 
+  pm_runtime_enable(&device->dev);
+  pm_runtime_get_sync(&device->dev);
+   
+  info = framebuffer_alloc(sizeof(struct myfb_par), &device->dev);
+  if(!info){
+    dev_dbg(&device->dev, "memory allocation failed for fb_info\n");
+    return -ENOMEM;
+  }
+ 
+  par = info->par;
+  par->pdev = device;
+  par->dev = &device->dev;
+  par->bpp = 16;
+  fb_videomode_to_var(&myfb_var, mode);
+  
+  par->vram_size = 320*240*2*2;
+  par->vram_virt = dma_alloc_coherent(NULL, par->vram_size, (resource_size_t*)&par->vram_phys, GFP_KERNEL | GFP_DMA);
+  if(!par->vram_virt){
+    dev_err(&device->dev, "%s, failed to allocate frame buffer(vram)\n", __func__);
+    return -EINVAL;
+  }
+  info->screen_base = (char __iomem*)par->vram_virt;
+  myfb_fix.smem_start = par->vram_phys;
+  myfb_fix.smem_len = par->vram_size;
+  myfb_fix.line_length = 320 * 2;
+  
+  par->lram_size = 320*240*18;
+  for(i=0; i<LRAM_NUM; i++){
+    par->lram_virt[i] = dma_alloc_coherent(NULL, par->lram_size, (resource_size_t*)&par->lram_phys[i], GFP_KERNEL | GFP_DMA);
+    if(!par->lram_virt[i]){
+      dev_err(&device->dev, "%s, failed to allocate frame buffer(lram[%d])\n", __func__, i);
+      return -EINVAL;
+    }
+  }
+   
+  par->v_palette_base = dma_alloc_coherent(NULL, PALETTE_SIZE, (resource_size_t*)&par->p_palette_base, GFP_KERNEL | GFP_DMA);
+  if(!par->v_palette_base){
+    dev_err(&device->dev, "GLCD: kmalloc for palette buffer failed\n");
+    return -EINVAL;
+  }
+  memset(par->v_palette_base, 0, PALETTE_SIZE);
+  myfb_var.grayscale = 0;
+  myfb_var.bits_per_pixel = par->bpp;
+ 
+  info->flags = FBINFO_FLAG_DEFAULT;
+  info->fix = myfb_fix;
+  info->var = myfb_var;
+  info->fbops = &myfb_ops;
+  info->pseudo_palette = par->pseudo_palette;
+  info->fix.visual = (info->var.bits_per_pixel <= 8) ? FB_VISUAL_PSEUDOCOLOR : FB_VISUAL_TRUECOLOR; 
+  ret = fb_alloc_cmap(&info->cmap, PALETTE_SIZE, 0);
+  if(ret){
+    return -EINVAL;
+  }
+  info->cmap.len = 32;
+ 
+  myfb_var.activate = FB_ACTIVATE_FORCE;
+  fb_set_var(info, &myfb_var);
+  dev_set_drvdata(&device->dev, info);
+
+  if(register_framebuffer(info) < 0){
+    dev_err(&device->dev, "failed to register /dev/fb0\n");
+    return -EINVAL;
+  }
+  
+  mypar = par;
+  new_bp = -1;
+  new_fp = -1;
+  for(ret=0; ret<of_clk_get_parent_count(device->dev.of_node); ret++){
+    clk_prepare_enable(of_clk_get(device->dev.of_node, ret));
+  }
+  suniv_cpu_init(par);
+  suniv_gpio_init();
+  suniv_lcdc_init(par);
+  suniv_enable_irq(par);
+  
+  fb_prepare_logo(info, 0);
+  fb_show_logo(info, 0);
+  return 0;
+}
+ 
+static int myfb_suspend(struct platform_device *dev, pm_message_t state)
+{
+  struct fb_info *info = platform_get_drvdata(dev);
+ 
+  console_lock();
+  fb_set_suspend(info, 1);
+  pm_runtime_put_sync(&dev->dev);
+  console_unlock();
+  return 0;
+}
+ 
+static int myfb_resume(struct platform_device *dev)
+{
+  struct fb_info *info = platform_get_drvdata(dev);
+
+  console_lock();
+  pm_runtime_get_sync(&dev->dev);
+  fb_set_suspend(info, 0);
+  console_unlock();
+  return 0;
+}
+
+static const struct of_device_id fb_of_match[] = {
+  {
+    .compatible = "allwinner,suniv-f1c500s-tcon0", 
+  },{}
+};
+MODULE_DEVICE_TABLE(of, fb_of_match);
+ 
+static struct platform_driver fb_driver = {
+  .probe    = myfb_probe,
+  .remove   = myfb_remove,
+  .suspend  = myfb_suspend,
+  .resume   = myfb_resume,
+  .driver = {
+    .name   = DRIVER_NAME,
+    .owner  = THIS_MODULE,
+    .of_match_table = of_match_ptr(fb_of_match),
+  },
+};
+ 
+static void suniv_ioremap(void)
+{
+  iomm.dma = (uint8_t*)ioremap(SUNIV_DMA_BASE, 4096);
+  iomm.ccm = (uint8_t*)ioremap(SUNIV_CCM_BASE, 4096);
+  iomm.gpio = (uint8_t*)ioremap(SUNIV_GPIO_BASE, 4096);
+  iomm.lcdc = (uint8_t*)ioremap(SUNIV_LCDC_BASE, 4096);
+  iomm.debe = (uint8_t*)ioremap(SUNIV_DEBE_BASE, 4096);
+  iomm.intc = (uint8_t*)ioremap(SUNIV_INTC_BASE, 4096);
+}
+
+static void suniv_iounmap(void)
+{
+  iounmap(iomm.dma);
+  iounmap(iomm.ccm);
+  iounmap(iomm.gpio);
+  iounmap(iomm.lcdc);
+  iounmap(iomm.debe);
+  iounmap(iomm.intc);
+}
+
+static int myopen(struct inode *inode, struct file *file)
+{
+  return 0;
+}
+
+static int myclose(struct inode *inode, struct file *file)
+{
+  return 0;
+}
+
+static long myioctl(struct file *filp, unsigned int cmd, unsigned long arg)
+{
+  int32_t w, bpp;
+  unsigned long tmp;
+
+  switch(cmd){
+  case MIYOO_FB0_PUT_OSD:
+    break;
+  case MIYOO_FB0_SET_MODE:
+    w = (arg >> 16);
+    bpp = (arg & 0xffff);
+    if((bpp != 16)){
+	    writel((5 << 8), iomm.debe + DEBE_LAY0_ATT_CTRL_REG1);
+      writel((5 << 8), iomm.debe + DEBE_LAY1_ATT_CTRL_REG1);
+    }
+    else{
+	    writel((7 << 8) | 4, iomm.debe + DEBE_LAY0_ATT_CTRL_REG1);
+	    writel((7 << 8) | 4, iomm.debe + DEBE_LAY1_ATT_CTRL_REG1);
+    }
+    break;
+  case MIYOO_FB0_GET_VER:
+    break;
+  case MIYOO_FB0_SET_FLIP:
+    break;
+  case MIYOO_FB0_GET_FPBP:
+    tmp = (def_fp & 0x0f) << 12;
+    tmp|= (def_bp & 0x0f) <<  8;
+    tmp|= (new_fp & 0x0f) <<  4;
+    tmp|= (new_bp & 0x0f) <<  0;
+    w = copy_to_user((void*)arg, &tmp, sizeof(unsigned long));
+    break;
+  case MIYOO_FB0_SET_FPBP:
+    new_fp = (arg & 0xf0) >> 4;
+    new_bp = (arg & 0x0f) >> 0;
+	  
+    flip_mode = 1;
+    mdelay(100);
+    panel_init();
+    flip_mode = 0;
+	  suniv_setbits(iomm.debe + DEBE_REGBUFF_CTRL_REG, (1 << 0));
+    break;
+  }
+  return 0;
+}
+
+static const struct file_operations myfops = {
+  .owner = THIS_MODULE,
+  .open = myopen,
+  .release = myclose,
+  .unlocked_ioctl = myioctl,
+};
+
+static int __init fb_init(void)
+{
+  suniv_ioremap();
+    alloc_chrdev_region(&major, 0, 1, "miyoo_fb0");
+    myclass = class_create(THIS_MODULE, "miyoo_fb0");
+    device_create(myclass, NULL, major, NULL, "miyoo_fb0");
+  cdev_init(&mycdev, &myfops);
+  cdev_add(&mycdev, major, 1);
+  return platform_driver_register(&fb_driver);
+}
+ 
+static void __exit fb_cleanup(void)
+{
+  suniv_iounmap();
+  device_destroy(myclass, major);
+  cdev_del(&mycdev);
+  class_destroy(myclass);
+  unregister_chrdev_region(major, 1);
+  platform_driver_unregister(&fb_driver);
+}
+ 
+module_init(fb_init);
+module_exit(fb_cleanup);
+ 
+MODULE_DESCRIPTION("Allwinner suniv framebuffer driver for Miyoo handheld");
+MODULE_AUTHOR("Steward Fu <steward.fu@gmail.com>");
+MODULE_LICENSE("GPL");
diff --git a/drivers/video/fbdev/st7789sTEfb.c b/drivers/video/fbdev/st7789sTEfb.c
new file mode 100644
index 00000000..8924dbce
--- /dev/null
+++ b/drivers/video/fbdev/st7789sTEfb.c
@@ -0,0 +1,835 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option)any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#include <linux/cdev.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/fb.h>
+#include <linux/dma-mapping.h>
+#include <linux/device.h>
+#include <linux/backlight.h>
+#include <linux/platform_device.h>
+#include <linux/uaccess.h>
+#include <linux/pm_runtime.h>
+#include <linux/interrupt.h>
+#include <linux/wait.h>
+#include <linux/clk.h>
+#include <linux/cpufreq.h>
+#include <linux/console.h>
+#include <linux/spinlock.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+#include <linux/lcm.h>
+#include <linux/clk-provider.h>
+#include <video/of_display_timing.h>
+#include <linux/gpio.h>
+#include <linux/omapfb.h>
+#include <linux/compiler.h>
+#include <linux/workqueue.h>
+#include <linux/sched.h>
+#include <asm/io.h>
+#include <asm/gpio.h>
+
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <sound/tlv.h>
+#include <sound/initval.h>
+#include <sound/dmaengine_pcm.h>
+#include <linux/gpio.h>
+
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/gpio.h>
+#include <asm/arch-suniv/cpu.h>
+#include <asm/arch-suniv/dma.h>
+#include <asm/arch-suniv/gpio.h>
+#include <asm/arch-suniv/intc.h>
+#include <asm/arch-suniv/lcdc.h>
+#include <asm/arch-suniv/debe.h>
+#include <asm/arch-suniv/codec.h>
+#include <asm/arch-suniv/clock.h>
+#include <asm/arch-suniv/common.h>
+
+
+#define PALETTE_SIZE 256
+#define DRIVER_NAME  "suniv-fb"
+
+#define FBIO_SET_DEBE_MODE _IOWR(0x1000, 0, unsigned long)
+
+DECLARE_WAIT_QUEUE_HEAD(wait_vsync_queue);
+
+struct myfb_app {
+    uint32_t yoffset;
+    uint32_t vsync_count;
+};
+
+struct myfb_par {
+    struct device *dev;
+    struct platform_device *pdev;
+
+    resource_size_t p_palette_base;
+    unsigned short *v_palette_base;
+
+    void *vram_virt;
+    uint32_t vram_size;
+    dma_addr_t vram_phys;
+
+    struct myfb_app *app_virt;
+
+    int bpp;
+    int lcdc_irq;
+    int gpio_irq;
+    int lcdc_ready;
+    u32 pseudo_palette[16];
+    struct fb_videomode mode;
+};
+
+struct suniv_iomm {
+    uint8_t *dma;
+    uint8_t *ccm;
+    uint8_t *gpio;
+    uint8_t *lcdc;
+    uint8_t *debe;
+    uint8_t *intc;
+    uint8_t *timer;
+};
+static struct timer_list mytimer;
+static struct suniv_iomm iomm = {0};
+static struct myfb_par *mypar = NULL;
+static struct fb_var_screeninfo myfb_var = {0};
+
+static struct fb_fix_screeninfo myfb_fix = {
+    .id = DRIVER_NAME,
+    .type = FB_TYPE_PACKED_PIXELS,
+    .type_aux = 0,
+    .visual = FB_VISUAL_TRUECOLOR,
+    .xpanstep = 0,
+    .ypanstep = 1,
+    .ywrapstep = 0,
+    .accel = FB_ACCEL_NONE
+};
+
+static int wait_for_vsync(struct myfb_par *par)
+{
+    uint32_t count = par->app_virt->vsync_count;
+    long t = wait_event_interruptible_timeout(wait_vsync_queue, count != par->app_virt->vsync_count, HZ / 10);
+    return t > 0 ? 0 : (t < 0 ? (int)t : -ETIMEDOUT);
+}
+
+static void pocketgo_gpio_init(void)
+{
+    uint32_t r = 0;
+
+    r = readl(iomm.gpio + PD_CFG0);
+    r &= 0x0000000f;
+    r |= 0x22222220;
+    writel(r, iomm.gpio + PD_CFG0);
+
+    r = readl(iomm.gpio + PD_CFG1);
+    r &= 0x000000f0;
+    r |= 0x22222202;
+    writel(r, iomm.gpio + PD_CFG1);
+
+    r = readl(iomm.gpio + PD_CFG2);
+    r &= 0xff000000;
+    r |= 0x000222222;
+    writel(r, iomm.gpio + PD_CFG2);
+
+    r = readl(iomm.gpio + PD_PUL1);
+    r &= 0xfffff0ff;
+    r |= 0x00000500;
+    writel(r, iomm.gpio + PD_PUL1);
+
+    r = readl(iomm.gpio + PE_CFG1);
+    r &= 0xffff0fff;
+    r |= 0x00001000;
+    writel(r, iomm.gpio + PE_CFG1);
+
+    suniv_clrbits(iomm.gpio + PE_DATA, (1 << 11));
+    mdelay(150);
+    suniv_setbits(iomm.gpio + PE_DATA, (1 << 11));
+    mdelay(50);
+}
+
+static uint32_t lcdc_wait_busy(void)
+{
+    uint32_t cnt = 0;
+
+    suniv_setbits(iomm.lcdc + TCON0_CPU_IF_REG, (1 << 0));
+    ndelay(10);
+    while(1) {
+        if(readl(iomm.lcdc + TCON0_CPU_IF_REG) & 0x00c00000) {
+            if(cnt > 200) {
+                return -1;
+            }
+            else {
+                cnt += 1;
+            }
+        }
+        break;
+    }
+    return 0;
+}
+
+static uint32_t extend_16b_to_24b(uint32_t value)
+{
+    return ((value & 0xfc00) << 8) | ((value & 0x0300) << 6) | ((value & 0x00e0) << 5) | ((value & 0x001f) << 3);
+}
+
+static void lcdc_wr(uint8_t is_data, uint32_t data)
+{
+    while(lcdc_wait_busy());
+    if(is_data) {
+        suniv_setbits(iomm.lcdc + TCON0_CPU_IF_REG, (1 << 25));
+    }
+    else {
+        suniv_clrbits(iomm.lcdc + TCON0_CPU_IF_REG, (1 << 25));
+    }
+    while(lcdc_wait_busy());
+    writel(extend_16b_to_24b(data), iomm.lcdc + TCON0_CPU_WR_REG);
+}
+
+static void lcdc_wr_cmd(uint32_t cmd)
+{
+    lcdc_wr(0, cmd);
+}
+
+static void lcdc_wr_dat(uint32_t cmd)
+{
+    lcdc_wr(1, cmd);
+}
+
+static void flip_lcd(struct myfb_par *par)
+{
+#if 0
+    static uint32_t report = 0;
+
+    if((report++ % 60) == 0) {
+        printk("%s, vsync\n", __func__);
+    }
+#endif
+    suniv_clrbits(iomm.lcdc + TCON_INT_REG0, (1 << 15));
+    suniv_clrbits(iomm.lcdc + TCON_CTRL_REG, (1 << 31));
+
+    if(par->lcdc_ready) {
+            lcdc_wr_cmd(0x2c);
+
+        if(par->app_virt->yoffset == 0) {
+            suniv_setbits(iomm.debe + DEBE_MODE_CTRL_REG, (1 << 8));
+            suniv_clrbits(iomm.debe + DEBE_MODE_CTRL_REG, (1 << 9));
+            suniv_clrbits(iomm.debe + DEBE_MODE_CTRL_REG, (1 << 10));
+            suniv_clrbits(iomm.debe + DEBE_MODE_CTRL_REG, (1 << 11));
+        }
+        else if(par->app_virt->yoffset == 240) {
+            suniv_clrbits(iomm.debe + DEBE_MODE_CTRL_REG, (1 << 8));
+            suniv_setbits(iomm.debe + DEBE_MODE_CTRL_REG, (1 << 9));
+            suniv_clrbits(iomm.debe + DEBE_MODE_CTRL_REG, (1 << 10));
+            suniv_clrbits(iomm.debe + DEBE_MODE_CTRL_REG, (1 << 11));
+        }
+        else if(par->app_virt->yoffset == 480) {
+            suniv_clrbits(iomm.debe + DEBE_MODE_CTRL_REG, (1 << 8));
+            suniv_clrbits(iomm.debe + DEBE_MODE_CTRL_REG, (1 << 9));
+            suniv_setbits(iomm.debe + DEBE_MODE_CTRL_REG, (1 << 10));
+            suniv_clrbits(iomm.debe + DEBE_MODE_CTRL_REG, (1 << 11));
+        }
+        else if(par->app_virt->yoffset == 720) {
+            suniv_clrbits(iomm.debe + DEBE_MODE_CTRL_REG, (1 << 8));
+            suniv_clrbits(iomm.debe + DEBE_MODE_CTRL_REG, (1 << 9));
+            suniv_clrbits(iomm.debe + DEBE_MODE_CTRL_REG, (1 << 10));
+            suniv_setbits(iomm.debe + DEBE_MODE_CTRL_REG, (1 << 11));
+        }
+    }
+    suniv_setbits(iomm.debe + DEBE_REGBUFF_CTRL_REG, (1 << 0));
+    suniv_setbits(iomm.lcdc + TCON_CTRL_REG, (1 << 31));
+
+    par->app_virt->vsync_count += 1;
+    wake_up_interruptible_all(&wait_vsync_queue);
+}
+
+static irqreturn_t gpio_irq_handler(int irq, void *arg)
+{
+    flip_lcd(arg);
+    return IRQ_HANDLED;
+}
+
+static irqreturn_t lcdc_irq_handler(int irq, void *arg) {
+    suniv_clrbits(iomm.lcdc + TCON_INT_REG0, (1 << 15));
+    return IRQ_HANDLED;
+}
+
+static void pocketgo_lcd_init(void)
+{
+    pocketgo_gpio_init();
+
+    lcdc_wr_cmd(0x11);
+    mdelay(250);
+
+    lcdc_wr_cmd(0x36);
+    lcdc_wr_dat(0xB0);
+
+    lcdc_wr_cmd(0x3a);
+    lcdc_wr_dat(0x05);
+
+    lcdc_wr_cmd(0x2a);
+    lcdc_wr_dat(0x00);
+    lcdc_wr_dat(0x00);
+    lcdc_wr_dat(0x01);
+    lcdc_wr_dat(0x3f);
+
+    lcdc_wr_cmd(0x2b);
+    lcdc_wr_dat(0x00);
+    lcdc_wr_dat(0x00);
+    lcdc_wr_dat(0x00);
+    lcdc_wr_dat(0xef);
+
+    // ST7789S Frame rate setting
+    lcdc_wr_cmd(0xb2);
+    lcdc_wr_dat(90);
+    lcdc_wr_dat(127);
+    lcdc_wr_dat(0x01);
+    lcdc_wr_dat(0x33);
+    lcdc_wr_dat(0x33);
+
+    // Gate Control
+    lcdc_wr_cmd(0xb7);
+    lcdc_wr_dat(0x35);
+
+    // ?
+    lcdc_wr_cmd(0xb8);
+    lcdc_wr_dat(0x2f);
+    lcdc_wr_dat(0x2b);
+    lcdc_wr_dat(0x2f);
+
+    // ST7789S Power setting
+    lcdc_wr_cmd(0xbb);
+    lcdc_wr_dat(0x15);
+
+    lcdc_wr_cmd(0xc0);
+    lcdc_wr_dat(0x3c);
+
+    lcdc_wr_cmd(0x35);
+    lcdc_wr_dat(0x00);
+
+    lcdc_wr_cmd(0xc2);
+    lcdc_wr_dat(0x01);
+
+    lcdc_wr_cmd(0xc3);
+    lcdc_wr_dat(0x13);
+
+    lcdc_wr_cmd(0xc4);
+    lcdc_wr_dat(0x20);
+
+    lcdc_wr_cmd(0xc6);
+    lcdc_wr_dat(0x01); // 0x04, 0x1f
+
+    lcdc_wr_cmd(0xd0);
+    lcdc_wr_dat(0xa4);
+    lcdc_wr_dat(0xa1);
+
+    lcdc_wr_cmd(0xe8);
+    lcdc_wr_dat(0x03);
+
+    lcdc_wr_cmd(0xe9);
+    lcdc_wr_dat(0x0d);
+    lcdc_wr_dat(0x12);
+    lcdc_wr_dat(0x00);
+
+    // ST7789S gamma setting
+    lcdc_wr_cmd(0xe0);
+    lcdc_wr_dat(0x70);
+    lcdc_wr_dat(0x00);
+    lcdc_wr_dat(0x06);
+    lcdc_wr_dat(0x09);
+    lcdc_wr_dat(0x0b);
+    lcdc_wr_dat(0x2a);
+    lcdc_wr_dat(0x3c);
+    lcdc_wr_dat(0x33);
+    lcdc_wr_dat(0x4b);
+    lcdc_wr_dat(0x08);
+    lcdc_wr_dat(0x16);
+    lcdc_wr_dat(0x14);
+    lcdc_wr_dat(0x2a);
+    lcdc_wr_dat(0x23);
+
+    lcdc_wr_cmd(0xe1);
+    lcdc_wr_dat(0xd0);
+    lcdc_wr_dat(0x00);
+    lcdc_wr_dat(0x06);
+    lcdc_wr_dat(0x09);
+    lcdc_wr_dat(0x0b);
+    lcdc_wr_dat(0x29);
+    lcdc_wr_dat(0x36);
+    lcdc_wr_dat(0x54);
+    lcdc_wr_dat(0x4b);
+    lcdc_wr_dat(0x0d);
+    lcdc_wr_dat(0x16);
+    lcdc_wr_dat(0x14);
+    lcdc_wr_dat(0x28);
+    lcdc_wr_dat(0x22);
+
+    mdelay(50);
+    lcdc_wr_cmd(0x29);
+    mdelay(50);
+    lcdc_wr_cmd(0x2c);
+    mdelay(100);
+}
+
+static void smartlcd_init(struct myfb_par *par)
+{
+    uint32_t ret=0, bp=0, total=0, ver=0;
+    uint32_t h_front_porch = 8;
+    uint32_t h_back_porch = 8;
+    uint32_t h_sync_len = 1;
+    uint32_t v_front_porch = 8;
+    uint32_t v_back_porch = 8;
+    uint32_t v_sync_len = 1;
+
+    writel(0, iomm.lcdc + TCON_CTRL_REG);
+    writel(0, iomm.lcdc + TCON_INT_REG0);
+    ret = readl(iomm.lcdc + TCON_CLK_CTRL_REG);
+    ret &= ~(0xf << 28);
+    writel(ret, iomm.lcdc + TCON_CLK_CTRL_REG);
+    writel(0xffffffff, iomm.lcdc + TCON0_IO_CTRL_REG1);
+    writel(0xffffffff, iomm.lcdc + TCON1_IO_CTRL_REG1);
+
+    suniv_setbits(iomm.debe + DEBE_MODE_CTRL_REG, (1 << 0));
+    writel(par->mode.xres << 4, iomm.debe + DEBE_LAY0_LINEWIDTH_REG);
+    writel(par->mode.xres << 4, iomm.debe + DEBE_LAY1_LINEWIDTH_REG);
+    writel(par->mode.xres << 4, iomm.debe + DEBE_LAY2_LINEWIDTH_REG);
+    writel(par->mode.xres << 4, iomm.debe + DEBE_LAY3_LINEWIDTH_REG);
+    writel((((par->mode.yres) - 1) << 16) | (((par->mode.xres) - 1) << 0), iomm.debe + DEBE_DISP_SIZE_REG);
+    writel((((par->mode.yres) - 1) << 16) | (((par->mode.xres) - 1) << 0), iomm.debe + DEBE_LAY0_SIZE_REG);
+    writel((((par->mode.yres) - 1) << 16) | (((par->mode.xres) - 1) << 0), iomm.debe + DEBE_LAY1_SIZE_REG);
+    writel((((par->mode.yres) - 1) << 16) | (((par->mode.xres) - 1) << 0), iomm.debe + DEBE_LAY2_SIZE_REG);
+    writel((((par->mode.yres) - 1) << 16) | (((par->mode.xres) - 1) << 0), iomm.debe + DEBE_LAY3_SIZE_REG);
+    writel((5 << 8), iomm.debe + DEBE_LAY0_ATT_CTRL_REG1);
+    writel((5 << 8), iomm.debe + DEBE_LAY1_ATT_CTRL_REG1);
+    writel((5 << 8), iomm.debe + DEBE_LAY2_ATT_CTRL_REG1);
+    writel((5 << 8), iomm.debe + DEBE_LAY3_ATT_CTRL_REG1);
+    suniv_setbits(iomm.debe + DEBE_MODE_CTRL_REG, (1 << 8));
+    suniv_setbits(iomm.debe + DEBE_REGBUFF_CTRL_REG, (1 << 1));
+    suniv_setbits(iomm.debe + DEBE_MODE_CTRL_REG, (1 << 1));
+
+    ret = readl(iomm.lcdc + TCON_CTRL_REG);
+    ret &= ~(1 << 0);
+    writel(ret, iomm.lcdc + TCON_CTRL_REG);
+    ret = (1 + 1 + 1);
+
+    writel((uint32_t)(par->vram_phys + 320 * 240 * 2 * 0) << 3, iomm.debe + DEBE_LAY0_FB_ADDR_REG);
+    writel((uint32_t)(par->vram_phys + 320 * 240 * 2 * 1) << 3, iomm.debe + DEBE_LAY1_FB_ADDR_REG);
+    writel((uint32_t)(par->vram_phys + 320 * 240 * 2 * 2) << 3, iomm.debe + DEBE_LAY2_FB_ADDR_REG);
+    writel((uint32_t)(par->vram_phys + 320 * 240 * 2 * 3) << 3, iomm.debe + DEBE_LAY3_FB_ADDR_REG);
+
+    writel((uint32_t)(par->vram_phys + 320 * 240 * 2 * 0) >> 29, iomm.debe + DEBE_LAY0_FB_HI_ADDR_REG);
+    writel((uint32_t)(par->vram_phys + 320 * 240 * 2 * 1) >> 29, iomm.debe + DEBE_LAY1_FB_HI_ADDR_REG);
+    writel((uint32_t)(par->vram_phys + 320 * 240 * 2 * 2) >> 29, iomm.debe + DEBE_LAY2_FB_HI_ADDR_REG);
+    writel((uint32_t)(par->vram_phys + 320 * 240 * 2 * 3) >> 29, iomm.debe + DEBE_LAY3_FB_HI_ADDR_REG);
+
+    writel((1 << 31) | ((ret & 0x1f) << 4) | (1 << 24), iomm.lcdc + TCON0_CTRL_REG);
+    writel((0xf << 28) | (6 << 0), iomm.lcdc + TCON_CLK_CTRL_REG);
+    writel((4 << 29) | (1 << 26), iomm.lcdc + TCON0_CPU_IF_REG);
+    writel((1 << 28), iomm.lcdc + TCON0_IO_CTRL_REG0);
+
+    writel(((par->mode.xres - 1) << 16) | ((par->mode.yres - 1) << 0), iomm.lcdc + TCON0_BASIC_TIMING_REG0);
+    bp = h_sync_len + h_back_porch;
+    total = par->mode.xres * 1 + h_front_porch + bp;
+    writel(((total - 1) << 16) | ((bp - 1) << 0), iomm.lcdc + TCON0_BASIC_TIMING_REG1);
+    bp = v_sync_len + v_back_porch;
+    total = par->mode.yres + v_front_porch + bp;
+    writel(((total * 2) << 16) | ((bp - 1) << 0), iomm.lcdc + TCON0_BASIC_TIMING_REG2);
+    writel(((h_sync_len - 1) << 16) | ((v_sync_len - 1) << 0), iomm.lcdc + TCON0_BASIC_TIMING_REG3);
+
+    writel(0, iomm.lcdc + TCON0_HV_TIMING_REG);
+    writel(0, iomm.lcdc + TCON0_IO_CTRL_REG1);
+
+    suniv_setbits(iomm.lcdc + TCON_CTRL_REG, (1 << 31));
+    pocketgo_lcd_init();
+
+    suniv_setbits(iomm.lcdc + TCON_INT_REG0, (1 << 31));
+    suniv_setbits(iomm.lcdc + TCON0_CPU_IF_REG, (1 << 28));
+}
+
+static void suniv_enable_irq(struct myfb_par *par)
+{
+    int ret = 0;
+
+    par->lcdc_irq = platform_get_irq(par->pdev, 0);
+    if(par->lcdc_irq < 0) {
+        printk("%s, failed to get irq number for lcdc irq\n", __func__);
+    }
+    else {
+        ret = request_irq(par->lcdc_irq, lcdc_irq_handler, IRQF_SHARED, "lcdc_irq", par);
+        if(ret) {
+            printk("%s, failed to register lcdc interrupt(%d)\n", __func__, par->lcdc_irq);
+        }
+    }
+
+        par->gpio_irq = gpio_to_irq(((32 * 4) + 10));
+        if(par->gpio_irq < 0) {
+            printk("%s, failed to get irq number for gpio irq\n", __func__);
+        }
+        else {
+            ret = request_irq(par->gpio_irq, gpio_irq_handler, IRQF_TRIGGER_RISING, "gpio_irq", par);
+            if(ret) {
+                printk("%s, failed to register gpio interrupt(%d)\n", __func__, par->gpio_irq);
+            }
+        }
+}
+
+static void suniv_cpu_init(struct myfb_par *par)
+{
+    uint32_t ret, i;
+    writel(0x91001307, iomm.ccm + PLL_VIDEO_CTRL_REG);
+    while((readl(iomm.ccm + PLL_VIDEO_CTRL_REG) & (1 << 28)) == 0){}
+    while((readl(iomm.ccm + PLL_PERIPH_CTRL_REG) & (1 << 28)) == 0){}
+
+    ret = readl(iomm.ccm + DRAM_GATING_REG);
+    ret |= (1 << 26) | (1 << 24);
+    writel(ret, iomm.ccm + DRAM_GATING_REG);
+
+    suniv_setbits(iomm.ccm + FE_CLK_REG, (1 << 31));
+    suniv_setbits(iomm.ccm + BE_CLK_REG, (1 << 31));
+    suniv_setbits(iomm.ccm + TCON_CLK_REG, (1 << 31) | (1 << 25));
+    suniv_setbits(iomm.ccm + BUS_CLK_GATING_REG1, (1 << 14) | (1 << 12) | (1 << 4));
+    suniv_setbits(iomm.ccm + BUS_SOFT_RST_REG1, (1 << 14) | (1 << 12) | (1 << 4));
+    for(i = 0x0800; i < 0x1000; i += 4) {
+        writel(0, iomm.debe + i);
+    }
+}
+
+static void lcd_delay_init(unsigned long param)
+{
+    suniv_cpu_init(mypar);
+        smartlcd_init(mypar);
+    mypar->app_virt->yoffset = 0;        // Show Kernel msg
+    mypar->lcdc_ready = 1;
+    suniv_enable_irq(mypar);
+
+}
+
+#define CNVT_TOHW(val, width) ((((val) << (width)) + 0x7FFF - (val)) >> 16)
+static int myfb_setcolreg(unsigned regno, unsigned red, unsigned green, unsigned blue, unsigned transp, struct fb_info *info)
+{
+    red = CNVT_TOHW(red, info->var.red.length);
+    blue = CNVT_TOHW(blue, info->var.blue.length);
+    green = CNVT_TOHW(green, info->var.green.length);
+    ((u32 *)(info->pseudo_palette))[regno] = (red << info->var.red.offset) | (green << info->var.green.offset) | (blue << info->var.blue.offset);
+    return 0;
+}
+#undef CNVT_TOHW
+
+static int myfb_check_var(struct fb_var_screeninfo *var, struct fb_info *info)
+{
+    int bpp = var->bits_per_pixel >> 3;
+    struct myfb_par *par = info->par;
+    unsigned long line_size = var->xres_virtual * bpp;
+
+    if((var->xres != 320) || (var->yres != 240) || (var->bits_per_pixel != 16)) {
+        return -EINVAL;
+    }
+
+    var->transp.offset = 0;
+    var->transp.length = 0;
+    var->red.offset = 11;
+    var->red.length = 5;
+    var->green.offset = 5;
+    var->green.length = 6;
+    var->blue.offset = 0;
+    var->blue.length = 5;
+    var->red.msb_right = 0;
+    var->green.msb_right = 0;
+    var->blue.msb_right = 0;
+    var->transp.msb_right = 0;
+    if(line_size * var->yres_virtual > par->vram_size) {
+        var->yres_virtual = par->vram_size / line_size;
+    }
+    if(var->yres > var->yres_virtual) {
+        var->yres = var->yres_virtual;
+    }
+    if(var->xres > var->xres_virtual) {
+        var->xres = var->xres_virtual;
+    }
+    if(var->xres + var->xoffset > var->xres_virtual) {
+        var->xoffset = var->xres_virtual - var->xres;
+    }
+    if(var->yres + var->yoffset > var->yres_virtual) {
+        var->yoffset = var->yres_virtual - var->yres;
+    }
+    return 0;
+}
+
+static int myfb_set_par(struct fb_info *info)
+{
+    struct myfb_par *par = info->par;
+
+    fb_var_to_videomode(&par->mode, &info->var);
+    par->app_virt->yoffset = info->var.yoffset = 0;
+    par->bpp = info->var.bits_per_pixel;
+    info->fix.visual = FB_VISUAL_TRUECOLOR;
+    info->fix.line_length = (par->mode.xres * par->bpp) / 8;
+
+    writel((5 << 8), iomm.debe + DEBE_LAY0_ATT_CTRL_REG1);
+    writel((5 << 8), iomm.debe + DEBE_LAY1_ATT_CTRL_REG1);
+    writel((5 << 8), iomm.debe + DEBE_LAY2_ATT_CTRL_REG1);
+    writel((5 << 8), iomm.debe + DEBE_LAY3_ATT_CTRL_REG1);
+    return 0;
+}
+
+static int myfb_ioctl(struct fb_info *info, unsigned int cmd, unsigned long arg)
+{
+    struct myfb_par *par = info->par;
+
+    switch(cmd) {
+    case FBIO_WAITFORVSYNC:
+        wait_for_vsync(par);
+        break;
+    case FBIO_SET_DEBE_MODE:
+        if(arg == 1) {
+            writel((7 << 8) | 4, iomm.debe + DEBE_LAY0_ATT_CTRL_REG1);
+            writel((7 << 8) | 4, iomm.debe + DEBE_LAY1_ATT_CTRL_REG1);
+            writel((7 << 8) | 4, iomm.debe + DEBE_LAY2_ATT_CTRL_REG1);
+            writel((7 << 8) | 4, iomm.debe + DEBE_LAY3_ATT_CTRL_REG1);
+        }
+        else {
+            writel((5 << 8), iomm.debe + DEBE_LAY0_ATT_CTRL_REG1);
+            writel((5 << 8), iomm.debe + DEBE_LAY1_ATT_CTRL_REG1);
+            writel((5 << 8), iomm.debe + DEBE_LAY2_ATT_CTRL_REG1);
+            writel((5 << 8), iomm.debe + DEBE_LAY3_ATT_CTRL_REG1);
+        }
+        break;
+    default:
+        return -1;
+    }
+    return 0;
+}
+
+static int myfb_mmap(struct fb_info *info, struct vm_area_struct *vma)
+{
+    const unsigned long offset = vma->vm_pgoff << PAGE_SHIFT;
+    const unsigned long size = vma->vm_end - vma->vm_start;
+
+    if(offset + size > info->fix.smem_len) {
+        return -EINVAL;
+    }
+
+    if(remap_pfn_range(vma, vma->vm_start, (info->fix.smem_start + offset) >> PAGE_SHIFT, size, vma->vm_page_prot)) {
+        return -EAGAIN;
+    }
+    return 0;
+}
+
+static int myfb_pan_display(struct fb_var_screeninfo *var, struct fb_info *info)
+{
+    struct myfb_par *par = info->par;
+
+    info->var.xoffset = var->xoffset;
+    info->var.yoffset = var->yoffset;
+    par->app_virt->yoffset = var->yoffset;
+    return 0;
+}
+
+static struct fb_ops myfb_ops = {
+    .owner          = THIS_MODULE,
+    .fb_check_var   = myfb_check_var,
+    .fb_set_par     = myfb_set_par,
+    .fb_setcolreg   = myfb_setcolreg,
+    .fb_pan_display = myfb_pan_display,
+    .fb_ioctl       = myfb_ioctl,
+    .fb_mmap        = myfb_mmap,
+
+    .fb_fillrect  = sys_fillrect,
+    .fb_copyarea  = sys_copyarea,
+    .fb_imageblit = sys_imageblit,
+};
+
+static int myfb_probe(struct platform_device *device)
+{
+    int ret = 0;
+    struct fb_info *info = NULL;
+    struct myfb_par *par = NULL;
+    struct fb_videomode *mode = NULL;
+
+    mode = devm_kzalloc(&device->dev, sizeof(struct fb_videomode), GFP_KERNEL);
+    if(mode == NULL) {
+        return -ENOMEM;
+    }
+    mode->name = "320x240";
+    mode->xres = 320;
+    mode->yres = 240;
+    mode->vmode = FB_VMODE_NONINTERLACED;
+    pm_runtime_enable(&device->dev);
+    pm_runtime_get_sync(&device->dev);
+
+    info = framebuffer_alloc(sizeof(struct myfb_par), &device->dev);
+    if(!info) {
+        return -ENOMEM;
+    }
+
+    par = info->par;
+    par->pdev = device;
+    par->dev = &device->dev;
+    par->bpp = 16;
+    fb_videomode_to_var(&myfb_var, mode);
+
+    par->vram_size = (320 * 240 * 2 * 4) + 4096;
+    par->vram_virt = dma_alloc_coherent(NULL, par->vram_size, (resource_size_t *)&par->vram_phys, GFP_KERNEL | GFP_DMA);
+    if(!par->vram_virt) {
+        return -EINVAL;
+    }
+    info->screen_base = (char __iomem *)par->vram_virt;
+    myfb_fix.smem_start = par->vram_phys;
+    myfb_fix.smem_len = par->vram_size;
+    myfb_fix.line_length = 320 * 2;
+    par->app_virt = (struct myfb_app *)((uint8_t *)par->vram_virt + (320 * 240 * 2 * 4));
+
+    par->v_palette_base = dma_alloc_coherent(NULL, PALETTE_SIZE, (resource_size_t *)&par->p_palette_base, GFP_KERNEL | GFP_DMA);
+    if(!par->v_palette_base) {
+        return -EINVAL;
+    }
+    memset(par->v_palette_base, 0, PALETTE_SIZE);
+    myfb_var.grayscale = 0;
+    myfb_var.bits_per_pixel = par->bpp;
+
+    info->flags = FBINFO_FLAG_DEFAULT;
+    info->fix = myfb_fix;
+    info->var = myfb_var;
+    info->fbops = &myfb_ops;
+    info->pseudo_palette = par->pseudo_palette;
+    info->fix.visual = (info->var.bits_per_pixel <= 8) ? FB_VISUAL_PSEUDOCOLOR : FB_VISUAL_TRUECOLOR;
+    ret = fb_alloc_cmap(&info->cmap, PALETTE_SIZE, 0);
+    if(ret) {
+        return -EINVAL;
+    }
+    info->cmap.len = 32;
+
+    myfb_var.activate = FB_ACTIVATE_FORCE;
+    fb_set_var(info, &myfb_var);
+    dev_set_drvdata(&device->dev, info);
+    if(register_framebuffer(info) < 0) {
+        return -EINVAL;
+    }
+
+    mypar = par;
+    mypar->lcdc_ready = 0;
+    mypar->app_virt->vsync_count = 0;
+    for(ret = 0; ret < of_clk_get_parent_count(device->dev.of_node); ret++) {
+        clk_prepare_enable(of_clk_get(device->dev.of_node, ret));
+    }
+
+
+    setup_timer(&mytimer, lcd_delay_init, 0);
+    mod_timer(&mytimer, jiffies + HZ);
+    return 0;
+}
+
+static int myfb_remove(struct platform_device *dev)
+{
+    struct fb_info *info = dev_get_drvdata(&dev->dev);
+    struct myfb_par *par = info->par;
+
+    if(info) {
+        free_irq(par->lcdc_irq, par);
+        free_irq(par->gpio_irq, par);
+        del_timer(&mytimer);
+        flush_scheduled_work();
+        unregister_framebuffer(info);
+        fb_dealloc_cmap(&info->cmap);
+        dma_free_coherent(NULL, PALETTE_SIZE, par->v_palette_base, par->p_palette_base);
+        dma_free_coherent(NULL, par->vram_size, par->vram_virt, par->vram_phys);
+        pm_runtime_put_sync(&dev->dev);
+        pm_runtime_disable(&dev->dev);
+        framebuffer_release(info);
+    }
+    return 0;
+}
+
+static int myfb_suspend(struct platform_device *dev, pm_message_t state)
+{
+    struct fb_info *info = platform_get_drvdata(dev);
+
+    console_lock();
+    fb_set_suspend(info, 1);
+    pm_runtime_put_sync(&dev->dev);
+    console_unlock();
+    return 0;
+}
+
+static int myfb_resume(struct platform_device *dev)
+{
+    struct fb_info *info = platform_get_drvdata(dev);
+
+    console_lock();
+    pm_runtime_get_sync(&dev->dev);
+    fb_set_suspend(info, 0);
+    console_unlock();
+    return 0;
+}
+
+static const struct of_device_id fb_of_match[] = {
+        {
+                .compatible = "allwinner,suniv-f1c500s-tcon0",
+        },{}
+};
+MODULE_DEVICE_TABLE(of, fb_of_match);
+
+static struct platform_driver fb_driver = {
+    .probe    = myfb_probe,
+    .remove   = myfb_remove,
+    .suspend  = myfb_suspend,
+    .resume   = myfb_resume,
+    .driver = {
+        .name   = DRIVER_NAME,
+        .owner  = THIS_MODULE,
+        .of_match_table = of_match_ptr(fb_of_match),
+    },
+};
+
+static void suniv_ioremap(void)
+{
+    iomm.ccm = (uint8_t *)ioremap(SUNIV_CCM_BASE, 1024);
+    iomm.gpio = (uint8_t *)ioremap(SUNIV_GPIO_BASE, 1024);
+    iomm.lcdc = (uint8_t *)ioremap(SUNIV_LCDC_BASE, 1024);
+    iomm.debe = (uint8_t *)ioremap(SUNIV_DEBE_BASE, 4096);
+}
+
+static void suniv_iounmap(void)
+{
+    iounmap(iomm.ccm);
+    iounmap(iomm.gpio);
+    iounmap(iomm.lcdc);
+    iounmap(iomm.debe);
+}
+
+static int __init fb_init(void)
+{
+    suniv_ioremap();
+    return platform_driver_register(&fb_driver);
+}
+
+static void __exit fb_cleanup(void)
+{
+    suniv_iounmap();
+    platform_driver_unregister(&fb_driver);
+}
+
+module_init(fb_init);
+module_exit(fb_cleanup);
+
+MODULE_DESCRIPTION("framebuffer driver for allwinner suniv handheld");
+MODULE_AUTHOR("Steward Fu <steward.fu@gmail.com>");
+MODULE_LICENSE("GPL");
diff --git a/drivers/video/fbdev/st7789sfb.c b/drivers/video/fbdev/st7789sfb.c
new file mode 100644
index 00000000..e8fbfebe
--- /dev/null
+++ b/drivers/video/fbdev/st7789sfb.c
@@ -0,0 +1,985 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option)any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#include <linux/cdev.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/fb.h>
+#include <linux/dma-mapping.h>
+#include <linux/device.h>
+#include <linux/backlight.h>
+#include <linux/platform_device.h>
+#include <linux/uaccess.h>
+#include <linux/pm_runtime.h>
+#include <linux/interrupt.h>
+#include <linux/wait.h>
+#include <linux/clk.h>
+#include <linux/cpufreq.h>
+#include <linux/console.h>
+#include <linux/spinlock.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+#include <linux/lcm.h>
+#include <linux/clk-provider.h>
+#include <video/of_display_timing.h>
+#include <linux/gpio.h>
+#include <linux/omapfb.h>
+#include <linux/compiler.h>
+#include <linux/workqueue.h>
+#include <linux/sched.h>
+#include <asm/io.h>
+#include <asm/gpio.h>
+
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <sound/tlv.h>
+#include <sound/initval.h>
+#include <sound/dmaengine_pcm.h>
+#include <linux/gpio.h>
+
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/gpio.h>
+#include <asm/arch-suniv/cpu.h>
+#include <asm/arch-suniv/dma.h>
+#include <asm/arch-suniv/gpio.h>
+#include <asm/arch-suniv/intc.h>
+#include <asm/arch-suniv/lcdc.h>
+#include <asm/arch-suniv/debe.h>
+#include <asm/arch-suniv/codec.h>
+#include <asm/arch-suniv/clock.h>
+#include <asm/arch-suniv/common.h>
+
+//#define DEBUG
+#define PALETTE_SIZE 256
+#define DRIVER_NAME  "ST7789S-fb"
+#define MIYOO_FB0_PUT_OSD     _IOWR(0x100, 0, unsigned long)
+#define MIYOO_FB0_SET_MODE    _IOWR(0x101, 0, unsigned long)
+#define MIYOO_FB0_GET_VER     _IOWR(0x102, 0, unsigned long)
+#define MIYOO_FB0_SET_FPBP    _IOWR(0x104, 0, unsigned long)
+#define MIYOO_FB0_SET_TEFIX   _IOWR(0x106, 0, unsigned long)
+#define MIYOO_FB0_GET_TEFIX   _IOWR(0x107, 0, unsigned long)
+DECLARE_WAIT_QUEUE_HEAD(wait_vsync_queue);
+
+static bool flip=false;
+module_param(flip,bool,0660);
+
+static bool lowcurrent=false;
+module_param(lowcurrent,bool,0660);
+
+static int tefix = 0; //DEFAULT_TEFIX
+module_param(tefix,int,0660);
+
+static bool invert=false;
+module_param(invert,bool,0660);
+
+struct myfb_app{
+    uint32_t yoffset;
+    uint32_t vsync_count;
+};
+
+struct myfb_par {
+    struct device *dev;
+    struct platform_device *pdev;
+
+    resource_size_t p_palette_base;
+    unsigned short *v_palette_base;
+
+    void *vram_virt;
+    uint32_t vram_size;
+    dma_addr_t vram_phys;
+    struct myfb_app *app_virt;
+
+    int bpp;
+    int lcdc_irq;
+    int gpio_irq;
+    int lcdc_ready;
+    u32 pseudo_palette[16];
+    struct fb_videomode mode;
+};
+
+struct suniv_iomm {
+    uint8_t *dma;
+    uint8_t *ccm;
+    uint8_t *gpio;
+    uint8_t *lcdc;
+    uint8_t *debe;
+    uint8_t *intc;
+    uint8_t *timer;
+};
+
+static int major = -1;
+static struct cdev mycdev;
+static struct class *myclass = NULL;
+static uint32_t miyoo_ver = 2;
+struct timer_list mytimer;
+static struct suniv_iomm iomm={0};
+static struct myfb_par *mypar=NULL;
+static struct fb_var_screeninfo myfb_var={0};
+static uint16_t lastScanLine = 120;
+static uint16_t  firstScanLine = 5;
+uint16_t x, i, scanline, vsync;
+uint32_t cpu_clock;
+uint32_t video_clock;
+
+static struct fb_fix_screeninfo myfb_fix = {
+        .id = DRIVER_NAME,
+        .type = FB_TYPE_PACKED_PIXELS,
+        .type_aux = 0,
+        .visual = FB_VISUAL_TRUECOLOR,
+        .xpanstep = 0,
+        .ypanstep = 1,
+        .ywrapstep = 0,
+        .accel = FB_ACCEL_NONE
+};
+
+static int wait_for_vsync(struct myfb_par *par)
+{
+    uint32_t count = par->app_virt->vsync_count;
+    long t = wait_event_interruptible_timeout(wait_vsync_queue, count != par->app_virt->vsync_count, HZ / 10);
+    return t > 0 ? 0 : (t < 0 ? (int)t : -ETIMEDOUT);
+}
+
+static void suniv_gpio_init(void)
+{
+    uint32_t r=0;
+
+    r = readl(iomm.gpio + PD_CFG0);
+    r&= 0x0000000f;
+    r|= 0x22222220;
+    writel(r, iomm.gpio + PD_CFG0);
+
+    r = readl(iomm.gpio + PD_CFG1);
+    r&= 0x000000f0;
+    r|= 0x22222202;
+    writel(r, iomm.gpio + PD_CFG1);
+
+    r = readl(iomm.gpio + PD_CFG2);
+    r&= 0x00000000;
+    r|= 0x22222222;
+    writel(r, iomm.gpio + PD_CFG2);
+
+    if (lowcurrent) {
+    writel(0x00000000, iomm.gpio + PD_DRV0);
+    }
+
+    r = readl(iomm.gpio + PD_PUL1);
+    r&= 0xfffff0ff;
+    r|= 0x00000500;
+    writel(r, iomm.gpio + PD_PUL1);
+
+    r = readl(iomm.gpio + PE_CFG1);
+    r&= 0xffff0fff;
+    r|= 0x00001000;
+    writel(r, iomm.gpio + PE_CFG1);
+    writel(0xffffffff, iomm.gpio + PE_DATA);
+}
+
+static uint32_t lcdc_wait_busy(void)
+{
+    uint32_t cnt=0;
+
+    suniv_setbits(iomm.lcdc + TCON0_CPU_IF_REG, (1 << 0));
+    ndelay(10);
+    while (1) {
+        if (readl(iomm.lcdc + TCON0_CPU_IF_REG) & 0x00c00000) {
+            if (cnt > 200) {
+                return -1;
+            } else {
+                cnt+= 1;
+            }
+        }
+        break;
+    }
+    return 0;
+}
+
+static uint32_t extend_16b_to_24b(uint32_t value)
+{
+    return ((value & 0xfc00) << 8) | ((value & 0x0300) << 6) | ((value & 0x00e0) << 5) | ((value & 0x001f) << 3);
+}
+
+static void lcdc_wr(uint8_t is_data, uint32_t data)
+{
+    while (lcdc_wait_busy());
+    if (is_data) {
+        suniv_setbits(iomm.lcdc + TCON0_CPU_IF_REG, (1 << 25));
+    } else {
+        suniv_clrbits(iomm.lcdc + TCON0_CPU_IF_REG, (1 << 25));
+    }
+    while (lcdc_wait_busy());
+    writel(extend_16b_to_24b(data), iomm.lcdc + TCON0_CPU_WR_REG);
+}
+
+static void lcdc_wr_cmd(uint32_t cmd)
+{
+    lcdc_wr(0, cmd);
+}
+
+static void lcdc_wr_dat(uint32_t cmd)
+{
+    lcdc_wr(1, cmd);
+}
+
+static uint32_t extend_24b_to_16b(uint32_t value)
+{
+    return ((value & 0xfc0000) >> 8) | ((value & 0xc000) >> 6) | ((value & 0x1c00) >> 5) | ((value & 0x00f8) >> 3);
+}
+
+static uint32_t lcdc_rd_dat(void)
+{
+	while (lcdc_wait_busy());
+	suniv_setbits(iomm.lcdc + TCON0_CPU_IF_REG, (1 << 25)); // ca=1
+	while (lcdc_wait_busy());
+	return extend_24b_to_16b(readl(iomm.lcdc + TCON0_CPU_RD_REG));
+}
+
+static void refresh_lcd(struct myfb_par *par)
+{
+    if (par->lcdc_ready) {
+        lcdc_wr_cmd(0x2c);
+  
+        if (par->app_virt->yoffset == 0) {
+	        suniv_setbits(iomm.debe + DEBE_MODE_CTRL_REG, (1 << 8));
+	        suniv_clrbits(iomm.debe + DEBE_MODE_CTRL_REG, (1 << 9));
+        } else {
+	        suniv_clrbits(iomm.debe + DEBE_MODE_CTRL_REG, (1 << 8));
+	        suniv_setbits(iomm.debe + DEBE_MODE_CTRL_REG, (1 << 9));
+        }
+	    suniv_setbits(iomm.debe + DEBE_REGBUFF_CTRL_REG, (1 << 0));
+    }
+}
+
+static irqreturn_t gpio_irq_handler(int irq, void *arg)
+{
+    refresh_lcd(arg);
+    return IRQ_HANDLED;
+}
+
+static irqreturn_t lcdc_irq_handler(int irq, void *arg)
+{
+	if (tefix != 0) {
+      suniv_clrbits(iomm.lcdc + TCON0_CPU_IF_REG, (1 << 28));
+          lcdc_wr_cmd(0x45);
+          lcdc_rd_dat();
+          lcdc_rd_dat();
+          cpu_clock = readl(iomm.ccm + PLL_CPU_CTRL_REG);
+	        switch (cpu_clock) {
+		    case 0x90001110: case 0x90001210: case 0x90000C20: case 0x90001310: case 0x90001410: //==[864, 912, 936, 960, 1008]MHz
+				lastScanLine = 280;
+				break;
+		    case 0x90000A20: case 0x90001010: //==[792, 816]MHz
+				lastScanLine = 240;
+				break;					
+		    case 0x90001E00: case 0x90001F00: //==[744, 768]MHz
+				lastScanLine = 200;
+				break;
+		    case 0x90001C00: case 0x90001D00: //==[696, 720]MHz
+				lastScanLine = 164;
+				break;
+		    default: // < 696Mhz
+				lastScanLine = 120;
+	      }
+          for (i = firstScanLine; i <= lastScanLine; i++) {
+              lcdc_wr_cmd(0x45);
+              lcdc_rd_dat();
+              lcdc_rd_dat();
+              vsync = lcdc_rd_dat();
+              if (vsync > 0) {
+                  refresh_lcd(arg);
+                  suniv_setbits(iomm.lcdc + TCON0_CPU_IF_REG, (1 << 28));
+                  suniv_clrbits(iomm.lcdc + TCON_INT_REG0, (1 << 15));
+                  return IRQ_HANDLED;
+              }
+          }
+    suniv_setbits(iomm.lcdc + TCON0_CPU_IF_REG, (1 << 28));
+    suniv_clrbits(iomm.lcdc + TCON_INT_REG0, (1 << 15));
+    return IRQ_HANDLED;
+	}
+    refresh_lcd(arg);
+    suniv_clrbits(iomm.lcdc + TCON_INT_REG0, (1 << 15));
+    return IRQ_HANDLED;	
+}
+
+static void init_lcd(void)
+{
+    suniv_gpio_init();
+    suniv_clrbits(iomm.lcdc + PE_DATA, (1 << 11));
+    mdelay(150);
+    suniv_setbits(iomm.lcdc + PE_DATA, (1 << 11));
+    mdelay(150);
+
+    lcdc_wr_cmd(0x11);
+    mdelay(250);
+                  
+    lcdc_wr_cmd(0x36);
+    if (flip) {
+        lcdc_wr_dat(0x70); //screen direction //0x70 for 3.5, 0xB0 for pg
+    } else {
+        lcdc_wr_dat(0xB0); //screen direction //0x70 for 3.5, 0xB0 for pg
+    }
+//    lcdc_wr_cmd(0x3a);
+//    lcdc_wr_dat(0x05);
+      
+    lcdc_wr_cmd(0x2a);
+    lcdc_wr_dat(0x00);
+    lcdc_wr_dat(0x00);
+    lcdc_wr_dat(0x01);
+    lcdc_wr_dat(0x3f);
+
+    lcdc_wr_cmd(0x2b);
+    lcdc_wr_dat(0x00);
+    lcdc_wr_dat(0x00);
+    lcdc_wr_dat(0x00);
+    lcdc_wr_dat(0xef);
+        
+    // ST7789S Frame rate setting
+	lcdc_wr_cmd(0xb2);
+	if (tefix == 3) {
+		lcdc_wr_dat(8); // bp 0x0a
+		lcdc_wr_dat(122); // fp 0x0b
+    } else if (tefix == 2) {
+        lcdc_wr_dat(8); // bp 0x0a
+        lcdc_wr_dat(120); // fp 0x0b
+	} else if (tefix == 1) {
+		lcdc_wr_dat(90); // bp 0x0a
+		lcdc_wr_dat(20); // fp 0x0b
+	} else {
+        lcdc_wr_dat(9); // bp 0x0a
+        lcdc_wr_dat(10); // fp 0x0b
+    }
+		lcdc_wr_dat(0x00);        			
+		lcdc_wr_dat(0x33);
+		lcdc_wr_dat(0x33);
+
+//    // Gate Control
+//    lcdc_wr_cmd(0xb7);
+//    lcdc_wr_dat(0x35);
+//
+//    // ?
+//    lcdc_wr_cmd(0xb8);
+//    lcdc_wr_dat(0x2f);
+//    lcdc_wr_dat(0x2b);
+//    lcdc_wr_dat(0x2f);
+//
+//    // ST7789S Power setting
+//    lcdc_wr_cmd(0xbb);
+//    lcdc_wr_dat(0x15);
+//
+//    lcdc_wr_cmd(0xc0);
+//    lcdc_wr_dat(0x3C);
+//
+//    lcdc_wr_cmd(0xc2);
+//    lcdc_wr_dat(0x01);
+//
+//    lcdc_wr_cmd(0xc3);
+//    lcdc_wr_dat(0x13); // or 0x0b?
+//
+//    lcdc_wr_cmd(0xc4);
+//    lcdc_wr_dat(0x20);
+//
+    if (invert) {
+        lcdc_wr_cmd(0x21); // Display Inversion On (INVON for colors)
+    } else {
+        lcdc_wr_cmd(0x20); //  Display Inversion Off (INVOFF for colors)
+    }
+
+    lcdc_wr_cmd(0xc6);
+    if (tefix == 3)
+        lcdc_wr_dat(0x03); // 0x04, 0x1f
+    else if (tefix == 2)
+        lcdc_wr_dat(0x04);
+    else if (tefix == 1)
+        lcdc_wr_dat(0x03);
+    else
+        lcdc_wr_dat(0x03); // 0x04, 0x1f
+//
+//    lcdc_wr_cmd(0xd0);
+//    lcdc_wr_dat(0xa4);
+//    lcdc_wr_dat(0xa1);
+//
+//    lcdc_wr_cmd(0xe8);
+//    lcdc_wr_dat(0x03);
+//
+//    lcdc_wr_cmd(0xe9);
+//    lcdc_wr_dat(0x0d);
+//    lcdc_wr_dat(0x12);
+//    lcdc_wr_dat(0x00);
+//
+//    // ST7789S gamma setting
+//    lcdc_wr_cmd(0xe0);
+//    lcdc_wr_dat(0x70);
+//    lcdc_wr_dat(0x00);
+//    lcdc_wr_dat(0x06);
+//    lcdc_wr_dat(0x09);
+//    lcdc_wr_dat(0x0b);
+//    lcdc_wr_dat(0x2a);
+//    lcdc_wr_dat(0x3c);
+//    lcdc_wr_dat(0x33);
+//    lcdc_wr_dat(0x4b);
+//    lcdc_wr_dat(0x08);
+//    lcdc_wr_dat(0x16);
+//    lcdc_wr_dat(0x14);
+//    lcdc_wr_dat(0x2a);
+//    lcdc_wr_dat(0x23);
+//
+//    lcdc_wr_cmd(0xe1);
+//    lcdc_wr_dat(0xd0);
+//    lcdc_wr_dat(0x00);
+//    lcdc_wr_dat(0x06);
+//    lcdc_wr_dat(0x09);
+//    lcdc_wr_dat(0x0b);
+//    lcdc_wr_dat(0x29);
+//    lcdc_wr_dat(0x36);
+//    lcdc_wr_dat(0x54);
+//    lcdc_wr_dat(0x4b);
+//    lcdc_wr_dat(0x0d);
+//    lcdc_wr_dat(0x16);
+//    lcdc_wr_dat(0x14);
+//    lcdc_wr_dat(0x28);
+//    lcdc_wr_dat(0x22);
+
+    mdelay(50);
+    lcdc_wr_cmd(0x29);
+    mdelay(50);
+    lcdc_wr_cmd(0x2c);
+    mdelay(100);
+
+    mypar->app_virt->yoffset = 0;
+    memset(mypar->vram_virt, 0, 320*240*4);
+}
+
+static void suniv_fb_addr_init(struct myfb_par *par)
+{
+    writel((uint32_t)(par->vram_phys + 320*240*2*0) << 3, iomm.debe + DEBE_LAY0_FB_ADDR_REG);
+    writel((uint32_t)(par->vram_phys + 320*240*2*1) << 3, iomm.debe + DEBE_LAY1_FB_ADDR_REG);
+    writel((uint32_t)(par->vram_phys + 320*240*2*2) << 3, iomm.debe + DEBE_LAY2_FB_ADDR_REG);
+    writel((uint32_t)(par->vram_phys + 320*240*2*3) << 3, iomm.debe + DEBE_LAY3_FB_ADDR_REG);
+
+    writel((uint32_t)(par->vram_phys + 320*240*2*0) >> 29, iomm.debe + DEBE_LAY0_FB_HI_ADDR_REG);
+    writel((uint32_t)(par->vram_phys + 320*240*2*1) >> 29, iomm.debe + DEBE_LAY1_FB_HI_ADDR_REG);
+    writel((uint32_t)(par->vram_phys + 320*240*2*2) >> 29, iomm.debe + DEBE_LAY2_FB_HI_ADDR_REG);
+    writel((uint32_t)(par->vram_phys + 320*240*2*3) >> 29, iomm.debe + DEBE_LAY3_FB_HI_ADDR_REG);	
+}
+
+static void suniv_lcdc_init(unsigned long xres, unsigned long yres)
+{
+    uint32_t ret=0, bp=0, total=0;
+    uint32_t h_front_porch = 8;
+    uint32_t h_back_porch = 8;
+    uint32_t h_sync_len = 1;
+    uint32_t v_front_porch = 8;
+    uint32_t v_back_porch = 8;
+    uint32_t v_sync_len = 1;
+    if (tefix == 3) {
+        v_front_porch = 10;
+        v_back_porch = 110;
+    } else if (tefix == 2) {
+        v_front_porch = 10;
+        v_back_porch = 110;
+    } else if (tefix == 1) {
+        h_front_porch = 45;
+        h_back_porch = 45;
+	    v_front_porch = 4;
+        v_back_porch = 16;
+        v_sync_len = 3;
+        h_sync_len = 3;
+	}
+
+    writel(0, iomm.lcdc + TCON_CTRL_REG);
+    writel(0, iomm.lcdc + TCON_INT_REG0);
+    ret = readl(iomm.lcdc + TCON_CLK_CTRL_REG);
+    ret&= ~(0xf << 28);
+    writel(ret, iomm.lcdc + TCON_CLK_CTRL_REG);
+    writel(0xffffffff, iomm.lcdc + TCON0_IO_CTRL_REG1);
+    writel(0xffffffff, iomm.lcdc + TCON1_IO_CTRL_REG1);
+
+    suniv_setbits(iomm.debe + DEBE_MODE_CTRL_REG, (1 << 0));
+    writel(xres << 4, iomm.debe + DEBE_LAY0_LINEWIDTH_REG);
+    writel(xres << 4, iomm.debe + DEBE_LAY1_LINEWIDTH_REG);
+    writel(xres << 4, iomm.debe + DEBE_LAY2_LINEWIDTH_REG);
+    writel(xres << 4, iomm.debe + DEBE_LAY3_LINEWIDTH_REG);
+    writel((((yres) - 1) << 16) | (((xres) - 1) << 0), iomm.debe + DEBE_DISP_SIZE_REG);
+    writel((((yres) - 1) << 16) | (((xres) - 1) << 0), iomm.debe + DEBE_LAY0_SIZE_REG);
+    writel((((yres) - 1) << 16) | (((xres) - 1) << 0), iomm.debe + DEBE_LAY1_SIZE_REG);
+    writel((((yres) - 1) << 16) | (((xres) - 1) << 0), iomm.debe + DEBE_LAY2_SIZE_REG);
+    writel((((yres) - 1) << 16) | (((xres) - 1) << 0), iomm.debe + DEBE_LAY3_SIZE_REG);
+    writel((5 << 8), iomm.debe + DEBE_LAY0_ATT_CTRL_REG1);
+    writel((5 << 8), iomm.debe + DEBE_LAY1_ATT_CTRL_REG1);
+    writel((5 << 8), iomm.debe + DEBE_LAY2_ATT_CTRL_REG1);
+    writel((5 << 8), iomm.debe + DEBE_LAY3_ATT_CTRL_REG1);
+    suniv_setbits(iomm.debe + DEBE_MODE_CTRL_REG, (1 << 8));
+    suniv_setbits(iomm.debe + DEBE_REGBUFF_CTRL_REG, (1 << 1));
+    suniv_setbits(iomm.debe + DEBE_MODE_CTRL_REG, (1 << 1));
+
+    ret = readl(iomm.lcdc + TCON_CTRL_REG);
+    ret&= ~(1 << 0);
+    writel(ret, iomm.lcdc + TCON_CTRL_REG);
+    ret = (v_front_porch + v_back_porch + v_sync_len);
+
+    writel((1 << 31) | ((ret & 0x1f) << 4) | (1 << 24), iomm.lcdc + TCON0_CTRL_REG);
+    writel((0xf << 28) | (6 << 0), iomm.lcdc + TCON_CLK_CTRL_REG); //6, 15, 25
+    writel((4 << 29) | (1 << 26), iomm.lcdc + TCON0_CPU_IF_REG);
+    writel((1 << 28), iomm.lcdc + TCON0_IO_CTRL_REG0);
+
+    writel(((xres - 1) << 16) | ((yres - 1) << 0), iomm.lcdc + TCON0_BASIC_TIMING_REG0);
+    bp = h_sync_len + h_back_porch;
+    total = xres * 1 + h_front_porch + bp;
+    writel(((total - 1) << 16) | ((h_back_porch) << 0), iomm.lcdc + TCON0_BASIC_TIMING_REG1);
+    bp = v_sync_len + v_back_porch;
+    total = yres + v_front_porch + bp;
+    writel(((total * 2) << 16) | ((v_back_porch) << 0), iomm.lcdc + TCON0_BASIC_TIMING_REG2);
+    writel(((h_sync_len) << 16) | ((v_sync_len) << 0), iomm.lcdc + TCON0_BASIC_TIMING_REG3);
+    writel(0, iomm.lcdc + TCON0_HV_TIMING_REG);
+    writel(0, iomm.lcdc + TCON0_IO_CTRL_REG1);
+
+    writel(0, iomm.lcdc + TCON0_HV_TIMING_REG);
+    writel(0, iomm.lcdc + TCON0_IO_CTRL_REG1);
+
+    suniv_setbits(iomm.lcdc + TCON_CTRL_REG, (1 << 31));
+    init_lcd();
+    suniv_setbits(iomm.lcdc + TCON_INT_REG0, (1 << 31));
+    suniv_setbits(iomm.lcdc + TCON0_CPU_IF_REG, (1 << 28));
+}
+
+static void suniv_enable_irq(struct myfb_par *par)
+{
+    int ret=0;
+
+    par->gpio_irq = gpio_to_irq(((32 * 4) + 10));
+    if (par->gpio_irq < 0) {
+        printk("%s, failed to get irq number for gpio irq\n", __func__);
+    } else {
+        ret = request_irq(par->gpio_irq, gpio_irq_handler, IRQF_TRIGGER_RISING, "gpio_irq", par);
+        if (ret) {
+            printk("%s, failed to register gpio interrupt(%d)\n", __func__, par->gpio_irq);
+        }
+    }
+
+        par->lcdc_irq = platform_get_irq(par->pdev, 0);
+        if (par->lcdc_irq < 0) {
+            printk("%s, failed to get irq number for lcdc irq\n", __func__);
+        } else {
+            ret = request_irq(par->lcdc_irq, lcdc_irq_handler, IRQF_SHARED, "lcdc_irq", par);
+            if (ret) {
+                printk("%s, failed to register lcdc interrupt(%d)\n", __func__, par->lcdc_irq);
+            }
+        }
+
+}
+
+static void suniv_cpu_init(struct myfb_par *par)
+{
+    uint32_t ret, i;
+    if (tefix == 3 || tefix == 2) {
+        writel(0x91001303, iomm.ccm + PLL_VIDEO_CTRL_REG);
+    } else {
+        writel(0x91001107, iomm.ccm + PLL_VIDEO_CTRL_REG);
+    }
+    while ((readl(iomm.ccm + PLL_VIDEO_CTRL_REG) & (1 << 28)) == 0){}
+    while ((readl(iomm.ccm + PLL_PERIPH_CTRL_REG) & (1 << 28)) == 0){}
+
+    ret = readl(iomm.ccm + DRAM_GATING_REG);
+    ret|= (1 << 26) | (1 << 24);
+    writel(ret, iomm.ccm + DRAM_GATING_REG);
+
+    suniv_setbits(iomm.ccm + FE_CLK_REG, (1 << 31));
+    suniv_setbits(iomm.ccm + BE_CLK_REG, (1 << 31));
+    suniv_setbits(iomm.ccm + TCON_CLK_REG, (1 << 31));
+    suniv_setbits(iomm.ccm + BUS_CLK_GATING_REG1, (1 << 14) | (1 << 12) | (1 << 4));
+    suniv_setbits(iomm.ccm + BUS_SOFT_RST_REG1, (1 << 14) | (1 << 12) | (1 << 4));
+    for (i=0x0800; i<0x1000; i+=4) {
+        writel(0, iomm.debe + i);
+    }
+}
+
+static void lcd_delay_init(unsigned long param)
+{
+    suniv_cpu_init(mypar);
+	suniv_fb_addr_init(mypar);
+    suniv_lcdc_init(mypar->mode.xres, mypar->mode.yres);
+    mypar->lcdc_ready = 1;
+    suniv_enable_irq(mypar);
+}
+
+#define CNVT_TOHW(val, width) ((((val) << (width)) + 0x7FFF - (val)) >> 16)
+static int myfb_setcolreg(unsigned regno, unsigned red, unsigned green, unsigned blue, unsigned transp, struct fb_info *info)
+{
+    red = CNVT_TOHW(red, info->var.red.length);
+    blue = CNVT_TOHW(blue, info->var.blue.length);
+    green = CNVT_TOHW(green, info->var.green.length);
+    ((u32*)(info->pseudo_palette))[regno] = (red << info->var.red.offset) | (green << info->var.green.offset) | (blue << info->var.blue.offset);
+    return 0;
+}
+#undef CNVT_TOHW
+
+static int myfb_check_var(struct fb_var_screeninfo *var, struct fb_info *info)
+{
+    int bpp = var->bits_per_pixel >> 3;
+    struct myfb_par *par = info->par;
+    unsigned long line_size = var->xres_virtual * bpp;
+
+    if ((var->xres != 320) || (var->yres != 240) || (var->bits_per_pixel != 16)) {
+        return -EINVAL;
+    }
+
+    var->transp.offset = 0;
+    var->transp.length = 0;
+    var->red.offset = 11;
+    var->red.length = 5;
+    var->green.offset = 5;
+    var->green.length = 6;
+    var->blue.offset = 0;
+    var->blue.length = 5;
+    var->red.msb_right = 0;
+    var->green.msb_right = 0;
+    var->blue.msb_right = 0;
+    var->transp.msb_right = 0;
+    if (line_size * var->yres_virtual > par->vram_size) {
+        var->yres_virtual = par->vram_size / line_size;
+    }
+    if (var->yres > var->yres_virtual) {
+        var->yres = var->yres_virtual;
+    }
+    if (var->xres > var->xres_virtual) {
+        var->xres = var->xres_virtual;
+    }
+    if (var->xres + var->xoffset > var->xres_virtual) {
+        var->xoffset = var->xres_virtual - var->xres;
+    }
+    if (var->yres + var->yoffset > var->yres_virtual) {
+        var->yoffset = var->yres_virtual - var->yres;
+    }
+    return 0;
+}
+
+static int myfb_set_par(struct fb_info *info)
+{
+    struct myfb_par *par = info->par;
+
+    fb_var_to_videomode(&par->mode, &info->var);
+    par->app_virt->yoffset = info->var.yoffset = 0;
+    par->bpp = info->var.bits_per_pixel;
+    info->fix.visual = FB_VISUAL_TRUECOLOR;
+    info->fix.line_length = (par->mode.xres * par->bpp) / 8;
+    writel((5 << 8), iomm.debe + DEBE_LAY0_ATT_CTRL_REG1);
+    writel((5 << 8), iomm.debe + DEBE_LAY1_ATT_CTRL_REG1);
+    writel((5 << 8), iomm.debe + DEBE_LAY2_ATT_CTRL_REG1);
+    writel((5 << 8), iomm.debe + DEBE_LAY3_ATT_CTRL_REG1);
+    return 0;
+}
+
+static int myfb_ioctl(struct fb_info *info, unsigned int cmd, unsigned long arg)
+{
+    struct myfb_par *par = info->par;
+    switch (cmd) {
+        case FBIO_WAITFORVSYNC:
+            wait_for_vsync(par);
+            break;			
+    }
+    return 0;
+}
+
+static int myfb_mmap(struct fb_info *info, struct vm_area_struct *vma)
+{
+    const unsigned long offset = vma->vm_pgoff << PAGE_SHIFT;
+    const unsigned long size = vma->vm_end - vma->vm_start;
+
+    if (offset + size > info->fix.smem_len) {
+        return -EINVAL;
+    }
+
+    if (remap_pfn_range(vma, vma->vm_start, (info->fix.smem_start + offset) >> PAGE_SHIFT, size, vma->vm_page_prot)) {
+        return -EAGAIN;
+    }
+    return 0;
+}
+
+static int myfb_pan_display(struct fb_var_screeninfo *var, struct fb_info *info)
+{
+    struct myfb_par *par = info->par;
+
+    info->var.xoffset = var->xoffset;
+    info->var.yoffset = var->yoffset;
+    par->app_virt->yoffset = var->yoffset;
+    return 0;
+}
+
+static struct fb_ops myfb_ops = {
+        .owner          = THIS_MODULE,
+        .fb_check_var   = myfb_check_var,
+        .fb_set_par     = myfb_set_par,
+        .fb_setcolreg   = myfb_setcolreg,
+        .fb_pan_display = myfb_pan_display,
+        .fb_ioctl       = myfb_ioctl,
+        .fb_mmap        = myfb_mmap,
+
+        .fb_fillrect  = sys_fillrect,
+        .fb_copyarea  = sys_copyarea,
+        .fb_imageblit = sys_imageblit,
+};
+
+static int myfb_probe(struct platform_device *device)
+{
+    int ret=0;
+    struct fb_info *info=NULL;
+    struct myfb_par *par=NULL;
+    struct fb_videomode *mode=NULL;
+
+    mode = devm_kzalloc(&device->dev, sizeof(struct fb_videomode), GFP_KERNEL);
+    if (mode == NULL) {
+        return -ENOMEM;
+    }
+    mode->name = "320x240";
+    mode->xres = 320;
+    mode->yres = 240;
+    mode->vmode = FB_VMODE_NONINTERLACED;
+    pm_runtime_enable(&device->dev);
+    pm_runtime_get_sync(&device->dev);
+
+    info = framebuffer_alloc(sizeof(struct myfb_par), &device->dev);
+    if (!info) {
+        return -ENOMEM;
+    }
+
+    par = info->par;
+    par->pdev = device;
+    par->dev = &device->dev;
+    par->bpp = 16;
+    fb_videomode_to_var(&myfb_var, mode);
+
+    par->vram_size = (320 * 240 * 2 * 4) + 4096;
+    par->vram_virt = dma_alloc_coherent(NULL, par->vram_size, (resource_size_t*)&par->vram_phys, GFP_KERNEL | GFP_DMA);
+    if (!par->vram_virt) {
+        return -EINVAL;
+    }
+    info->screen_base = (char __iomem*)par->vram_virt;
+    myfb_fix.smem_start = par->vram_phys;
+    myfb_fix.smem_len = par->vram_size;
+    myfb_fix.line_length = 320 * 2;
+    par->app_virt = (struct myfb_app*)((uint8_t*)par->vram_virt + (320 * 240 * 2 * 4));
+
+    par->v_palette_base = dma_alloc_coherent(NULL, PALETTE_SIZE, (resource_size_t*)&par->p_palette_base, GFP_KERNEL | GFP_DMA);
+    if (!par->v_palette_base) {
+        return -EINVAL;
+    }
+    memset(par->v_palette_base, 0, PALETTE_SIZE);
+    myfb_var.grayscale = 0;
+    myfb_var.bits_per_pixel = par->bpp;
+
+    info->flags = FBINFO_FLAG_DEFAULT;
+    info->fix = myfb_fix;
+    info->var = myfb_var;
+    info->fbops = &myfb_ops;
+    info->pseudo_palette = par->pseudo_palette;
+    info->fix.visual = (info->var.bits_per_pixel <= 8) ? FB_VISUAL_PSEUDOCOLOR : FB_VISUAL_TRUECOLOR;
+    ret = fb_alloc_cmap(&info->cmap, PALETTE_SIZE, 0);
+    if (ret) {
+        return -EINVAL;
+    }
+    info->cmap.len = 32;
+
+    myfb_var.activate = FB_ACTIVATE_FORCE;
+    fb_set_var(info, &myfb_var);
+    dev_set_drvdata(&device->dev, info);
+    if (register_framebuffer(info) < 0) {
+        return -EINVAL;
+    }
+
+    mypar = par;
+    mypar->lcdc_ready = 0;
+    mypar->app_virt->vsync_count = 0;
+    for (ret=0; ret<of_clk_get_parent_count(device->dev.of_node); ret++) {
+        clk_prepare_enable(of_clk_get(device->dev.of_node, ret));
+    }
+    init_waitqueue_head(&wait_vsync_queue);
+    setup_timer(&mytimer, lcd_delay_init, 0);
+    mod_timer(&mytimer, jiffies + HZ);
+    return 0;
+}
+
+static int myfb_remove(struct platform_device *dev)
+{
+    struct fb_info *info = dev_get_drvdata(&dev->dev);
+    struct myfb_par *par = info->par;
+
+    if (info) {
+        free_irq(par->lcdc_irq, par);
+        free_irq(par->gpio_irq, par);
+        del_timer(&mytimer);
+        flush_scheduled_work();
+        unregister_framebuffer(info);
+        fb_dealloc_cmap(&info->cmap);
+        dma_free_coherent(NULL, PALETTE_SIZE, par->v_palette_base, par->p_palette_base);
+        dma_free_coherent(NULL, par->vram_size, par->vram_virt, par->vram_phys);
+        pm_runtime_put_sync(&dev->dev);
+        pm_runtime_disable(&dev->dev);
+        framebuffer_release(info);
+    }
+    return 0;
+}
+
+static int myfb_suspend(struct platform_device *dev, pm_message_t state)
+{
+    struct fb_info *info = platform_get_drvdata(dev);
+
+    console_lock();
+    fb_set_suspend(info, 1);
+    pm_runtime_put_sync(&dev->dev);
+    console_unlock();
+    return 0;
+}
+
+static int myfb_resume(struct platform_device *dev)
+{
+    struct fb_info *info = platform_get_drvdata(dev);
+
+    console_lock();
+    pm_runtime_get_sync(&dev->dev);
+    fb_set_suspend(info, 0);
+    console_unlock();
+    return 0;
+}
+
+static const struct of_device_id fb_of_match[] = {
+        {
+                .compatible = "allwinner,suniv-f1c500s-tcon0",
+        },{}
+};
+MODULE_DEVICE_TABLE(of, fb_of_match);
+
+static struct platform_driver fb_driver = {
+        .probe    = myfb_probe,
+        .remove   = myfb_remove,
+        .suspend  = myfb_suspend,
+        .resume   = myfb_resume,
+        .driver = {
+                .name   = DRIVER_NAME,
+                .owner  = THIS_MODULE,
+                .of_match_table = of_match_ptr(fb_of_match),
+        },
+};
+
+static void suniv_ioremap(void)
+{
+    iomm.ccm = (uint8_t*)ioremap(SUNIV_CCM_BASE, 1024);
+    iomm.gpio = (uint8_t*)ioremap(SUNIV_GPIO_BASE, 1024);
+    iomm.lcdc = (uint8_t*)ioremap(SUNIV_LCDC_BASE, 1024);
+    iomm.debe = (uint8_t*)ioremap(SUNIV_DEBE_BASE, 4096);
+}
+
+static void suniv_iounmap(void)
+{
+    iounmap(iomm.ccm);
+    iounmap(iomm.gpio);
+    iounmap(iomm.lcdc);
+    iounmap(iomm.debe);
+    iounmap(iomm.intc);
+    iounmap(iomm.timer);
+}
+
+static int myopen(struct inode *inode, struct file *file)
+{
+    return 0;
+}
+
+static int myclose(struct inode *inode, struct file *file)
+{
+    return 0;
+}
+
+static long myioctl(struct file *filp, unsigned int cmd, unsigned long arg)
+{
+    int ret;
+    int32_t w, bpp;
+
+    switch (cmd) {
+        case MIYOO_FB0_PUT_OSD:
+            break;
+        case MIYOO_FB0_SET_MODE:
+            w = (arg >> 16);
+            bpp = (arg & 0xffff);
+            if ((bpp != 16)) {
+                writel((5 << 8), iomm.debe + DEBE_LAY0_ATT_CTRL_REG1);
+                writel((5 << 8), iomm.debe + DEBE_LAY1_ATT_CTRL_REG1);
+            } else {
+                writel((7 << 8) | 4, iomm.debe + DEBE_LAY0_ATT_CTRL_REG1);
+                writel((7 << 8) | 4, iomm.debe + DEBE_LAY1_ATT_CTRL_REG1);
+            }
+            break;
+        case MIYOO_FB0_GET_VER:
+            w = copy_to_user((void*)arg, &miyoo_ver, sizeof(uint32_t));
+            break;
+        case MIYOO_FB0_SET_TEFIX:
+            tefix = arg;
+#if defined(DEBUG)
+            printk("st7789sfb: set TE fix to: %d", (int)tefix);
+#endif
+            if (tefix == 3 || tefix == 2) {
+            	writel(0x91001303, iomm.ccm + PLL_VIDEO_CTRL_REG);
+            } else {
+            	writel(0x91001107, iomm.ccm + PLL_VIDEO_CTRL_REG);
+            }
+            while ((readl(iomm.ccm + PLL_VIDEO_CTRL_REG) & (1 << 28)) == 0){};
+            suniv_lcdc_init(320, 240);
+            break;
+        case MIYOO_FB0_GET_TEFIX:
+            ret = copy_to_user((void*)arg, &tefix, sizeof(unsigned long));
+#if defined(DEBUG)
+	    video_clock = readl(iomm.ccm + PLL_VIDEO_CTRL_REG);
+	    printk("VIDEO_clock set to 0x%x", (uint32_t)video_clock);
+#endif
+	    break;				
+    }
+    return 0;
+}
+
+static const struct file_operations myfops = {
+        .owner = THIS_MODULE,
+        .open = myopen,
+        .release = myclose,
+        .unlocked_ioctl = myioctl,
+};
+
+static int __init fb_init(void)
+{
+    suniv_ioremap();
+    alloc_chrdev_region(&major, 0, 1, "miyoo_fb0");
+    myclass = class_create(THIS_MODULE, "miyoo_fb0");
+    device_create(myclass, NULL, major, NULL, "miyoo_fb0");
+    cdev_init(&mycdev, &myfops);
+    cdev_add(&mycdev, major, 1);
+    return platform_driver_register(&fb_driver);
+}
+
+static void __exit fb_cleanup(void)
+{
+    suniv_iounmap();
+    device_destroy(myclass, major);
+    cdev_del(&mycdev);
+    class_destroy(myclass);
+    unregister_chrdev_region(major, 1);
+    platform_driver_unregister(&fb_driver);
+}
+
+module_init(fb_init);
+module_exit(fb_cleanup);
+
+MODULE_DESCRIPTION("Framebuffer driver for ST7789S");
+MODULE_AUTHOR("Steward Fu <steward.fu@gmail.com>");
+MODULE_LICENSE("GPL");
diff --git a/include/dt-bindings/clock/suniv-ccu.h b/include/dt-bindings/clock/suniv-ccu.h
new file mode 100644
index 00000000..9e8636be
--- /dev/null
+++ b/include/dt-bindings/clock/suniv-ccu.h
@@ -0,0 +1,69 @@
+/*
+ * Copyright (c) 2018 Icenowy Zheng <icenowy@aosc.xyz>
+ *
+ * SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+ */
+
+#ifndef _DT_BINDINGS_CLK_SUNIV_H_
+#define _DT_BINDINGS_CLK_SUNIV_H_
+
+#define CLK_CPU			11
+
+#define CLK_BUS_MMC0		14
+#define CLK_BUS_MMC1		15
+#define CLK_BUS_DRAM		16
+#define CLK_BUS_SPI0		17
+#define CLK_BUS_SPI1		18
+#define CLK_BUS_OTG		19
+#define CLK_BUS_VE		20
+#define CLK_BUS_LCD		21
+#define CLK_BUS_DI	22
+#define CLK_BUS_CSI		23
+#define CLK_BUS_TVD		24
+#define CLK_BUS_TVE		25
+#define CLK_BUS_DE_BE		26
+#define CLK_BUS_DE_FE		27
+#define CLK_BUS_CODEC		28
+#define CLK_BUS_SPDIF		29
+#define CLK_BUS_IR		30
+#define CLK_BUS_RSB		31
+#define CLK_BUS_I2S0		32
+#define CLK_BUS_I2C0		33
+#define CLK_BUS_I2C1		34
+#define CLK_BUS_I2C2		35
+#define CLK_BUS_PIO		36
+#define CLK_BUS_UART0		37
+#define CLK_BUS_UART1		38
+#define CLK_BUS_UART2		39
+
+#define CLK_MMC0		40
+#define CLK_MMC0_SAMPLE		41
+#define CLK_MMC0_OUTPUT		42
+#define CLK_MMC1		43
+#define CLK_MMC1_SAMPLE		44
+#define CLK_MMC1_OUTPUT		45
+#define CLK_I2S			46
+#define CLK_SPDIF		47
+
+#define CLK_USB_PHY0		48
+
+#define CLK_DRAM_VE		49
+#define CLK_DRAM_CSI		50
+#define CLK_DRAM_DI	51
+#define CLK_DRAM_TVD		52
+#define CLK_DRAM_DE_FE		53
+#define CLK_DRAM_DE_BE		54
+
+#define CLK_DE_BE		55
+#define CLK_DE_FE		56
+#define CLK_TCON		57
+#define CLK_DI		58
+#define CLK_TVE2_CLK		59
+#define CLK_TVE1_CLK		60
+#define CLK_TVD			61
+#define CLK_CSI			62
+#define CLK_VE			63
+#define CLK_CODEC		64
+#define CLK_AVS			65
+
+#endif
diff --git a/include/dt-bindings/reset/suniv-ccu.h b/include/dt-bindings/reset/suniv-ccu.h
new file mode 100644
index 00000000..34262b9c
--- /dev/null
+++ b/include/dt-bindings/reset/suniv-ccu.h
@@ -0,0 +1,37 @@
+/*
+ * Copyright (C) 2018 Icenowy Zheng <icenowy@aosc.xyz>
+ *
+ * SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+ */
+
+#ifndef _DT_BINDINGS_RST_SUNIV_H_
+#define _DT_BINDINGS_RST_SUNIV_H_
+
+#define RST_USB_PHY0		0
+#define RST_BUS_MMC0		1
+#define RST_BUS_MMC1		2
+#define RST_BUS_DRAM		3
+#define RST_BUS_SPI0		4
+#define RST_BUS_SPI1		5
+#define RST_BUS_OTG		6
+#define RST_BUS_VE		7
+#define RST_BUS_LCD		8
+#define RST_BUS_DI		9
+#define RST_BUS_CSI		10
+#define RST_BUS_TVD		11
+#define RST_BUS_TVE		12
+#define RST_BUS_DE_BE		13
+#define RST_BUS_DE_FE		14
+#define RST_BUS_CODEC		15
+#define RST_BUS_SPDIF		16
+#define RST_BUS_IR		17
+#define RST_BUS_RSB		18
+#define RST_BUS_I2S0		19
+#define RST_BUS_I2C0		20
+#define RST_BUS_I2C1		21
+#define RST_BUS_I2C2		22
+#define RST_BUS_UART0		23
+#define RST_BUS_UART1		24
+#define RST_BUS_UART2		25
+
+#endif /* _DT_BINDINGS_RST_SUNIV_H_ */
diff --git a/scripts/setlocalversion b/scripts/setlocalversion
index 2cb0b92f..569b8295 100755
--- a/scripts/setlocalversion
+++ b/scripts/setlocalversion
@@ -54,7 +54,8 @@ scm_version()
 			# If only the short version is requested, don't bother
 			# running further git commands
 			if $short; then
-				echo "+"
+			#comment next line to make local kernel work with your upstream build
+				#echo "+"
 				return
 			fi
 			# If we are past a tagged commit (like
diff --git a/sound/soc/Kconfig b/sound/soc/Kconfig
index c0abad20..382183bd 100644
--- a/sound/soc/Kconfig
+++ b/sound/soc/Kconfig
@@ -65,12 +65,12 @@ source "sound/soc/sirf/Kconfig"
 source "sound/soc/spear/Kconfig"
 source "sound/soc/sti/Kconfig"
 source "sound/soc/stm/Kconfig"
-source "sound/soc/sunxi/Kconfig"
 source "sound/soc/tegra/Kconfig"
 source "sound/soc/txx9/Kconfig"
 source "sound/soc/ux500/Kconfig"
 source "sound/soc/xtensa/Kconfig"
 source "sound/soc/zte/Kconfig"
+source "sound/soc/suniv/Kconfig"
 
 # Supported codecs
 source "sound/soc/codecs/Kconfig"
diff --git a/sound/soc/Makefile b/sound/soc/Makefile
index bf8c1e2c..52efd0e1 100644
--- a/sound/soc/Makefile
+++ b/sound/soc/Makefile
@@ -46,7 +46,7 @@ obj-$(CONFIG_SND_SOC)	+= sirf/
 obj-$(CONFIG_SND_SOC)	+= spear/
 obj-$(CONFIG_SND_SOC)	+= sti/
 obj-$(CONFIG_SND_SOC)	+= stm/
-obj-$(CONFIG_SND_SOC)	+= sunxi/
+obj-$(CONFIG_SND_SOC)	+= suniv/
 obj-$(CONFIG_SND_SOC)	+= tegra/
 obj-$(CONFIG_SND_SOC)	+= txx9/
 obj-$(CONFIG_SND_SOC)	+= ux500/
diff --git a/sound/soc/suniv/Kconfig b/sound/soc/suniv/Kconfig
new file mode 100644
index 00000000..11732438
--- /dev/null
+++ b/sound/soc/suniv/Kconfig
@@ -0,0 +1,8 @@
+config SND_SUNIV_CODEC
+	tristate "Allwinner f1c500s codec support"
+	select SND_SOC_GENERIC_DMAENGINE_PCM
+	select REGMAP_MMIO
+	help
+	  Select Y or M to add support for the Codec embedded in the Allwinner
+	  A10 and affiliated SoCs.
+
diff --git a/sound/soc/suniv/Makefile b/sound/soc/suniv/Makefile
new file mode 100644
index 00000000..8fb58650
--- /dev/null
+++ b/sound/soc/suniv/Makefile
@@ -0,0 +1 @@
+obj-$(CONFIG_SND_SUNIV_CODEC) += miyoo.o
diff --git a/sound/soc/suniv/miyoo.c b/sound/soc/suniv/miyoo.c
new file mode 100644
index 00000000..9e704fe9
--- /dev/null
+++ b/sound/soc/suniv/miyoo.c
@@ -0,0 +1,600 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option)any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+#include <linux/cdev.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/dma-mapping.h>
+#include <linux/platform_device.h>
+#include <linux/delay.h>
+#include <linux/slab.h>
+#include <linux/of.h>
+#include <linux/of_address.h>
+#include <linux/of_device.h>
+#include <linux/of_platform.h>
+#include <linux/clk.h>
+#include <linux/clk-provider.h>
+#include <linux/regmap.h>
+#include <linux/reset.h>
+#include <linux/gpio/consumer.h>
+
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <sound/tlv.h>
+#include <sound/initval.h>
+#include <sound/dmaengine_pcm.h>
+#include <linux/gpio.h>
+
+#include <asm/io.h>
+#include <asm/gpio.h>
+#include <asm/arch-suniv/dma.h>
+#include <asm/arch-suniv/cpu.h>
+#include <asm/arch-suniv/gpio.h>
+#include <asm/arch-suniv/clock.h>
+#include <asm/arch-suniv/codec.h>
+#include <asm/arch-suniv/common.h>
+
+#define USE_EARPHONE          1		// set to 0 if UART pin becomes inaccessible
+#define DMA_SIZE              (128 * 2 * PAGE_SIZE)
+#define MIYOO_KBD_GET_HOTKEY  _IOWR(0x100, 0, unsigned long)
+#define MIYOO_FB0_PUT_OSD     _IOWR(0x100, 0, unsigned long)
+#define MIYOO_SND_SET_VOLUME  _IOWR(0x100, 0, unsigned long)
+#define MIYOO_SND_GET_VOLUME  _IOWR(0x101, 0, unsigned long)
+
+struct mypcm {
+  uint32_t dma_period;
+  dma_addr_t dma_start;
+  dma_addr_t dma_pos;
+  dma_addr_t dma_end;
+};
+
+struct suniv_iomm {
+  uint8_t *dma;
+  uint8_t *ccm;
+  uint8_t *gpio;
+  uint8_t *codec;
+
+	void* dma_virt;
+  dma_addr_t dma_phys;
+  uint8_t dma_trigger;
+
+  int irq;
+  struct snd_pcm_substream *substream;
+};
+static struct suniv_iomm iomm={0};
+
+static int major = -1;
+static struct cdev mycdev;
+static struct class *myclass = NULL;
+
+static unsigned long MIYOO_VOLUME = 5;
+static uint32_t miyoo_snd=1;
+module_param(miyoo_snd,uint,0660);
+
+static void suniv_ioremap(void)
+{
+  iomm.dma_trigger = 0;
+  iomm.dma = (uint8_t*)ioremap(SUNIV_DMA_BASE, 4096);
+  iomm.ccm = (uint8_t*)ioremap(SUNIV_CCM_BASE, 4096);
+  iomm.gpio = (uint8_t*)ioremap(SUNIV_GPIO_BASE, 4096);
+  iomm.codec = (uint8_t*)ioremap(SUNIV_CODEC_BASE, 4096);
+}
+
+static void suniv_codec_init(void)
+{
+  suniv_setbits(iomm.ccm + PLL_AUDIO_CTRL_REG, (1 << 31));
+  while(!(readl(iomm.ccm + PLL_AUDIO_CTRL_REG) & (1 << 28)));
+  suniv_setbits(iomm.ccm + BUS_SOFT_RST_REG2, (1 << 0) | (1 << 12));
+  suniv_setbits(iomm.ccm + BUS_CLK_GATING_REG2, (1 << 0) | (1 << 12));
+  suniv_setbits(iomm.ccm + AUDIO_CODEC_CLK_REG, (1 << 31));
+
+  writel((1 << 31), iomm.codec + AC_DAC_DPC_REG);
+  writel((1 << 26) | (1 << 24) | (0x03 << 21) | (0x3f << 8) | (1 << 4) | (1 << 0), iomm.codec + AC_DAC_FIFOC_REG);
+  writel(0xffffffff, iomm.codec + AC_DAC_FIFOS_REG);
+  writel((1 << 31) | (1 << 30) | (1 << 27) | (1 << 26) | (1 << 17) | (1 << 15) | (1 << 9) | (10 << 0), iomm.codec + DAC_MIXER_CTRL_REG);
+}
+
+static void suniv_gpio_init(void)
+{
+  uint32_t ret;
+  switch(miyoo_snd) {
+      case 1:
+      ret = readl(iomm.gpio + PA_CFG0);
+#if defined(USE_EARPHONE)
+      ret&= 0xfffff0f0;
+#else
+      ret &= 0xfffffff0;
+#endif
+      ret |= 0x00000001;
+      writel(ret, iomm.gpio + PA_CFG0);
+      suniv_setbits(iomm.gpio + PA_DATA, (1 << 0));
+      break;
+      case 2:
+        ret = readl(iomm.gpio + PD_CFG0);
+        ret &= 0xfffffff0;
+        ret |= 0x00000001;
+        writel(ret, iomm.gpio + PD_CFG0);
+        suniv_setbits(iomm.gpio + PD_DATA, (1 << 0));
+
+        ret = readl(iomm.gpio + PD_CFG1);
+        ret &= 0xffffff1f;
+        ret |= 0x00000010;
+        writel(ret, iomm.gpio + PD_CFG1);
+        suniv_setbits(iomm.gpio + PD_DATA, (1 << 9));
+        break;
+  }
+
+}
+
+static irqreturn_t dma_irq_handler(int irq, void *arg)
+{
+  uint32_t ret;
+  struct snd_pcm_substream *substream = arg;
+
+#if defined(USE_EARPHONE)
+  ret = readl(iomm.gpio + PA_DATA);
+  if(ret & 4){
+    suniv_setbits(iomm.gpio + PA_DATA, (1 << 0));
+  }
+  else{
+    suniv_clrbits(iomm.gpio + PA_DATA, (1 << 0));
+  }
+#endif
+
+  ret = readl(iomm.dma + DMA_INT_STA_REG);
+  writel(0x03, iomm.dma + DMA_INT_STA_REG);
+  if(ret & 2){
+    if(iomm.dma_trigger){
+      struct snd_pcm_runtime *runtime = substream->runtime;
+      struct mypcm *prtd = runtime->private_data;
+
+      snd_pcm_period_elapsed(substream);
+      if (prtd->dma_pos == prtd->dma_end) {
+        prtd->dma_pos = prtd->dma_start;
+      }
+      writel(prtd->dma_pos, iomm.dma + NDMA0_SRC_ADR_REG);
+      writel(prtd->dma_period, iomm.dma + NDMA0_BYTE_CNT_REG);
+      prtd->dma_pos+= prtd->dma_period;
+      suniv_setbits(iomm.dma + NDMA0_CFG_REG, (1 << 31));
+    }
+  }
+  return IRQ_HANDLED;
+}
+
+static int mycpu_dai_probe(struct snd_soc_dai *dai)
+{
+  return 0;
+}
+
+static int mycard_spk_event(struct snd_soc_dapm_widget *w, struct snd_kcontrol *k, int event)
+{
+  printk("%s\n", __func__);
+  return 0;
+}
+
+static const struct snd_pcm_hardware mypcm_hardware = { 
+  .info = SNDRV_PCM_INFO_MMAP |
+    SNDRV_PCM_INFO_MMAP_VALID |
+    SNDRV_PCM_INFO_INTERLEAVED |
+    SNDRV_PCM_INFO_BLOCK_TRANSFER,
+  .formats = SNDRV_PCM_FMTBIT_S16_LE,
+  .rates = SNDRV_PCM_RATE_8000_192000,
+  .channels_min = 2,
+  .channels_max = 2,
+  .period_bytes_min = 16, 
+  .period_bytes_max = 2 * PAGE_SIZE,
+  .periods_min = 2,
+  .periods_max = 128,
+  .buffer_bytes_max = 128 * 2 * PAGE_SIZE,
+};
+
+static int mypcm_open(struct snd_pcm_substream *substream)
+{
+  int ret;
+  struct mypcm *prtd;
+  struct snd_pcm_runtime *rtd = substream->runtime;
+
+  prtd = kzalloc(sizeof(*prtd), GFP_KERNEL);
+ 	if (prtd == NULL) {
+		printk("%s, failed to allocate runtime data\n", __func__);
+  	return -ENOMEM;
+	}
+
+  snd_soc_set_runtime_hwparams(substream, &mypcm_hardware);
+	ret = snd_pcm_hw_constraint_integer(rtd, SNDRV_PCM_HW_PARAM_PERIODS);
+  if (ret < 0) {
+		printk("%s, failed to do snd_pcm_hw_constraint_integer(%d)\n", __func__, ret);
+  	kfree(prtd);
+  	return ret;
+  }
+  rtd->private_data = prtd;
+  return 0;
+}
+
+static int mypcm_close(struct snd_pcm_substream *substream)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+  struct mypcm *prtd = runtime->private_data;
+
+ 	kfree(prtd);
+  return 0;
+}
+
+static int mypcm_hw_params(struct snd_pcm_substream *substream, struct snd_pcm_hw_params *params)
+{
+  uint32_t ret;
+  struct snd_pcm_runtime *runtime = substream->runtime;
+  struct mypcm *prtd = runtime->private_data;
+
+  switch (params_channels(params)) {
+  case 2:
+    suniv_clrbits(iomm.codec + AC_DAC_FIFOC_REG, (1 << 6));
+    break;
+  default:
+		printk("%s, invalid channel %d\n", __func__, params_channels(params));
+    return -EINVAL;
+  }
+
+  switch (params_format(params)) {
+  case SNDRV_PCM_FORMAT_S16:
+    suniv_clrbits(iomm.codec + AC_DAC_FIFOC_REG, (1 << 5));
+    break;
+  default:
+		printk("%s, invalid format %d\n", __func__, params_format(params));
+    return -EINVAL;
+  }
+
+  switch(params_rate(params)){
+  case 44100:
+  case 22050:
+  case 11025:
+    writel(0x90003f10, iomm.ccm + PLL_AUDIO_CTRL_REG);
+    break;
+  default:
+    writel(0x90005514, iomm.ccm + PLL_AUDIO_CTRL_REG);
+    break;
+  }
+  while(!(readl(iomm.ccm + PLL_AUDIO_CTRL_REG) & (1 << 28)));
+
+  ret = readl(iomm.codec + AC_DAC_FIFOC_REG);
+  ret&= 0x1fffffff;
+	switch (params_rate(params)) {
+	case 48000:
+	case 44100:
+    ret|= (0 << 29);
+		break;
+	case 32000:
+    ret|= (1 << 29);
+		break;
+	case 24000:
+  case 22050:
+    ret|= (2 << 29);
+		break;
+	case 16000:
+    ret|= (3 << 29);
+		break;
+	case 12000:
+  case 11025:
+    ret|= (4 << 29);
+		break;
+	case 8000:
+    ret|= (5 << 29);
+		break;
+	case 192000:
+    ret|= (6 << 29);
+		break;
+	case 96000:
+    ret|= (7 << 29);
+		break;
+	default:
+		printk("%s, invalid rate %d\n", __func__, params_rate(params));
+		return -EINVAL;
+	}
+  writel(ret, iomm.codec + AC_DAC_FIFOC_REG);
+
+  snd_pcm_set_runtime_buffer(substream, &substream->dma_buffer);
+  runtime->dma_bytes = params_buffer_bytes(params);
+  prtd->dma_period = params_period_bytes(params);
+  prtd->dma_start = runtime->dma_addr;
+  prtd->dma_pos = prtd->dma_start;
+  prtd->dma_end = prtd->dma_start + runtime->dma_bytes;
+  writel(prtd->dma_period, iomm.dma + NDMA0_BYTE_CNT_REG);
+  return 0;
+}
+
+static int mypcm_hw_free(struct snd_pcm_substream *substream)
+{
+  return 0;
+}
+
+static int mypcm_prepare(struct snd_pcm_substream *substream)
+{
+  struct mypcm *prtd = substream->runtime->private_data;
+
+  prtd->dma_pos = prtd->dma_start;
+  return 0;
+}
+
+static int mypcm_trigger(struct snd_pcm_substream *substream, int cmd)
+{ 
+  switch (cmd) {
+  case SNDRV_PCM_TRIGGER_START:
+  case SNDRV_PCM_TRIGGER_RESUME:
+  case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+    iomm.dma_trigger = 1;
+    suniv_setbits(iomm.codec + AC_DAC_FIFOC_REG, 1);
+		suniv_setbits(iomm.dma + NDMA0_CFG_REG, (1 << 31));
+    break;
+  case SNDRV_PCM_TRIGGER_STOP:
+  case SNDRV_PCM_TRIGGER_SUSPEND:
+  case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+    iomm.dma_trigger = 0;
+    break;
+  default:
+    break;
+  }
+  return 0;
+}
+
+static snd_pcm_uframes_t mypcm_pointer(struct snd_pcm_substream *substream)
+{
+  struct snd_pcm_runtime *runtime = substream->runtime;
+  struct mypcm *prtd = runtime->private_data;
+  unsigned long byte_offset;
+  snd_pcm_uframes_t offset;
+
+  byte_offset = prtd->dma_pos - prtd->dma_start;
+  byte_offset-= readl(iomm.dma + NDMA0_BYTE_CNT_REG);
+  offset = bytes_to_frames(runtime, byte_offset);
+  if (offset >= runtime->buffer_size) {
+    offset = 0;
+	}
+  return offset;
+}
+
+static int mypcm_mmap(struct snd_pcm_substream *substream, struct vm_area_struct *vma)
+{
+  return remap_pfn_range(vma, vma->vm_start, substream->dma_buffer.addr >> PAGE_SHIFT, vma->vm_end - vma->vm_start, vma->vm_page_prot);
+}
+
+static int mypcm_new(struct snd_soc_pcm_runtime *rtd)
+{
+  struct snd_pcm *pcm = rtd->pcm;
+  struct snd_pcm_substream *substream = pcm->streams[SNDRV_PCM_STREAM_PLAYBACK].substream;
+  struct snd_dma_buffer *buf = &substream->dma_buffer;
+
+  suniv_setbits(iomm.ccm + BUS_CLK_GATING_REG0, (1 << 6));
+  suniv_setbits(iomm.ccm + BUS_SOFT_RST_REG0, (1 << 6));
+  writel(0x00000000, iomm.dma + DMA_INT_CTRL_REG);
+  writel(0xffffffff, iomm.dma + DMA_INT_STA_REG);
+  writel(0x00000002, iomm.dma + DMA_INT_CTRL_REG);
+  writel(0x01ac8190, iomm.dma + NDMA0_CFG_REG);
+  writel(SUNIV_CODEC_BASE + AC_DAC_TXDATA_REG, iomm.dma + NDMA0_DES_ADR_REG);
+  writel(DMA_SIZE, iomm.dma + NDMA0_BYTE_CNT_REG);
+  iomm.dma_virt = dma_alloc_coherent(NULL, DMA_SIZE, (resource_size_t*)&iomm.dma_phys, GFP_KERNEL | GFP_DMA); 
+  if(iomm.dma_virt == NULL){
+    printk("%s, failed to allocate DMA memory\n", __func__);
+    return -ENOMEM;
+  }
+  writel(iomm.dma_phys, iomm.dma + NDMA0_SRC_ADR_REG);
+
+  buf->dev.type = SNDRV_DMA_TYPE_DEV;
+  buf->dev.dev = pcm->card->dev;
+  buf->private_data = NULL;
+  buf->area = iomm.dma_virt;
+	buf->addr = iomm.dma_phys;
+  buf->bytes = DMA_SIZE;
+  iomm.substream = substream;
+  return 0;
+}
+
+static void mypcm_free(struct snd_pcm *pcm)
+{
+	dma_free_coherent(NULL, DMA_SIZE, iomm.dma_virt, iomm.dma_phys);
+	free_irq(iomm.irq, NULL);
+}
+
+static const struct snd_soc_component_driver mycodec_comp = {
+  .name = "miyoo codec",
+};
+
+static struct snd_soc_dai_driver mycpu_dai = {
+  .name = "miyoo cpu dai",
+  .probe = mycpu_dai_probe,
+  .playback = {
+    .stream_name = "miyoo cpu playback",
+    .channels_min = 2,
+    .channels_max = 2,
+    .rates = SNDRV_PCM_RATE_8000_192000,
+    .formats = SNDRV_PCM_FMTBIT_S16_LE,
+  },
+};
+
+static const struct snd_soc_dapm_widget mycard_dapm_widgets[] = {
+  SND_SOC_DAPM_SPK("Speaker", mycard_spk_event),
+};
+
+static const struct snd_pcm_ops mypcm_ops = {
+  .open = mypcm_open,
+  .ioctl = snd_pcm_lib_ioctl,
+  .close = mypcm_close,
+  .hw_params = mypcm_hw_params,
+  .hw_free = mypcm_hw_free,
+  .prepare = mypcm_prepare,
+  .trigger = mypcm_trigger,
+  .pointer = mypcm_pointer,
+  .mmap = mypcm_mmap,
+};
+
+static const struct snd_soc_platform_driver myplatform = {
+  .ops = &mypcm_ops,
+  .pcm_new = mypcm_new,
+  .pcm_free = mypcm_free
+};
+
+static int myopen(struct inode *inode, struct file *file)
+{
+  return 0;
+}
+
+static int myclose(struct inode *inode, struct file *file)
+{
+  return 0;
+}
+
+extern void MIYOO_SET_VOLUME(unsigned long arg) {
+  uint32_t ret;
+  ret = readl(iomm.codec + DAC_MIXER_CTRL_REG);
+  ret&= ~0x3f;
+  ret|= (arg * 6);
+  writel(ret, iomm.codec + DAC_MIXER_CTRL_REG);
+  MIYOO_VOLUME = arg;
+  //printk("MIYOO_SET_VOLUME %ld %ld %ld\n", arg, (arg * 6),MIYOO_VOLUME);
+}
+EXPORT_SYMBOL_GPL(MIYOO_SET_VOLUME);
+
+extern void MIYOO_INCREASE_VOLUME(void){
+  if(MIYOO_VOLUME < 9) {
+    MIYOO_SET_VOLUME(MIYOO_VOLUME+1);
+  }
+}
+EXPORT_SYMBOL_GPL(MIYOO_INCREASE_VOLUME);
+
+extern void MIYOO_DECREASE_VOLUME(void){
+  if(MIYOO_VOLUME > 0) {
+    MIYOO_SET_VOLUME(MIYOO_VOLUME-1);
+  }
+}
+EXPORT_SYMBOL_GPL(MIYOO_DECREASE_VOLUME);
+
+static long myioctl(struct file *filp, unsigned int cmd, unsigned long arg)
+{
+  uint32_t ret;
+
+  switch(cmd){
+  case MIYOO_SND_SET_VOLUME:
+    MIYOO_SET_VOLUME(arg);
+    break;
+  case MIYOO_SND_GET_VOLUME:
+    ret = copy_to_user((void*)arg, &MIYOO_VOLUME, sizeof(unsigned long));
+    break;
+  }
+  return 0;
+}
+
+static const struct file_operations myfops = {
+  .owner = THIS_MODULE,
+  .open = myopen,
+  .release = myclose,
+  .unlocked_ioctl = myioctl,
+};
+
+static int myaudio_probe(struct platform_device *pdev)
+{
+  int ret;
+  struct snd_soc_card *card;
+
+  suniv_ioremap();
+  card = devm_kzalloc(&pdev->dev, sizeof(*card), GFP_KERNEL);
+  if (card == NULL) {
+    dev_err(&pdev->dev, "%s, failed to allocate memory for card\n", __func__);
+    return -ENOMEM; // sorry, no any error handling
+  }
+  card->dai_link = devm_kzalloc(&pdev->dev, sizeof(struct snd_soc_dai_link), GFP_KERNEL);
+  if (card->dai_link == NULL) {
+    dev_err(&pdev->dev, "%s, faild to create link\n", __func__);
+    return -ENOMEM; // sorry, no any error handling
+  }
+
+  ret = snd_soc_register_platform(&pdev->dev, &myplatform);
+  if (ret < 0) {
+    dev_err(&pdev->dev, "%s, failed to register platform(%d)\n", __func__, ret);
+    return ret; // sorry, no any error handling
+  }
+
+  ret = snd_soc_register_component(&pdev->dev, &mycodec_comp, &mycpu_dai, 1);
+  if (ret < 0) {
+    dev_err(&pdev->dev, "%s, failed to register dai\n", __func__);
+    return ret; // sorry, no any error handling
+  }
+
+  card->dev = &pdev->dev;
+  card->name = "miyoo audio card";
+  card->num_links = 1;
+  card->dai_link->name = dev_name(&pdev->dev);
+  card->dai_link->stream_name = dev_name(&pdev->dev);
+  card->dai_link->codec_dai_name = dev_name(&pdev->dev);
+  card->dai_link->cpu_dai_name = dev_name(&pdev->dev);
+  card->dai_link->codec_name = dev_name(&pdev->dev);
+  card->dai_link->platform_name = dev_name(&pdev->dev);
+  card->dai_link->dai_fmt = SND_SOC_DAIFMT_I2S;
+  card->dapm_widgets = mycard_dapm_widgets;
+  card->num_dapm_widgets = ARRAY_SIZE(mycard_dapm_widgets);
+  card->fully_routed = true;
+  snd_soc_card_set_drvdata(card, NULL);
+
+  ret = snd_soc_register_card(card);
+  if (ret) {
+    dev_err(&pdev->dev, "%s, failed to register card\n", __func__);
+    return ret; // sorry, no any error handling
+  }
+  
+  alloc_chrdev_region(&major, 0, 1, "miyoo_snd");
+  myclass = class_create(THIS_MODULE, "miyoo_snd");
+  device_create(myclass, NULL, major, NULL, "miyoo_snd");
+  cdev_init(&mycdev, &myfops);
+  cdev_add(&mycdev, major, 1);
+
+  suniv_gpio_init();
+  suniv_codec_init();
+  for(ret=0; ret<of_clk_get_parent_count(pdev->dev.of_node); ret++){
+    clk_prepare_enable(of_clk_get(pdev->dev.of_node, ret));
+  }
+  iomm.dma_trigger = 0;
+
+  iomm.irq = platform_get_irq(pdev, 0);
+  if (iomm.irq < 0) {
+    printk("%s, failed to get irq number\n", __func__);
+  }
+  else{
+	  if(request_irq(iomm.irq, dma_irq_handler, IRQF_SHARED, "miyoo_dma_irq", iomm.substream)) {
+      printk("%s, failed to register DMA interrupt\n", __func__);
+    }
+  }
+  return 0;
+}
+
+static const struct of_device_id myaudio_driver_of_match[] = {
+  {
+    .compatible = "allwinner,suniv-f1c500s-codec",
+  },{}
+};
+MODULE_DEVICE_TABLE(of, myaudio_driver_of_match);
+
+static struct platform_driver myaudio_driver = {
+  .driver = {
+    .name = "miyoo audio driver",
+    .of_match_table = myaudio_driver_of_match,
+  },
+  .probe = myaudio_probe,
+};
+module_platform_driver(myaudio_driver);
+
+MODULE_DESCRIPTION("Allwinner f1c500s audio codec driver");
+MODULE_AUTHOR("Steward Fu <steward.fu@gmail.com>");
+MODULE_LICENSE("GPL");
