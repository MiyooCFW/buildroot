#!/bin/busybox sh

BOOTLOGO="boot-logo"
export HOME=/mnt
export ROMS=/roms
export BOOTDIR=/boot # we expect /dev/mmcblk0p1 has been mounted here read only, from inittab
export SDL_NOMOUSE=1
START="${HOME}/autoexec.sh"

LOGS=/dev/null
LOGS_TEMP=/dev/null
UMTPR_LOGS=/dev/null
GMENU2X_LOGS=/dev/null

# check if it's first boot and turn on messages if yes
if (grep -sq DEBUG\=\1 "${HOME}/options.cfg" || test -r "${BOOTDIR}/firstboot" || test -r "${HOME}/firstboot.completed" || grep -sq FIRSTBOOT\=\1 "${HOME}/options.cfg"); then
	DEBUG_MSG="yes"
	LOGS="${HOME}/log.txt"
	GMENU2X_LOGS="${HOME}/log_gmenu2x.txt" # just standard stdout/stderr
	#UMTPR_LOGS=/dev/null # see description at umtprd cmd
fi
if (grep -sq DEBUG_GMENU2X\=\1 "${HOME}/options.cfg"); then
	DEBUG_GMENU2X="yes"
	GMENU2X_LOGS="${HOME}/log_gmenu2x.txt"
fi
if (grep -sq DEBUG_UMTPR\=\1 "${HOME}/options.cfg"); then
	DEBUG_UMTPR="yes"
	UMTPR_LOGS="${HOME}/log_umtpr.txt"
fi

if test "x${DEBUG_MSG}" == "xyes" || test "x${DEBUG_GMENU2X}" == "xyes" || test "x${DEBUG_UMTPR}" == "xyes"; then
	LOGS_TEMP=$(mktemp)
fi

export LOGS LOGS_TEMP # so that subshells can use this as well
export UMTPR_LOGS GMENU2X_LOGS
export DEBUG_MSG DEBUG_UMTPR DEBUG_GMENU2X

if test "x${DEBUG_MSG}" == "xyes"; then
	echo -e "\e[0m"    # normal foreground color
	export DEBUG_MSG   # set it globally for further programs
else
	echo -e "\e[30m"   # black foreground color
fi

restore_temp_log_func(){
	if test "x${DEBUG_UMTPR}" == "xyes"; then
		cat ${LOGS_TEMP} >> ${UMTPR_LOGS}
	else
		cat ${LOGS_TEMP} >> ${LOGS}
	fi
	LOGS_TEMP=$(mktemp)
	export LOGS_TEMP
}

! test -r "${HOME}/options.cfg"\
 && echo "Did not find valid ${HOME}/options.cfg file, using default configuration." >> ${LOGS}

# load kernel modules

# Load the expected one screen driver from here with modprobe 
## automatically from rootfs/lib/modules/VERSION
# The uEnv.txt is autogenerated by u-boot from HW which outputs
## environmental variables needed for ID of screen type
video=`cat /sys/kernel/miyoo_video/miyoo_video`

BACKLIGHT=$(cat ${HOME}/.backlight.conf)

# TVout scripting backend
if test -r "${HOME}/tvout"; then
	echo "Starting TVout video." >> "${LOGS}"
	echo 0 > /sys/class/backlight/backlight/brightness
	echo 0 > /sys/class/vtconsole/vtcon1/bind
	if test $BACKLIGHT -ne 0; then
		cp ${HOME}/.backlight.conf ${HOME}/.backlight.bak 2>&1 | tee -a "${LOGS}"
	fi
	echo 0 > ${HOME}/.backlight.conf
	modprobe -r $video 2>&1 | tee -a "${LOGS}"
	#TVMODE options.cfg setting 
	tvmode=$(grep -o TVMODE=[0-1] "${HOME}/options.cfg" | tr '[:upper:]' '[:lower:]')
	echo "Loding TV module miyoo-tvout with args tvmode=${tvmode}" >> "${LOGS}"
	modprobe miyoo-tvout $tvmode 2>&1 | tee -a "${LOGS}"
	echo 1 > /sys/class/vtconsole/vtcon1/bind
	modprobe -r $video 2>&1 | tee -a "${LOGS}"
else
	if ((test -r "${HOME}/.backlight.bak")); then
		mv ${HOME}/.backlight.bak ${HOME}/.backlight.conf
	fi
	# MODULES_CUSTOM scripting
	if (!(test -r "${BOOTDIR}/modules.custom.sh") || !(grep -sq MODULES_CUSTOM\=\1 "${HOME}/options.cfg")); then
		# Load video module read from uEnv.txt & defined by variant in console.cfg
		#FLIP & INVERT options.cfg setting
		flip=$(grep -o FLIP=[0-1] "${HOME}/options.cfg" | tr '[:upper:]' '[:lower:]')
		invert=$(grep -o INVERT=[0-1] "${HOME}/options.cfg" | tr '[:upper:]' '[:lower:]')
		echo "Loding video module ${video} with args flip=${flip} invert=${invert}" >> "${LOGS}"
		modprobe $video $flip $invert 2>&1 | tee -a "${LOGS}"
	else
		echo "Loding custom modules." >> "${LOGS}"
		(cd "${BOOTDIR}" && sh modules.custom.sh ) >> "${LOGS}" 2>&1
	fi
fi

# Load sound modules

cmdline=$(cat /proc/cmdline)
snd_val=$(echo "$cmdline" | sed -n 's/.*miyoo\.miyoo_snd=\([0-9]\+\).*/\1/p')

modprobe miyoo miyoo_snd="$snd_val" 2>&1 | tee -a "${LOGS}"

# check if it's first boot and defer to the firstboot script if yes
if grep -sq FIRSTBOOT\=\1 "${HOME}/options.cfg"; then
	test -r "${BOOTDIR}/firstboot.done" \
	 && sh "${BOOTDIR}/firstboot.done"
fi
if test -r "${BOOTDIR}/firstboot"; then
	sh "${BOOTDIR}/firstboot"
elif test -r "${HOME}/firstboot.completed"; then
	rm "${HOME}/firstboot.completed"
fi

if !(grep -sq FS_CHECK\=\0 "${HOME}/options.cfg"); then
##Check if BOOT (FAT16) is flagged as "dirty", and if so unmount, repair, remount
	if dmesg | grep "mmcblk0p1" > /dev/null;  then
		echo -e "\e[31mDirty sectors detected.\e[0m" | tee -a "${LOGS}"
		echo -e "\e[32mChecking&Repairing FAT16 BOOT partition...\e[0m" | tee -a "${LOGS}"
		umount /dev/mmcblk0p1 2>&1 | tee -a "${LOGS}"
		fsck.vfat -y /dev/mmcblk0p1 >> "${LOGS}" 2>&1
		mount /dev/mmcblk0p1 "${BOOTDIR}" -t vfat -o ro,exec,utf8 2>&1 | tee -a "${LOGS}"
		echo -e "\e[32mCheck complete.\e[0m" | tee -a "${LOGS}"
	fi
##Check if MAIN (EXT4) is flagged as "dirty", and if so unmount, repair, remount
	if dmesg | grep "EXT4-fs (mmcblk0p4): warning: mounting fs with errors, running e2fsck is recommended" > /dev/null;  then
		echo -e "\e[31mUnclean shutdown detected.\e[0m" | tee -a "${LOGS}"
		echo -e "\e[32mChecking MAIN(EXT4) partition...\e[0m" | tee -a "${LOGS}"
		umount /dev/mmcblk0p4 2>&1 | tee -a "${LOGS_TEMP}"
		e2fsck -y /dev/mmcblk0p4 >> "${LOGS_TEMP}";
		mount /dev/mmcblk0p4 "${HOME}" -o rw,sync,exec 2>&1 | tee -a "${LOGS_TEMP}"
		restore_temp_log_func
	fi
##Check if ROMS (EXT4 or FAT32) is flagged as "dirty", and if so unmount, repair, remount
	if dmesg | grep "EXT4-fs (mmcblk0p5): warning: mounting fs with errors, running e2fsck is recommended" > /dev/null;  then
		echo -e "\e[31mUnclean shutdown detected.\e[0m" | tee -a "${LOGS}"
		echo -e "\e[32mChecking ROMS(EXT4) partition...\e[0m" | tee -a "${LOGS}"
		umount /dev/mmcblk0p5 2>&1 | tee -a "${LOGS}"
		e2fsck -y /dev/mmcblk0p5 >> "${LOGS}" 2>&1; 
		mount /dev/mmcblk0p5 "${ROMS}" -o rw,noatime 2>&1 | tee -a "${LOGS}"
	elif dmesg | grep "FAT-fs (mmcblk0p5): Volume was not properly unmounted. Some data may be corrupt. Please run fsck." > /dev/null;  then
		echo -e "\e[31mDirty sectors detected.\e[0m" | tee -a "${LOGS}"
		echo -e "\e[32mChecking&Repairing ROMS(FAT32) partition...\e[0m" | tee -a "${LOGS}"
		umount /dev/mmcblk0p5 2>&1 | tee -a "${LOGS}"
		fsck.vfat -y /dev/mmcblk0p5 >> "${LOGS}" 2>&1
		mount /dev/mmcblk0p5 "${ROMS}" -t vfat -o rw,utf8 2>&1 | tee -a "${LOGS}"
		echo -e "\e[32mCheck complete.\e[0m" | tee -a "${LOGS}"
	fi
fi

clear
# try to read what handheld we're on
if test -r "${BOOTDIR}/console.cfg"; then
	source "${BOOTDIR}/console.cfg"
else
	export CONSOLE_VARIANT="unknown"
fi

# load usb modules & gadget
if (!(grep -sq USB_OTG\=\0 "${HOME}/options.cfg")); then
	if test -r "${HOME}/.usbmode"; then
		source ${HOME}/.usbmode
	else
		USB_MODE="mtp" # default setup
	fi
	echo "Loading USB ${USB_MODE} default gadget" >> "${LOGS}"
	usb-mode ${USB_MODE} 2>&1 | tee -a "${LOGS}"
	export USB_MODE
fi

echo "Boot!" >> "${LOGS}"
echo "Handheld type is ${CONSOLE_VARIANT}" >> "${LOGS}"

# run any custom commands ('daemon' expected to be run from there)
if test -r "${BOOTDIR}/normalboot.custom.sh" ; then
	(cd "${BOOTDIR}" && sh normalboot.custom.sh) # don't redirect, want output on screen
else
	# at least run 'daemon'
	daemon >> "${LOGS}" 2>&1
fi

# run boot logo animation
if (!(grep -sq BOOT_LOGO\=\0 "${HOME}/options.cfg")); then
	${BOOTLOGO} >> "${LOGS}" 2>&1
fi

# we could unmount /boot here but since it's read-only it doesn't hurt to leave it running
## umount /dev/mmcblk0p1

# Writes dmesg after firstboot procedure or if DEBUG_MSG=yes
if test "x${DEBUG_MSG}" == "xyes"; then
	sleep 1
	echo -en "\n\nNew DMESG log:\n" >> ${HOME}/dmesg.txt
	dmesg >> ${HOME}/dmesg.txt
	restore_temp_log_func
fi

while [ 1 ]
do
	if test -f "${START}"; then
		source "${START}"
	else
		echo "Starting GMenu2x" >> "${LOGS}"
		cd "${HOME}"/gmenu2x || { echo "Failed to cd into ${HOME}/gmenu2x" >> "${LOGS}" ; exit; }
		if test "x${DEBUG_GMENU2X}" == "xyes"; then
			gdb -ex="set confirm off" -ex=run -ex="bt full" -ex=q ./gmenu2x-debug >> "${GMENU2X_LOGS}" 2>&1
		else
			./gmenu2x >> "${GMENU2X_LOGS}" 2>&1
		fi
		if (test -r "${HOME}/.usbmode" && !(grep -sq USB_OTG\=\0 "${HOME}/options.cfg")); then
		 	source ${HOME}/.usbmode
			export USB_MODE
		fi
		test "x${DEBUG_UMTPR}" == "xyes"\
		 && restore_temp_log_func
	fi
	clear
done
