#!/bin/busybox sh

BOOTLOGO="boot-logo"
export HOME=/mnt
export ROMS=/roms
export BOOTDIR=/boot # we expect /dev/mmcblk0p1 has been mounted here read only, from inittab
export SDL_NOMOUSE=1
START="${HOME}/autoexec.sh"
export OPTIONS_CFG="${BOOTDIR}/options.cfg"
export CONSOLE_CFG="${BOOTDIR}/console.cfg"

LOGS=/dev/null
LOGS_TEMP=/dev/null
UMTPR_LOGS=/dev/null
GMENU2X_LOGS=/dev/null

FRONTEND_ACTIVE=false
test -f /tmp/frontend.active \
 && FRONTEND_ACTIVE=true
echo "FRONTEND active status: ${FRONTEND_ACTIVE}" >> ${LOGS}

! test -r "${OPTIONS_CFG}"\
 && echo "Did not find valid ${OPTIONS_CFG} file, using default configuration." >> ${LOGS}

# check if it's first boot and turn on messages if yes
if (grep -sq DEBUG\=\1 "${OPTIONS_CFG}" || test -r "${BOOTDIR}/firstboot" || test -r "${HOME}/firstboot.completed" || grep -sq FIRSTBOOT\=\1 "${OPTIONS_CFG}"); then
	DEBUG_MSG="yes"
	LOGS="${HOME}/log.txt"
	GMENU2X_LOGS="${HOME}/log_gmenu2x.txt" # just standard stdout/stderr
	#UMTPR_LOGS=/dev/null # see description at umtprd cmd
fi
if (grep -sq DEBUG_GMENU2X\=\1 "${OPTIONS_CFG}"); then
	DEBUG_GMENU2X="yes"
	GMENU2X_LOGS="${HOME}/log_gmenu2x.txt"
fi
if (grep -sq DEBUG_UMTPR\=\1 "${OPTIONS_CFG}"); then
	DEBUG_UMTPR="yes"
	UMTPR_LOGS="${HOME}/log_umtpr.txt"
fi

if test "x${DEBUG_MSG}" == "xyes" || test "x${DEBUG_GMENU2X}" == "xyes"; then
	LOGS_TEMP=$(mktemp)
fi

export LOGS LOGS_TEMP # so that subshells can use this as well
export UMTPR_LOGS GMENU2X_LOGS
export DEBUG_MSG DEBUG_UMTPR DEBUG_GMENU2X

if test "x${DEBUG_MSG}" == "xyes"; then
	echo -e "\e[0m"    # normal foreground color
else
	echo -e "\e[30m"   # black foreground color
fi

restore_temp_log_func(){
	cat ${LOGS_TEMP} >> ${LOGS}
	LOGS_TEMP=$(mktemp)
	export LOGS_TEMP
}

if ! $FRONTEND_ACTIVE; then
	# load kernel modules

	# Load the expected one screen driver from here with modprobe 
	## automatically from rootfs/lib/modules/VERSION
	# The uEnv.txt is autogenerated by u-boot from HW which outputs
	## environmental variables needed for ID of screen type
	video=$(cat /sys/kernel/miyoo_video/miyoo_video) \
	|| echo "Couldn't read video module from /sys/kernel/miyoo_video/miyoo_video" | tee -a "${LOGS}"

	test -r "${HOME}/.backlight.conf" \
	&& BACKLIGHT=$(cat ${HOME}/.backlight.conf) 

	# TVout scripting backend
	if ! test -r "${HOME}/.tvmode" || grep -sq TV_OUT\=\0 "${OPTIONS_CFG}"; then
		echo "0" > ${HOME}/.tvmode #default is OFF thus "0" this is inline with frontend (NTSC!=1, PAL=1 - in kernel)
	fi
	tvmode=$(cat ${HOME}/.tvmode)
	if test $tvmode -eq 0 && grep -sq TV_OUT\=\1 "${OPTIONS_CFG}"; then
		tvmode=1;
	fi
	if test $tvmode -ne 0 && ! test -z "$tvmode"; then
		TVOUT="ON"
		if grep -sq TV_OUT\=\0 "${OPTIONS_CFG}" || grep -sq TV_OUT\=\1 "${OPTIONS_CFG}"; then
			unset TVOUT #since we have no real idea what video backend should be running when forcing TVout
		fi
		echo "Starting TVout video." >> "${LOGS}"
		echo 0 > /sys/class/backlight/backlight/brightness 2>>"$LOGS"
		echo 0 > /sys/class/vtconsole/vtcon1/bind 2>>"$LOGS"
		if test $BACKLIGHT -ne 0; then
			cp ${HOME}/.backlight.conf ${HOME}/.backlight.bak 2>&1 | tee -a "${LOGS}"
		fi
		echo 0 > ${HOME}/.backlight.conf
		echo "Loading TV module miyoo-tvout with args tvmode=${tvmode}" >> "${LOGS}"
		if (modprobe miyoo-tvout $tvmode >> "${LOGS}" 2>&1); then
			echo "Loaded TV-out with tvmode=${tvmode}" | tee -a "${LOGS}"
		fi
		echo 1 > /sys/class/vtconsole/vtcon1/bind 2>>"$LOGS"
	else
		TVOUT="OFF"
		if test -r "${HOME}/.backlight.bak"; then
			mv ${HOME}/.backlight.bak ${HOME}/.backlight.conf
		fi
		# MODULES_CUSTOM scripting
		if ( ! test -r "${BOOTDIR}/modules.custom.sh" || ! grep -sq MODULES_CUSTOM\=\1 "${OPTIONS_CFG}"); then
			# Load video module read from uEnv.txt & defined by variant in console.cfg
			#FLIP & INVERT options.cfg setting
			flip=$(grep -o FLIP=[0-1] "${OPTIONS_CFG}" | tr '[:upper:]' '[:lower:]')
			invert=$(grep -o INVERT=[0-1] "${OPTIONS_CFG}" | tr '[:upper:]' '[:lower:]')
			echo "Loading video module ${video} with args flip=${flip} invert=${invert}" >> "${LOGS}"
			if (modprobe $video $flip $invert >> "${LOGS}" 2>&1); then
				echo "Loaded video with flip=${flip} invert=${invert}" | tee -a "${LOGS}"
			fi
		else
			echo "Loading custom modules." | tee -a "${LOGS}"
			(cd "${BOOTDIR}" && sh modules.custom.sh ) >> "${LOGS}" 2>&1
		fi
	fi
	export TVOUT

	# Load sound modules
	if cmdline=$(cat /proc/cmdline 2>/dev/null | tee -a "${LOGS}"); then
		snd_val=$(echo "$cmdline" | sed -n 's/.*miyoo\.miyoo_snd=\([0-9]\+\).*/\1/p')
		test -z "$snd_val" && snd_val=1 # default to 1 from kernel, otherwise module fails to load
		tvjack_val=$(echo "$cmdline" | sed -n 's/.*miyoo\.miyoo_tvjack=\([0-9]\+\).*/\1/p')
		test -z "$tvjack_val" && tvjack_val=0 # default to 0 from kernel, otherwise module fails to load
		echo "Loading sound module miyoo with args miyoo_snd=${snd_val} miyoo_tvjack=${tvjack_val} " | tee -a "${LOGS}"
		modprobe miyoo miyoo_snd="$snd_val" miyoo_tvjack="$tvjack_val" 2>&1 | tee -a "${LOGS}"
	else
		echo "Couldn't read /proc/cmdline, loading miyoo_snd with default args" | tee -a "${LOGS}"
		modprobe miyoo 2>&1 | tee -a "${LOGS}"
	fi

	# check if it's first boot and defer to the firstboot script if yes
	if grep -sq FIRSTBOOT\=\1 "${OPTIONS_CFG}"; then
		test -r "${BOOTDIR}/firstboot.done" \
		&& sh "${BOOTDIR}/firstboot.done"
	fi
	if test -r "${BOOTDIR}/firstboot"; then
		sh "${BOOTDIR}/firstboot"
	elif test -r "${HOME}/firstboot.completed"; then
		rm "${HOME}/firstboot.completed"
	fi

	if ! (grep -sq FS_CHECK\=\0 "${OPTIONS_CFG}"); then
	##Check if BOOT (FAT16) is flagged as "dirty", and if so unmount, repair, remount
		if dmesg | grep "mmcblk0p1" > /dev/null;  then
			echo -e "\e[31mDirty sectors detected.\e[0m" | tee -a "${LOGS}"
			echo -e "\e[32mChecking&Repairing FAT16 BOOT partition...\e[0m" | tee -a "${LOGS}"
			umount /dev/mmcblk0p1 2>&1 | tee -a "${LOGS}"
			fsck.vfat -y /dev/mmcblk0p1 >> "${LOGS}" 2>&1
			mount /dev/mmcblk0p1 "${BOOTDIR}" -t vfat -o ro,exec,utf8 2>&1 | tee -a "${LOGS}"
			echo -e "\e[32mCheck complete.\e[0m" | tee -a "${LOGS}"
		fi
	##Check if MAIN (EXT4) is flagged as "dirty", and if so unmount, repair, remount
		if dmesg | grep "EXT4-fs (mmcblk0p4): warning: mounting fs with errors, running e2fsck is recommended" > /dev/null;  then
			echo -e "\e[31mUnclean shutdown detected.\e[0m" | tee -a "${LOGS}"
			echo -e "\e[32mChecking MAIN(EXT4) partition...\e[0m" | tee -a "${LOGS}"
			umount /dev/mmcblk0p4 2>&1 | tee -a "${LOGS_TEMP}"
			e2fsck -y /dev/mmcblk0p4 >> "${LOGS_TEMP}";
			mount /dev/mmcblk0p4 "${HOME}" -o rw,sync,exec 2>&1 | tee -a "${LOGS_TEMP}"
			test "x${DEBUG_MSG}" == "xyes"\
			&& restore_temp_log_func
		fi
	##Check if ROMS (EXT4 or FAT32) is flagged as "dirty", and if so unmount, repair, remount
		if dmesg | grep "EXT4-fs (mmcblk0p5): warning: mounting fs with errors, running e2fsck is recommended" > /dev/null;  then
			echo -e "\e[31mUnclean shutdown detected.\e[0m" | tee -a "${LOGS}"
			echo -e "\e[32mChecking ROMS(EXT4) partition...\e[0m" | tee -a "${LOGS}"
			umount /dev/mmcblk0p5 2>&1 | tee -a "${LOGS}"
			e2fsck -y /dev/mmcblk0p5 >> "${LOGS}" 2>&1; 
			mount /dev/mmcblk0p5 "${ROMS}" -o rw,noatime 2>&1 | tee -a "${LOGS}"
		elif dmesg | grep "FAT-fs (mmcblk0p5): Volume was not properly unmounted. Some data may be corrupt. Please run fsck." > /dev/null;  then
			echo -e "\e[31mDirty sectors detected.\e[0m" | tee -a "${LOGS}"
			echo -e "\e[32mChecking&Repairing ROMS(FAT32) partition...\e[0m" | tee -a "${LOGS}"
			umount /dev/mmcblk0p5 2>&1 | tee -a "${LOGS}"
			fsck.vfat -y /dev/mmcblk0p5 >> "${LOGS}" 2>&1
			mount /dev/mmcblk0p5 "${ROMS}" -t vfat -o rw,utf8 2>&1 | tee -a "${LOGS}"
			echo -e "\e[32mCheck complete.\e[0m" | tee -a "${LOGS}"
		fi
	fi

	# try to read what handheld we're on
	if test -r "${BOOTDIR}/console.cfg"; then
		source "${BOOTDIR}/console.cfg"
	else
		CONSOLE_VARIANT="unknown"
	fi
	export CONSOLE_VARIANT

	# load usb modules & gadget
	if ! (grep -sq USB_OTG\=\0 "${OPTIONS_CFG}"); then
		if test -r "${HOME}/.usbmode"; then
			source ${HOME}/.usbmode
		else
			USB_MODE="mtp" # default setup
		fi
		echo "Loading USB ${USB_MODE} default gadget" | tee -a "${LOGS}"
		usb-mode ${USB_MODE} 2>&1 | tee -a "${LOGS}"
		export USB_MODE
	fi

	echo "Boot!" | tee -a "${LOGS}"
	echo "Handheld type is ${CONSOLE_VARIANT}" | tee -a "${LOGS}"

	# run any custom commands ('daemon' expected to be run from there)
	if test -r "${BOOTDIR}/normalboot.custom.sh" ; then
		(cd "${BOOTDIR}" && sh normalboot.custom.sh) # don't redirect, want output on screen
	else
		# at least run 'daemon'
		daemon >> "${LOGS}" 2>&1
	fi

	# run boot logo animation
	if ! (grep -sq BOOT_LOGO\=\0 "${OPTIONS_CFG}"); then
		${BOOTLOGO} >> "${LOGS}" 2>&1
	fi

	# we could unmount /boot here but since it's read-only it doesn't hurt to leave it running
	## umount /dev/mmcblk0p1

	# Writes dmesg after firstboot procedure or if DEBUG_MSG=yes
	if test "x${DEBUG_MSG}" == "xyes"; then
		sleep 1
		echo -en "\n\nNew DMESG log:\n" >> ${HOME}/dmesg.txt
		dmesg >> ${HOME}/dmesg.txt
		restore_temp_log_func
	fi
fi

clear
if test -f "${START}"; then
	echo "Starting ${START} script." | tee -a "${LOGS}"
	source "${START}" >> "${LOGS}" 2>&1
else
	echo "Starting GMenu2x" >> "${LOGS}"
	cd "${HOME}"/gmenu2x || { echo "Failed to cd into ${HOME}/gmenu2x" >> "${LOGS}" ; exit; }
	if test "x${DEBUG_GMENU2X}" == "xyes"; then
		gdb -ex="set confirm off" -ex=run -ex="bt full" -ex=q ./gmenu2x-debug 2>&1 | tee -a "${GMENU2X_LOGS}"
	else
		./gmenu2x >> "${GMENU2X_LOGS}" 2>&1
	fi
fi

touch /tmp/frontend.active 2>&1 | tee -a "${LOGS}"
echo -en "\n\nOops what are u doing here?\nEnding /etc/main run..." | tee -a "${LOGS}"
sleep 2
clear
